// autogenerated

use volatile;
use bit_field::BitField;

# [ doc = "Digital camera interface" ]
# [ repr ( C ) ]
pub struct Dcmi {
    # [ doc = "0x00 - control register 1" ]
    pub cr: volatile::ReadWrite<Cr>,
    # [ doc = "0x04 - status register" ]
    pub sr: volatile::ReadOnly<Sr>,
    # [ doc = "0x08 - raw interrupt status register" ]
    pub ris: volatile::ReadOnly<Ris>,
    # [ doc = "0x0c - interrupt enable register" ]
    pub ier: volatile::ReadWrite<Ier>,
    # [ doc = "0x10 - masked interrupt status register" ]
    pub mis: volatile::ReadOnly<Mis>,
    # [ doc = "0x14 - interrupt clear register" ]
    pub icr: volatile::WriteOnly<Icr>,
    # [ doc = "0x18 - embedded synchronization code register" ]
    pub escr: volatile::ReadWrite<Escr>,
    # [ doc = "0x1c - embedded synchronization unmask register" ]
    pub esur: volatile::ReadWrite<Esur>,
    # [ doc = "0x20 - crop window start" ]
    pub cwstrt: volatile::ReadWrite<Cwstrt>,
    # [ doc = "0x24 - crop window size" ]
    pub cwsize: volatile::ReadWrite<Cwsize>,
    # [ doc = "0x28 - data register" ]
    pub dr: volatile::ReadOnly<Dr>,
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Cr {
    bits: u32,
}

impl Cr {
    # [ doc = "Bit 14 - DCMI enable" ]
    pub fn enable(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bits 10:11 - Extended data mode" ]
    pub fn edm(&self) -> u8 {
        self.bits.get_range(10u8..12u8) as u8
    }
    # [ doc = "Bits 8:9 - Frame capture rate control" ]
    pub fn fcrc(&self) -> u8 {
        self.bits.get_range(8u8..10u8) as u8
    }
    # [ doc = "Bit 7 - Vertical synchronization polarity" ]
    pub fn vspol(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 6 - Horizontal synchronization polarity" ]
    pub fn hspol(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 5 - Pixel clock polarity" ]
    pub fn pckpol(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Embedded synchronization select" ]
    pub fn ess(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - JPEG format" ]
    pub fn jpeg(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Crop feature" ]
    pub fn crop(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Capture mode" ]
    pub fn cm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Capture enable" ]
    pub fn capture(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Cr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Cr { bits: 0u32 }
    }
}

impl Cr {
    # [ doc = "Bit 14 - DCMI enable" ]
    pub fn set_enable(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bits 10:11 - Extended data mode" ]
    pub fn set_edm(&mut self, value: u8) {
        self.bits.set_range(10u8..12u8, value as u32);
    }
    # [ doc = "Bits 8:9 - Frame capture rate control" ]
    pub fn set_fcrc(&mut self, value: u8) {
        self.bits.set_range(8u8..10u8, value as u32);
    }
    # [ doc = "Bit 7 - Vertical synchronization polarity" ]
    pub fn set_vspol(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 6 - Horizontal synchronization polarity" ]
    pub fn set_hspol(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 5 - Pixel clock polarity" ]
    pub fn set_pckpol(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Embedded synchronization select" ]
    pub fn set_ess(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - JPEG format" ]
    pub fn set_jpeg(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Crop feature" ]
    pub fn set_crop(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Capture mode" ]
    pub fn set_cm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Capture enable" ]
    pub fn set_capture(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Sr {
    bits: u32,
}

impl Sr {
    # [ doc = "Bit 2 - FIFO not empty" ]
    pub fn fne(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - VSYNC" ]
    pub fn vsync(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - HSYNC" ]
    pub fn hsync(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Sr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Sr { bits: 0u32 }
    }
}

impl Sr {
    # [ doc = "Bit 2 - FIFO not empty" ]
    pub fn set_fne(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - VSYNC" ]
    pub fn set_vsync(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - HSYNC" ]
    pub fn set_hsync(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ris {
    bits: u32,
}

impl Ris {
    # [ doc = "Bit 4 - Line raw interrupt status" ]
    pub fn line_ris(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - VSYNC raw interrupt status" ]
    pub fn vsync_ris(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Synchronization error raw interrupt status" ]
    pub fn err_ris(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Overrun raw interrupt status" ]
    pub fn ovr_ris(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Capture complete raw interrupt status" ]
    pub fn frame_ris(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Ris {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ris { bits: 0u32 }
    }
}

impl Ris {
    # [ doc = "Bit 4 - Line raw interrupt status" ]
    pub fn set_line_ris(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - VSYNC raw interrupt status" ]
    pub fn set_vsync_ris(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Synchronization error raw interrupt status" ]
    pub fn set_err_ris(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Overrun raw interrupt status" ]
    pub fn set_ovr_ris(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Capture complete raw interrupt status" ]
    pub fn set_frame_ris(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ier {
    bits: u32,
}

impl Ier {
    # [ doc = "Bit 4 - Line interrupt enable" ]
    pub fn line_ie(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - VSYNC interrupt enable" ]
    pub fn vsync_ie(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Synchronization error interrupt enable" ]
    pub fn err_ie(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Overrun interrupt enable" ]
    pub fn ovr_ie(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Capture complete interrupt enable" ]
    pub fn frame_ie(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Ier {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ier { bits: 0u32 }
    }
}

impl Ier {
    # [ doc = "Bit 4 - Line interrupt enable" ]
    pub fn set_line_ie(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - VSYNC interrupt enable" ]
    pub fn set_vsync_ie(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Synchronization error interrupt enable" ]
    pub fn set_err_ie(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Overrun interrupt enable" ]
    pub fn set_ovr_ie(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Capture complete interrupt enable" ]
    pub fn set_frame_ie(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Mis {
    bits: u32,
}

impl Mis {
    # [ doc = "Bit 4 - Line masked interrupt status" ]
    pub fn line_mis(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - VSYNC masked interrupt status" ]
    pub fn vsync_mis(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Synchronization error masked interrupt status" ]
    pub fn err_mis(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Overrun masked interrupt status" ]
    pub fn ovr_mis(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Capture complete masked interrupt status" ]
    pub fn frame_mis(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Mis {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Mis { bits: 0u32 }
    }
}

impl Mis {
    # [ doc = "Bit 4 - Line masked interrupt status" ]
    pub fn set_line_mis(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - VSYNC masked interrupt status" ]
    pub fn set_vsync_mis(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Synchronization error masked interrupt status" ]
    pub fn set_err_mis(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Overrun masked interrupt status" ]
    pub fn set_ovr_mis(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Capture complete masked interrupt status" ]
    pub fn set_frame_mis(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Icr {
    bits: u32,
}

impl Icr {
    # [ doc = "Bit 4 - line interrupt status clear" ]
    pub fn line_isc(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Vertical synch interrupt status clear" ]
    pub fn vsync_isc(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Synchronization error interrupt status clear" ]
    pub fn err_isc(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Overrun interrupt status clear" ]
    pub fn ovr_isc(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Capture complete interrupt status clear" ]
    pub fn frame_isc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Icr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Icr { bits: 0u32 }
    }
}

impl Icr {
    # [ doc = "Bit 4 - line interrupt status clear" ]
    pub fn set_line_isc(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Vertical synch interrupt status clear" ]
    pub fn set_vsync_isc(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Synchronization error interrupt status clear" ]
    pub fn set_err_isc(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Overrun interrupt status clear" ]
    pub fn set_ovr_isc(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Capture complete interrupt status clear" ]
    pub fn set_frame_isc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Escr {
    bits: u32,
}

impl Escr {
    # [ doc = "Bits 24:31 - Frame end delimiter code" ]
    pub fn fec(&self) -> u8 {
        self.bits.get_range(24u8..32u8) as u8
    }
    # [ doc = "Bits 16:23 - Line end delimiter code" ]
    pub fn lec(&self) -> u8 {
        self.bits.get_range(16u8..24u8) as u8
    }
    # [ doc = "Bits 8:15 - Line start delimiter code" ]
    pub fn lsc(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bits 0:7 - Frame start delimiter code" ]
    pub fn fsc(&self) -> u8 {
        self.bits.get_range(0u8..8u8) as u8
    }
}

impl Default for Escr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Escr { bits: 0u32 }
    }
}

impl Escr {
    # [ doc = "Bits 24:31 - Frame end delimiter code" ]
    pub fn set_fec(&mut self, value: u8) {
        self.bits.set_range(24u8..32u8, value as u32);
    }
    # [ doc = "Bits 16:23 - Line end delimiter code" ]
    pub fn set_lec(&mut self, value: u8) {
        self.bits.set_range(16u8..24u8, value as u32);
    }
    # [ doc = "Bits 8:15 - Line start delimiter code" ]
    pub fn set_lsc(&mut self, value: u8) {
        self.bits.set_range(8u8..16u8, value as u32);
    }
    # [ doc = "Bits 0:7 - Frame start delimiter code" ]
    pub fn set_fsc(&mut self, value: u8) {
        self.bits.set_range(0u8..8u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Esur {
    bits: u32,
}

impl Esur {
    # [ doc = "Bits 24:31 - Frame end delimiter unmask" ]
    pub fn feu(&self) -> u8 {
        self.bits.get_range(24u8..32u8) as u8
    }
    # [ doc = "Bits 16:23 - Line end delimiter unmask" ]
    pub fn leu(&self) -> u8 {
        self.bits.get_range(16u8..24u8) as u8
    }
    # [ doc = "Bits 8:15 - Line start delimiter unmask" ]
    pub fn lsu(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bits 0:7 - Frame start delimiter unmask" ]
    pub fn fsu(&self) -> u8 {
        self.bits.get_range(0u8..8u8) as u8
    }
}

impl Default for Esur {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Esur { bits: 0u32 }
    }
}

impl Esur {
    # [ doc = "Bits 24:31 - Frame end delimiter unmask" ]
    pub fn set_feu(&mut self, value: u8) {
        self.bits.set_range(24u8..32u8, value as u32);
    }
    # [ doc = "Bits 16:23 - Line end delimiter unmask" ]
    pub fn set_leu(&mut self, value: u8) {
        self.bits.set_range(16u8..24u8, value as u32);
    }
    # [ doc = "Bits 8:15 - Line start delimiter unmask" ]
    pub fn set_lsu(&mut self, value: u8) {
        self.bits.set_range(8u8..16u8, value as u32);
    }
    # [ doc = "Bits 0:7 - Frame start delimiter unmask" ]
    pub fn set_fsu(&mut self, value: u8) {
        self.bits.set_range(0u8..8u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Cwstrt {
    bits: u32,
}

impl Cwstrt {
    # [ doc = "Bits 16:28 - Vertical start line count" ]
    pub fn vst(&self) -> u16 {
        self.bits.get_range(16u8..29u8) as u16
    }
    # [ doc = "Bits 0:13 - Horizontal offset count" ]
    pub fn hoffcnt(&self) -> u16 {
        self.bits.get_range(0u8..14u8) as u16
    }
}

impl Default for Cwstrt {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Cwstrt { bits: 0u32 }
    }
}

impl Cwstrt {
    # [ doc = "Bits 16:28 - Vertical start line count" ]
    pub fn set_vst(&mut self, value: u16) {
        self.bits.set_range(16u8..29u8, value as u32);
    }
    # [ doc = "Bits 0:13 - Horizontal offset count" ]
    pub fn set_hoffcnt(&mut self, value: u16) {
        self.bits.set_range(0u8..14u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Cwsize {
    bits: u32,
}

impl Cwsize {
    # [ doc = "Bits 16:29 - Vertical line count" ]
    pub fn vline(&self) -> u16 {
        self.bits.get_range(16u8..30u8) as u16
    }
    # [ doc = "Bits 0:13 - Capture count" ]
    pub fn capcnt(&self) -> u16 {
        self.bits.get_range(0u8..14u8) as u16
    }
}

impl Default for Cwsize {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Cwsize { bits: 0u32 }
    }
}

impl Cwsize {
    # [ doc = "Bits 16:29 - Vertical line count" ]
    pub fn set_vline(&mut self, value: u16) {
        self.bits.set_range(16u8..30u8, value as u32);
    }
    # [ doc = "Bits 0:13 - Capture count" ]
    pub fn set_capcnt(&mut self, value: u16) {
        self.bits.set_range(0u8..14u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Dr {
    bits: u32,
}

impl Dr {
    # [ doc = "Bits 24:31 - Data byte 3" ]
    pub fn byte3(&self) -> u8 {
        self.bits.get_range(24u8..32u8) as u8
    }
    # [ doc = "Bits 16:23 - Data byte 2" ]
    pub fn byte2(&self) -> u8 {
        self.bits.get_range(16u8..24u8) as u8
    }
    # [ doc = "Bits 8:15 - Data byte 1" ]
    pub fn byte1(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bits 0:7 - Data byte 0" ]
    pub fn byte0(&self) -> u8 {
        self.bits.get_range(0u8..8u8) as u8
    }
}

impl Default for Dr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Dr { bits: 0u32 }
    }
}

impl Dr {
    # [ doc = "Bits 24:31 - Data byte 3" ]
    pub fn set_byte3(&mut self, value: u8) {
        self.bits.set_range(24u8..32u8, value as u32);
    }
    # [ doc = "Bits 16:23 - Data byte 2" ]
    pub fn set_byte2(&mut self, value: u8) {
        self.bits.set_range(16u8..24u8, value as u32);
    }
    # [ doc = "Bits 8:15 - Data byte 1" ]
    pub fn set_byte1(&mut self, value: u8) {
        self.bits.set_range(8u8..16u8, value as u32);
    }
    # [ doc = "Bits 0:7 - Data byte 0" ]
    pub fn set_byte0(&mut self, value: u8) {
        self.bits.set_range(0u8..8u8, value as u32);
    }
}
