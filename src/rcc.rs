// autogenerated

use volatile;
use bit_field::BitField;

# [ doc = "Reset and clock control" ]
# [ repr ( C ) ]
pub struct Rcc {
    # [ doc = "0x00 - clock control register" ]
    pub cr: volatile::ReadWrite<Cr>,
    # [ doc = "0x04 - PLL configuration register" ]
    pub pllcfgr: volatile::ReadWrite<Pllcfgr>,
    # [ doc = "0x08 - clock configuration register" ]
    pub cfgr: volatile::ReadWrite<Cfgr>,
    # [ doc = "0x0c - clock interrupt register" ]
    pub cir: volatile::ReadWrite<Cir>,
    # [ doc = "0x10 - AHB1 peripheral reset register" ]
    pub ahb1rstr: volatile::ReadWrite<Ahb1rstr>,
    # [ doc = "0x14 - AHB2 peripheral reset register" ]
    pub ahb2rstr: volatile::ReadWrite<Ahb2rstr>,
    # [ doc = "0x18 - AHB3 peripheral reset register" ]
    pub ahb3rstr: volatile::ReadWrite<Ahb3rstr>,
    _reserved0: [u8; 4usize],
    # [ doc = "0x20 - APB1 peripheral reset register" ]
    pub apb1rstr: volatile::ReadWrite<Apb1rstr>,
    # [ doc = "0x24 - APB2 peripheral reset register" ]
    pub apb2rstr: volatile::ReadWrite<Apb2rstr>,
    _reserved1: [u8; 8usize],
    # [ doc = "0x30 - AHB1 peripheral clock register" ]
    pub ahb1enr: volatile::ReadWrite<Ahb1enr>,
    # [ doc = "0x34 - AHB2 peripheral clock enable register" ]
    pub ahb2enr: volatile::ReadWrite<Ahb2enr>,
    # [ doc = "0x38 - AHB3 peripheral clock enable register" ]
    pub ahb3enr: volatile::ReadWrite<Ahb3enr>,
    _reserved2: [u8; 4usize],
    # [ doc = "0x40 - APB1 peripheral clock enable register" ]
    pub apb1enr: volatile::ReadWrite<Apb1enr>,
    # [ doc = "0x44 - APB2 peripheral clock enable register" ]
    pub apb2enr: volatile::ReadWrite<Apb2enr>,
    _reserved3: [u8; 8usize],
    # [ doc = "0x50 - AHB1 peripheral clock enable in low power mode register" ]
    pub ahb1lpenr: volatile::ReadWrite<Ahb1lpenr>,
    # [ doc = "0x54 - AHB2 peripheral clock enable in low power mode register" ]
    pub ahb2lpenr: volatile::ReadWrite<Ahb2lpenr>,
    # [ doc = "0x58 - AHB3 peripheral clock enable in low power mode register" ]
    pub ahb3lpenr: volatile::ReadWrite<Ahb3lpenr>,
    _reserved4: [u8; 4usize],
    # [ doc = "0x60 - APB1 peripheral clock enable in low power mode register" ]
    pub apb1lpenr: volatile::ReadWrite<Apb1lpenr>,
    # [ doc = "0x64 - APB2 peripheral clock enabled in low power mode register" ]
    pub apb2lpenr: volatile::ReadWrite<Apb2lpenr>,
    _reserved5: [u8; 8usize],
    # [ doc = "0x70 - Backup domain control register" ]
    pub bdcr: volatile::ReadWrite<Bdcr>,
    # [ doc = "0x74 - clock control & status register" ]
    pub csr: volatile::ReadWrite<Csr>,
    _reserved6: [u8; 8usize],
    # [ doc = "0x80 - spread spectrum clock generation register" ]
    pub sscgr: volatile::ReadWrite<Sscgr>,
    # [ doc = "0x84 - PLLI2S configuration register" ]
    pub plli2scfgr: volatile::ReadWrite<Plli2scfgr>,
    # [ doc = "0x88 - PLL configuration register" ]
    pub pllsaicfgr: volatile::ReadWrite<Pllsaicfgr>,
    # [ doc = "0x8c - dedicated clocks configuration register" ]
    pub dkcfgr1: volatile::ReadWrite<Dkcfgr1>,
    # [ doc = "0x90 - dedicated clocks configuration register" ]
    pub dkcfgr2: volatile::ReadWrite<Dkcfgr2>,
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Cr {
    bits: u32,
}

impl Cr {
    # [ doc = "Bit 29 - PLLSAI clock ready flag" ]
    pub fn pllsairdy(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 28 - PLLSAI enable" ]
    pub fn pllsaion(&self) -> bool {
        self.bits.get_bit(28u8)
    }
    # [ doc = "Bit 27 - PLLI2S clock ready flag" ]
    pub fn plli2srdy(&self) -> bool {
        self.bits.get_bit(27u8)
    }
    # [ doc = "Bit 26 - PLLI2S enable" ]
    pub fn plli2son(&self) -> bool {
        self.bits.get_bit(26u8)
    }
    # [ doc = "Bit 25 - Main PLL (PLL) clock ready flag" ]
    pub fn pllrdy(&self) -> bool {
        self.bits.get_bit(25u8)
    }
    # [ doc = "Bit 24 - Main PLL (PLL) enable" ]
    pub fn pllon(&self) -> bool {
        self.bits.get_bit(24u8)
    }
    # [ doc = "Bit 19 - Clock security system enable" ]
    pub fn csson(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 18 - HSE clock bypass" ]
    pub fn hsebyp(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 17 - HSE clock ready flag" ]
    pub fn hserdy(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bit 16 - HSE clock enable" ]
    pub fn hseon(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bits 8:15 - Internal high-speed clock calibration" ]
    pub fn hsical(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bits 3:7 - Internal high-speed clock trimming" ]
    pub fn hsitrim(&self) -> u8 {
        self.bits.get_range(3u8..8u8) as u8
    }
    # [ doc = "Bit 1 - Internal high-speed clock ready flag" ]
    pub fn hsirdy(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Internal high-speed clock enable" ]
    pub fn hsion(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Cr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Cr { bits: 131u32 }
    }
}

impl Cr {
    # [ doc = "Bit 28 - PLLSAI enable" ]
    pub fn set_pllsaion(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 26 - PLLI2S enable" ]
    pub fn set_plli2son(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 24 - Main PLL (PLL) enable" ]
    pub fn set_pllon(&mut self, value: bool) {
        self.bits.set_bit(24u8, value);
    }
    # [ doc = "Bit 19 - Clock security system enable" ]
    pub fn set_csson(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 18 - HSE clock bypass" ]
    pub fn set_hsebyp(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 16 - HSE clock enable" ]
    pub fn set_hseon(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bits 3:7 - Internal high-speed clock trimming" ]
    pub fn set_hsitrim(&mut self, value: u8) {
        self.bits.set_range(3u8..8u8, value as u32);
    }
    # [ doc = "Bit 0 - Internal high-speed clock enable" ]
    pub fn set_hsion(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Pllcfgr {
    bits: u32,
}

impl Pllcfgr {
    # [ doc = "Bits 24:27 - Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks" ]
    pub fn pllq(&self) -> u8 {
        self.bits.get_range(24u8..28u8) as u8
    }
    # [ doc = "Bit 22 - Main PLL(PLL) and audio PLL (PLLI2S) entry clock source" ]
    pub fn pllsrc(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bits 16:17 - Main PLL (PLL) division factor for main system clock" ]
    pub fn pllp(&self) -> u8 {
        self.bits.get_range(16u8..18u8) as u8
    }
    # [ doc = "Bits 6:14 - Main PLL (PLL) multiplication factor for VCO" ]
    pub fn plln(&self) -> u16 {
        self.bits.get_range(6u8..15u8) as u16
    }
    # [ doc = "Bits 0:5 - Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock" ]
    pub fn pllm(&self) -> u8 {
        self.bits.get_range(0u8..6u8) as u8
    }
}

impl Default for Pllcfgr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Pllcfgr { bits: 603992080u32 }
    }
}

impl Pllcfgr {
    # [ doc = "Bits 24:27 - Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks" ]
    pub fn set_pllq(&mut self, value: u8) {
        self.bits.set_range(24u8..28u8, value as u32);
    }
    # [ doc = "Bit 22 - Main PLL(PLL) and audio PLL (PLLI2S) entry clock source" ]
    pub fn set_pllsrc(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bits 16:17 - Main PLL (PLL) division factor for main system clock" ]
    pub fn set_pllp(&mut self, value: u8) {
        self.bits.set_range(16u8..18u8, value as u32);
    }
    # [ doc = "Bits 6:14 - Main PLL (PLL) multiplication factor for VCO" ]
    pub fn set_plln(&mut self, value: u16) {
        self.bits.set_range(6u8..15u8, value as u32);
    }
    # [ doc = "Bits 0:5 - Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock" ]
    pub fn set_pllm(&mut self, value: u8) {
        self.bits.set_range(0u8..6u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Cfgr {
    bits: u32,
}

impl Cfgr {
    # [ doc = "Bits 30:31 - Microcontroller clock output 2" ]
    pub fn mco2(&self) -> u8 {
        self.bits.get_range(30u8..32u8) as u8
    }
    # [ doc = "Bits 27:29 - MCO2 prescaler" ]
    pub fn mco2pre(&self) -> u8 {
        self.bits.get_range(27u8..30u8) as u8
    }
    # [ doc = "Bits 24:26 - MCO1 prescaler" ]
    pub fn mco1pre(&self) -> u8 {
        self.bits.get_range(24u8..27u8) as u8
    }
    # [ doc = "Bit 23 - I2S clock selection" ]
    pub fn i2ssrc(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bits 21:22 - Microcontroller clock output 1" ]
    pub fn mco1(&self) -> u8 {
        self.bits.get_range(21u8..23u8) as u8
    }
    # [ doc = "Bits 16:20 - HSE division factor for RTC clock" ]
    pub fn rtcpre(&self) -> u8 {
        self.bits.get_range(16u8..21u8) as u8
    }
    # [ doc = "Bits 13:15 - APB high-speed prescaler (APB2)" ]
    pub fn ppre2(&self) -> u8 {
        self.bits.get_range(13u8..16u8) as u8
    }
    # [ doc = "Bits 10:12 - APB Low speed prescaler (APB1)" ]
    pub fn ppre1(&self) -> u8 {
        self.bits.get_range(10u8..13u8) as u8
    }
    # [ doc = "Bits 4:7 - AHB prescaler" ]
    pub fn hpre(&self) -> u8 {
        self.bits.get_range(4u8..8u8) as u8
    }
    # [ doc = "Bits 2:3 - System clock switch status" ]
    pub fn sws(&self) -> u8 {
        self.bits.get_range(2u8..4u8) as u8
    }
    # [ doc = "Bits 0:1 - System clock switch" ]
    pub fn sw(&self) -> u8 {
        self.bits.get_range(0u8..2u8) as u8
    }
}

impl Default for Cfgr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Cfgr { bits: 0u32 }
    }
}

impl Cfgr {
    # [ doc = "Bits 30:31 - Microcontroller clock output 2" ]
    pub fn set_mco2(&mut self, value: u8) {
        self.bits.set_range(30u8..32u8, value as u32);
    }
    # [ doc = "Bits 27:29 - MCO2 prescaler" ]
    pub fn set_mco2pre(&mut self, value: u8) {
        self.bits.set_range(27u8..30u8, value as u32);
    }
    # [ doc = "Bits 24:26 - MCO1 prescaler" ]
    pub fn set_mco1pre(&mut self, value: u8) {
        self.bits.set_range(24u8..27u8, value as u32);
    }
    # [ doc = "Bit 23 - I2S clock selection" ]
    pub fn set_i2ssrc(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bits 21:22 - Microcontroller clock output 1" ]
    pub fn set_mco1(&mut self, value: u8) {
        self.bits.set_range(21u8..23u8, value as u32);
    }
    # [ doc = "Bits 16:20 - HSE division factor for RTC clock" ]
    pub fn set_rtcpre(&mut self, value: u8) {
        self.bits.set_range(16u8..21u8, value as u32);
    }
    # [ doc = "Bits 13:15 - APB high-speed prescaler (APB2)" ]
    pub fn set_ppre2(&mut self, value: u8) {
        self.bits.set_range(13u8..16u8, value as u32);
    }
    # [ doc = "Bits 10:12 - APB Low speed prescaler (APB1)" ]
    pub fn set_ppre1(&mut self, value: u8) {
        self.bits.set_range(10u8..13u8, value as u32);
    }
    # [ doc = "Bits 4:7 - AHB prescaler" ]
    pub fn set_hpre(&mut self, value: u8) {
        self.bits.set_range(4u8..8u8, value as u32);
    }
    # [ doc = "Bits 0:1 - System clock switch" ]
    pub fn set_sw(&mut self, value: u8) {
        self.bits.set_range(0u8..2u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Cir {
    bits: u32,
}

impl Cir {
    # [ doc = "Bit 14 - PLLSAI Ready Interrupt Enable" ]
    pub fn pllsairdyie(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 13 - PLLI2S ready interrupt enable" ]
    pub fn plli2srdyie(&self) -> bool {
        self.bits.get_bit(13u8)
    }
    # [ doc = "Bit 12 - Main PLL (PLL) ready interrupt enable" ]
    pub fn pllrdyie(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 11 - HSE ready interrupt enable" ]
    pub fn hserdyie(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 10 - HSI ready interrupt enable" ]
    pub fn hsirdyie(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - LSE ready interrupt enable" ]
    pub fn lserdyie(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - LSI ready interrupt enable" ]
    pub fn lsirdyie(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 7 - Clock security system interrupt flag" ]
    pub fn cssf(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 6 - PLLSAI ready interrupt flag" ]
    pub fn pllsairdyf(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 5 - PLLI2S ready interrupt flag" ]
    pub fn plli2srdyf(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Main PLL (PLL) ready interrupt flag" ]
    pub fn pllrdyf(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - HSE ready interrupt flag" ]
    pub fn hserdyf(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - HSI ready interrupt flag" ]
    pub fn hsirdyf(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - LSE ready interrupt flag" ]
    pub fn lserdyf(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - LSI ready interrupt flag" ]
    pub fn lsirdyf(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Cir {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Cir { bits: 0u32 }
    }
}

impl Cir {
    # [ doc = "Bit 23 - Clock security system interrupt clear" ]
    pub fn set_cssc(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 22 - PLLSAI Ready Interrupt Clear" ]
    pub fn set_pllsairdyc(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 21 - PLLI2S ready interrupt clear" ]
    pub fn set_plli2srdyc(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 20 - Main PLL(PLL) ready interrupt clear" ]
    pub fn set_pllrdyc(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 19 - HSE ready interrupt clear" ]
    pub fn set_hserdyc(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 18 - HSI ready interrupt clear" ]
    pub fn set_hsirdyc(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 17 - LSE ready interrupt clear" ]
    pub fn set_lserdyc(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bit 16 - LSI ready interrupt clear" ]
    pub fn set_lsirdyc(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 14 - PLLSAI Ready Interrupt Enable" ]
    pub fn set_pllsairdyie(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 13 - PLLI2S ready interrupt enable" ]
    pub fn set_plli2srdyie(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
    # [ doc = "Bit 12 - Main PLL (PLL) ready interrupt enable" ]
    pub fn set_pllrdyie(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 11 - HSE ready interrupt enable" ]
    pub fn set_hserdyie(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 10 - HSI ready interrupt enable" ]
    pub fn set_hsirdyie(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - LSE ready interrupt enable" ]
    pub fn set_lserdyie(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - LSI ready interrupt enable" ]
    pub fn set_lsirdyie(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Ahb1rstr {
    bits: u32,
}

impl Ahb1rstr {
    # [ doc = "Bit 29 - USB OTG HS module reset" ]
    pub fn otghsrst(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 25 - Ethernet MAC reset" ]
    pub fn ethmacrst(&self) -> bool {
        self.bits.get_bit(25u8)
    }
    # [ doc = "Bit 23 - DMA2D reset" ]
    pub fn dma2drst(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bit 22 - DMA2 reset" ]
    pub fn dma2rst(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bit 21 - DMA2 reset" ]
    pub fn dma1rst(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 12 - CRC reset" ]
    pub fn crcrst(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 10 - IO port K reset" ]
    pub fn gpiokrst(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - IO port J reset" ]
    pub fn gpiojrst(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - IO port I reset" ]
    pub fn gpioirst(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 7 - IO port H reset" ]
    pub fn gpiohrst(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 6 - IO port G reset" ]
    pub fn gpiogrst(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 5 - IO port F reset" ]
    pub fn gpiofrst(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - IO port E reset" ]
    pub fn gpioerst(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - IO port D reset" ]
    pub fn gpiodrst(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - IO port C reset" ]
    pub fn gpiocrst(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - IO port B reset" ]
    pub fn gpiobrst(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - IO port A reset" ]
    pub fn gpioarst(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Ahb1rstr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ahb1rstr { bits: 0u32 }
    }
}

impl Ahb1rstr {
    # [ doc = "Bit 29 - USB OTG HS module reset" ]
    pub fn set_otghsrst(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 25 - Ethernet MAC reset" ]
    pub fn set_ethmacrst(&mut self, value: bool) {
        self.bits.set_bit(25u8, value);
    }
    # [ doc = "Bit 23 - DMA2D reset" ]
    pub fn set_dma2drst(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 22 - DMA2 reset" ]
    pub fn set_dma2rst(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 21 - DMA2 reset" ]
    pub fn set_dma1rst(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 12 - CRC reset" ]
    pub fn set_crcrst(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 10 - IO port K reset" ]
    pub fn set_gpiokrst(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - IO port J reset" ]
    pub fn set_gpiojrst(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - IO port I reset" ]
    pub fn set_gpioirst(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 7 - IO port H reset" ]
    pub fn set_gpiohrst(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 6 - IO port G reset" ]
    pub fn set_gpiogrst(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 5 - IO port F reset" ]
    pub fn set_gpiofrst(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - IO port E reset" ]
    pub fn set_gpioerst(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - IO port D reset" ]
    pub fn set_gpiodrst(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - IO port C reset" ]
    pub fn set_gpiocrst(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - IO port B reset" ]
    pub fn set_gpiobrst(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - IO port A reset" ]
    pub fn set_gpioarst(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Ahb2rstr {
    bits: u32,
}

impl Ahb2rstr {
    # [ doc = "Bit 7 - USB OTG FS module reset" ]
    pub fn otgfsrst(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 6 - Random number generator module reset" ]
    pub fn rngrst(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 5 - Hash module reset" ]
    pub fn hsahrst(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Cryptographic module reset" ]
    pub fn cryprst(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 0 - Camera interface reset" ]
    pub fn dcmirst(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Ahb2rstr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ahb2rstr { bits: 0u32 }
    }
}

impl Ahb2rstr {
    # [ doc = "Bit 7 - USB OTG FS module reset" ]
    pub fn set_otgfsrst(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 6 - Random number generator module reset" ]
    pub fn set_rngrst(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 5 - Hash module reset" ]
    pub fn set_hsahrst(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Cryptographic module reset" ]
    pub fn set_cryprst(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 0 - Camera interface reset" ]
    pub fn set_dcmirst(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Ahb3rstr {
    bits: u32,
}

impl Ahb3rstr {
    # [ doc = "Bit 0 - Flexible memory controller module reset" ]
    pub fn fmcrst(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Quad SPI memory controller reset" ]
    pub fn qspirst(&self) -> bool {
        self.bits.get_bit(1u8)
    }
}

impl Default for Ahb3rstr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ahb3rstr { bits: 0u32 }
    }
}

impl Ahb3rstr {
    # [ doc = "Bit 0 - Flexible memory controller module reset" ]
    pub fn set_fmcrst(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Quad SPI memory controller reset" ]
    pub fn set_qspirst(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Apb1rstr {
    bits: u32,
}

impl Apb1rstr {
    # [ doc = "Bit 0 - TIM2 reset" ]
    pub fn tim2rst(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - TIM3 reset" ]
    pub fn tim3rst(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - TIM4 reset" ]
    pub fn tim4rst(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - TIM5 reset" ]
    pub fn tim5rst(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - TIM6 reset" ]
    pub fn tim6rst(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - TIM7 reset" ]
    pub fn tim7rst(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - TIM12 reset" ]
    pub fn tim12rst(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - TIM13 reset" ]
    pub fn tim13rst(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - TIM14 reset" ]
    pub fn tim14rst(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 11 - Window watchdog reset" ]
    pub fn wwdgrst(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 14 - SPI 2 reset" ]
    pub fn spi2rst(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 15 - SPI 3 reset" ]
    pub fn spi3rst(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - USART 2 reset" ]
    pub fn uart2rst(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bit 18 - USART 3 reset" ]
    pub fn uart3rst(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 19 - USART 4 reset" ]
    pub fn uart4rst(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 20 - USART 5 reset" ]
    pub fn uart5rst(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 21 - I2C 1 reset" ]
    pub fn i2c1rst(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 22 - I2C 2 reset" ]
    pub fn i2c2rst(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bit 23 - I2C3 reset" ]
    pub fn i2c3rst(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bit 25 - CAN1 reset" ]
    pub fn can1rst(&self) -> bool {
        self.bits.get_bit(25u8)
    }
    # [ doc = "Bit 26 - CAN2 reset" ]
    pub fn can2rst(&self) -> bool {
        self.bits.get_bit(26u8)
    }
    # [ doc = "Bit 28 - Power interface reset" ]
    pub fn pwrrst(&self) -> bool {
        self.bits.get_bit(28u8)
    }
    # [ doc = "Bit 29 - DAC reset" ]
    pub fn dacrst(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - UART7 reset" ]
    pub fn uart7rst(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - UART8 reset" ]
    pub fn uart8rst(&self) -> bool {
        self.bits.get_bit(31u8)
    }
    # [ doc = "Bit 16 - SPDIF-RX reset" ]
    pub fn spdifrxrst(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 27 - HDMI-CEC reset" ]
    pub fn cecrst(&self) -> bool {
        self.bits.get_bit(27u8)
    }
    # [ doc = "Bit 9 - Low power timer 1 reset" ]
    pub fn lptim1rst(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 24 - I2C 4 reset" ]
    pub fn i2c4rst(&self) -> bool {
        self.bits.get_bit(24u8)
    }
}

impl Default for Apb1rstr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Apb1rstr { bits: 0u32 }
    }
}

impl Apb1rstr {
    # [ doc = "Bit 0 - TIM2 reset" ]
    pub fn set_tim2rst(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - TIM3 reset" ]
    pub fn set_tim3rst(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - TIM4 reset" ]
    pub fn set_tim4rst(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - TIM5 reset" ]
    pub fn set_tim5rst(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - TIM6 reset" ]
    pub fn set_tim6rst(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - TIM7 reset" ]
    pub fn set_tim7rst(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - TIM12 reset" ]
    pub fn set_tim12rst(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - TIM13 reset" ]
    pub fn set_tim13rst(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - TIM14 reset" ]
    pub fn set_tim14rst(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 11 - Window watchdog reset" ]
    pub fn set_wwdgrst(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 14 - SPI 2 reset" ]
    pub fn set_spi2rst(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 15 - SPI 3 reset" ]
    pub fn set_spi3rst(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - USART 2 reset" ]
    pub fn set_uart2rst(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bit 18 - USART 3 reset" ]
    pub fn set_uart3rst(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 19 - USART 4 reset" ]
    pub fn set_uart4rst(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 20 - USART 5 reset" ]
    pub fn set_uart5rst(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 21 - I2C 1 reset" ]
    pub fn set_i2c1rst(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 22 - I2C 2 reset" ]
    pub fn set_i2c2rst(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 23 - I2C3 reset" ]
    pub fn set_i2c3rst(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 25 - CAN1 reset" ]
    pub fn set_can1rst(&mut self, value: bool) {
        self.bits.set_bit(25u8, value);
    }
    # [ doc = "Bit 26 - CAN2 reset" ]
    pub fn set_can2rst(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 28 - Power interface reset" ]
    pub fn set_pwrrst(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 29 - DAC reset" ]
    pub fn set_dacrst(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - UART7 reset" ]
    pub fn set_uart7rst(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - UART8 reset" ]
    pub fn set_uart8rst(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
    # [ doc = "Bit 16 - SPDIF-RX reset" ]
    pub fn set_spdifrxrst(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 27 - HDMI-CEC reset" ]
    pub fn set_cecrst(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 9 - Low power timer 1 reset" ]
    pub fn set_lptim1rst(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 24 - I2C 4 reset" ]
    pub fn set_i2c4rst(&mut self, value: bool) {
        self.bits.set_bit(24u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Apb2rstr {
    bits: u32,
}

impl Apb2rstr {
    # [ doc = "Bit 0 - TIM1 reset" ]
    pub fn tim1rst(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - TIM8 reset" ]
    pub fn tim8rst(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 4 - USART1 reset" ]
    pub fn usart1rst(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - USART6 reset" ]
    pub fn usart6rst(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 8 - ADC interface reset (common to all ADCs)" ]
    pub fn adcrst(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 12 - SPI 1 reset" ]
    pub fn spi1rst(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 13 - SPI4 reset" ]
    pub fn spi4rst(&self) -> bool {
        self.bits.get_bit(13u8)
    }
    # [ doc = "Bit 14 - System configuration controller reset" ]
    pub fn syscfgrst(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 16 - TIM9 reset" ]
    pub fn tim9rst(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - TIM10 reset" ]
    pub fn tim10rst(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bit 18 - TIM11 reset" ]
    pub fn tim11rst(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 20 - SPI5 reset" ]
    pub fn spi5rst(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 21 - SPI6 reset" ]
    pub fn spi6rst(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 22 - SAI1 reset" ]
    pub fn sai1rst(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bit 26 - LTDC reset" ]
    pub fn ltdcrst(&self) -> bool {
        self.bits.get_bit(26u8)
    }
    # [ doc = "Bit 23 - SAI2 reset" ]
    pub fn sai2rst(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bit 11 - SDMMC1 reset" ]
    pub fn sdmmc1rst(&self) -> bool {
        self.bits.get_bit(11u8)
    }
}

impl Default for Apb2rstr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Apb2rstr { bits: 0u32 }
    }
}

impl Apb2rstr {
    # [ doc = "Bit 0 - TIM1 reset" ]
    pub fn set_tim1rst(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - TIM8 reset" ]
    pub fn set_tim8rst(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 4 - USART1 reset" ]
    pub fn set_usart1rst(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - USART6 reset" ]
    pub fn set_usart6rst(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 8 - ADC interface reset (common to all ADCs)" ]
    pub fn set_adcrst(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 12 - SPI 1 reset" ]
    pub fn set_spi1rst(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 13 - SPI4 reset" ]
    pub fn set_spi4rst(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
    # [ doc = "Bit 14 - System configuration controller reset" ]
    pub fn set_syscfgrst(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 16 - TIM9 reset" ]
    pub fn set_tim9rst(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 17 - TIM10 reset" ]
    pub fn set_tim10rst(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bit 18 - TIM11 reset" ]
    pub fn set_tim11rst(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 20 - SPI5 reset" ]
    pub fn set_spi5rst(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 21 - SPI6 reset" ]
    pub fn set_spi6rst(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 22 - SAI1 reset" ]
    pub fn set_sai1rst(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 26 - LTDC reset" ]
    pub fn set_ltdcrst(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 23 - SAI2 reset" ]
    pub fn set_sai2rst(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 11 - SDMMC1 reset" ]
    pub fn set_sdmmc1rst(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Ahb1enr {
    bits: u32,
}

impl Ahb1enr {
    # [ doc = "Bit 30 - USB OTG HSULPI clock enable" ]
    pub fn otghsulpien(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 29 - USB OTG HS clock enable" ]
    pub fn otghsen(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 28 - Ethernet PTP clock enable" ]
    pub fn ethmacptpen(&self) -> bool {
        self.bits.get_bit(28u8)
    }
    # [ doc = "Bit 27 - Ethernet Reception clock enable" ]
    pub fn ethmacrxen(&self) -> bool {
        self.bits.get_bit(27u8)
    }
    # [ doc = "Bit 26 - Ethernet Transmission clock enable" ]
    pub fn ethmactxen(&self) -> bool {
        self.bits.get_bit(26u8)
    }
    # [ doc = "Bit 25 - Ethernet MAC clock enable" ]
    pub fn ethmacen(&self) -> bool {
        self.bits.get_bit(25u8)
    }
    # [ doc = "Bit 23 - DMA2D clock enable" ]
    pub fn dma2den(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bit 22 - DMA2 clock enable" ]
    pub fn dma2en(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bit 21 - DMA1 clock enable" ]
    pub fn dma1en(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 20 - CCM data RAM clock enable" ]
    pub fn ccmdataramen(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 18 - Backup SRAM interface clock enable" ]
    pub fn bkpsramen(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 12 - CRC clock enable" ]
    pub fn crcen(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 10 - IO port K clock enable" ]
    pub fn gpioken(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - IO port J clock enable" ]
    pub fn gpiojen(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - IO port I clock enable" ]
    pub fn gpioien(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 7 - IO port H clock enable" ]
    pub fn gpiohen(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 6 - IO port G clock enable" ]
    pub fn gpiogen(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 5 - IO port F clock enable" ]
    pub fn gpiofen(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - IO port E clock enable" ]
    pub fn gpioeen(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - IO port D clock enable" ]
    pub fn gpioden(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - IO port C clock enable" ]
    pub fn gpiocen(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - IO port B clock enable" ]
    pub fn gpioben(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - IO port A clock enable" ]
    pub fn gpioaen(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Ahb1enr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ahb1enr { bits: 1048576u32 }
    }
}

impl Ahb1enr {
    # [ doc = "Bit 30 - USB OTG HSULPI clock enable" ]
    pub fn set_otghsulpien(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 29 - USB OTG HS clock enable" ]
    pub fn set_otghsen(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 28 - Ethernet PTP clock enable" ]
    pub fn set_ethmacptpen(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 27 - Ethernet Reception clock enable" ]
    pub fn set_ethmacrxen(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 26 - Ethernet Transmission clock enable" ]
    pub fn set_ethmactxen(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 25 - Ethernet MAC clock enable" ]
    pub fn set_ethmacen(&mut self, value: bool) {
        self.bits.set_bit(25u8, value);
    }
    # [ doc = "Bit 23 - DMA2D clock enable" ]
    pub fn set_dma2den(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 22 - DMA2 clock enable" ]
    pub fn set_dma2en(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 21 - DMA1 clock enable" ]
    pub fn set_dma1en(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 20 - CCM data RAM clock enable" ]
    pub fn set_ccmdataramen(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 18 - Backup SRAM interface clock enable" ]
    pub fn set_bkpsramen(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 12 - CRC clock enable" ]
    pub fn set_crcen(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 10 - IO port K clock enable" ]
    pub fn set_gpioken(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - IO port J clock enable" ]
    pub fn set_gpiojen(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - IO port I clock enable" ]
    pub fn set_gpioien(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 7 - IO port H clock enable" ]
    pub fn set_gpiohen(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 6 - IO port G clock enable" ]
    pub fn set_gpiogen(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 5 - IO port F clock enable" ]
    pub fn set_gpiofen(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - IO port E clock enable" ]
    pub fn set_gpioeen(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - IO port D clock enable" ]
    pub fn set_gpioden(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - IO port C clock enable" ]
    pub fn set_gpiocen(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - IO port B clock enable" ]
    pub fn set_gpioben(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - IO port A clock enable" ]
    pub fn set_gpioaen(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Ahb2enr {
    bits: u32,
}

impl Ahb2enr {
    # [ doc = "Bit 7 - USB OTG FS clock enable" ]
    pub fn otgfsen(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 6 - Random number generator clock enable" ]
    pub fn rngen(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 5 - Hash modules clock enable" ]
    pub fn hashen(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Cryptographic modules clock enable" ]
    pub fn crypen(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 0 - Camera interface enable" ]
    pub fn dcmien(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Ahb2enr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ahb2enr { bits: 0u32 }
    }
}

impl Ahb2enr {
    # [ doc = "Bit 7 - USB OTG FS clock enable" ]
    pub fn set_otgfsen(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 6 - Random number generator clock enable" ]
    pub fn set_rngen(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 5 - Hash modules clock enable" ]
    pub fn set_hashen(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Cryptographic modules clock enable" ]
    pub fn set_crypen(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 0 - Camera interface enable" ]
    pub fn set_dcmien(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Ahb3enr {
    bits: u32,
}

impl Ahb3enr {
    # [ doc = "Bit 0 - Flexible memory controller module clock enable" ]
    pub fn fmcen(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Quad SPI memory controller clock enable" ]
    pub fn qspien(&self) -> bool {
        self.bits.get_bit(1u8)
    }
}

impl Default for Ahb3enr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ahb3enr { bits: 0u32 }
    }
}

impl Ahb3enr {
    # [ doc = "Bit 0 - Flexible memory controller module clock enable" ]
    pub fn set_fmcen(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Quad SPI memory controller clock enable" ]
    pub fn set_qspien(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Apb1enr {
    bits: u32,
}

impl Apb1enr {
    # [ doc = "Bit 0 - TIM2 clock enable" ]
    pub fn tim2en(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - TIM3 clock enable" ]
    pub fn tim3en(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - TIM4 clock enable" ]
    pub fn tim4en(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - TIM5 clock enable" ]
    pub fn tim5en(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - TIM6 clock enable" ]
    pub fn tim6en(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - TIM7 clock enable" ]
    pub fn tim7en(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - TIM12 clock enable" ]
    pub fn tim12en(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - TIM13 clock enable" ]
    pub fn tim13en(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - TIM14 clock enable" ]
    pub fn tim14en(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 11 - Window watchdog clock enable" ]
    pub fn wwdgen(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 14 - SPI2 clock enable" ]
    pub fn spi2en(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 15 - SPI3 clock enable" ]
    pub fn spi3en(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - USART 2 clock enable" ]
    pub fn usart2en(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bit 18 - USART3 clock enable" ]
    pub fn usart3en(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 19 - UART4 clock enable" ]
    pub fn uart4en(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 20 - UART5 clock enable" ]
    pub fn uart5en(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 21 - I2C1 clock enable" ]
    pub fn i2c1en(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 22 - I2C2 clock enable" ]
    pub fn i2c2en(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bit 23 - I2C3 clock enable" ]
    pub fn i2c3en(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bit 25 - CAN 1 clock enable" ]
    pub fn can1en(&self) -> bool {
        self.bits.get_bit(25u8)
    }
    # [ doc = "Bit 26 - CAN 2 clock enable" ]
    pub fn can2en(&self) -> bool {
        self.bits.get_bit(26u8)
    }
    # [ doc = "Bit 28 - Power interface clock enable" ]
    pub fn pwren(&self) -> bool {
        self.bits.get_bit(28u8)
    }
    # [ doc = "Bit 29 - DAC interface clock enable" ]
    pub fn dacen(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - UART7 clock enable" ]
    pub fn uart7enr(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - UART8 clock enable" ]
    pub fn uart8enr(&self) -> bool {
        self.bits.get_bit(31u8)
    }
    # [ doc = "Bit 16 - SPDIF-RX clock enable" ]
    pub fn spdifrxen(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 27 - HDMI-CEN clock enable" ]
    pub fn cecen(&self) -> bool {
        self.bits.get_bit(27u8)
    }
    # [ doc = "Bit 9 - Low power timer 1 clock enable" ]
    pub fn lptmi1en(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 24 - I2C4 clock enable" ]
    pub fn i2c4en(&self) -> bool {
        self.bits.get_bit(24u8)
    }
}

impl Default for Apb1enr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Apb1enr { bits: 0u32 }
    }
}

impl Apb1enr {
    # [ doc = "Bit 0 - TIM2 clock enable" ]
    pub fn set_tim2en(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - TIM3 clock enable" ]
    pub fn set_tim3en(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - TIM4 clock enable" ]
    pub fn set_tim4en(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - TIM5 clock enable" ]
    pub fn set_tim5en(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - TIM6 clock enable" ]
    pub fn set_tim6en(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - TIM7 clock enable" ]
    pub fn set_tim7en(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - TIM12 clock enable" ]
    pub fn set_tim12en(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - TIM13 clock enable" ]
    pub fn set_tim13en(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - TIM14 clock enable" ]
    pub fn set_tim14en(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 11 - Window watchdog clock enable" ]
    pub fn set_wwdgen(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 14 - SPI2 clock enable" ]
    pub fn set_spi2en(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 15 - SPI3 clock enable" ]
    pub fn set_spi3en(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - USART 2 clock enable" ]
    pub fn set_usart2en(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bit 18 - USART3 clock enable" ]
    pub fn set_usart3en(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 19 - UART4 clock enable" ]
    pub fn set_uart4en(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 20 - UART5 clock enable" ]
    pub fn set_uart5en(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 21 - I2C1 clock enable" ]
    pub fn set_i2c1en(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 22 - I2C2 clock enable" ]
    pub fn set_i2c2en(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 23 - I2C3 clock enable" ]
    pub fn set_i2c3en(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 25 - CAN 1 clock enable" ]
    pub fn set_can1en(&mut self, value: bool) {
        self.bits.set_bit(25u8, value);
    }
    # [ doc = "Bit 26 - CAN 2 clock enable" ]
    pub fn set_can2en(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 28 - Power interface clock enable" ]
    pub fn set_pwren(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 29 - DAC interface clock enable" ]
    pub fn set_dacen(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - UART7 clock enable" ]
    pub fn set_uart7enr(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - UART8 clock enable" ]
    pub fn set_uart8enr(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
    # [ doc = "Bit 16 - SPDIF-RX clock enable" ]
    pub fn set_spdifrxen(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 27 - HDMI-CEN clock enable" ]
    pub fn set_cecen(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 9 - Low power timer 1 clock enable" ]
    pub fn set_lptmi1en(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 24 - I2C4 clock enable" ]
    pub fn set_i2c4en(&mut self, value: bool) {
        self.bits.set_bit(24u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Apb2enr {
    bits: u32,
}

impl Apb2enr {
    # [ doc = "Bit 0 - TIM1 clock enable" ]
    pub fn tim1en(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - TIM8 clock enable" ]
    pub fn tim8en(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 4 - USART1 clock enable" ]
    pub fn usart1en(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - USART6 clock enable" ]
    pub fn usart6en(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 8 - ADC1 clock enable" ]
    pub fn adc1en(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - ADC2 clock enable" ]
    pub fn adc2en(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - ADC3 clock enable" ]
    pub fn adc3en(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 12 - SPI1 clock enable" ]
    pub fn spi1en(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 13 - SPI4 clock enable" ]
    pub fn spi4enr(&self) -> bool {
        self.bits.get_bit(13u8)
    }
    # [ doc = "Bit 14 - System configuration controller clock enable" ]
    pub fn syscfgen(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 16 - TIM9 clock enable" ]
    pub fn tim9en(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - TIM10 clock enable" ]
    pub fn tim10en(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bit 18 - TIM11 clock enable" ]
    pub fn tim11en(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 20 - SPI5 clock enable" ]
    pub fn spi5enr(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 21 - SPI6 clock enable" ]
    pub fn spi6enr(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 22 - SAI1 clock enable" ]
    pub fn sai1en(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bit 26 - LTDC clock enable" ]
    pub fn ltdcen(&self) -> bool {
        self.bits.get_bit(26u8)
    }
    # [ doc = "Bit 23 - SAI2 clock enable" ]
    pub fn sai2en(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bit 11 - SDMMC1 clock enable" ]
    pub fn sdmmc1en(&self) -> bool {
        self.bits.get_bit(11u8)
    }
}

impl Default for Apb2enr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Apb2enr { bits: 0u32 }
    }
}

impl Apb2enr {
    # [ doc = "Bit 0 - TIM1 clock enable" ]
    pub fn set_tim1en(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - TIM8 clock enable" ]
    pub fn set_tim8en(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 4 - USART1 clock enable" ]
    pub fn set_usart1en(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - USART6 clock enable" ]
    pub fn set_usart6en(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 8 - ADC1 clock enable" ]
    pub fn set_adc1en(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - ADC2 clock enable" ]
    pub fn set_adc2en(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - ADC3 clock enable" ]
    pub fn set_adc3en(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 12 - SPI1 clock enable" ]
    pub fn set_spi1en(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 13 - SPI4 clock enable" ]
    pub fn set_spi4enr(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
    # [ doc = "Bit 14 - System configuration controller clock enable" ]
    pub fn set_syscfgen(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 16 - TIM9 clock enable" ]
    pub fn set_tim9en(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 17 - TIM10 clock enable" ]
    pub fn set_tim10en(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bit 18 - TIM11 clock enable" ]
    pub fn set_tim11en(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 20 - SPI5 clock enable" ]
    pub fn set_spi5enr(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 21 - SPI6 clock enable" ]
    pub fn set_spi6enr(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 22 - SAI1 clock enable" ]
    pub fn set_sai1en(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 26 - LTDC clock enable" ]
    pub fn set_ltdcen(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 23 - SAI2 clock enable" ]
    pub fn set_sai2en(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 11 - SDMMC1 clock enable" ]
    pub fn set_sdmmc1en(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Ahb1lpenr {
    bits: u32,
}

impl Ahb1lpenr {
    # [ doc = "Bit 0 - IO port A clock enable during sleep mode" ]
    pub fn gpioalpen(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - IO port B clock enable during Sleep mode" ]
    pub fn gpioblpen(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - IO port C clock enable during Sleep mode" ]
    pub fn gpioclpen(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - IO port D clock enable during Sleep mode" ]
    pub fn gpiodlpen(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - IO port E clock enable during Sleep mode" ]
    pub fn gpioelpen(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - IO port F clock enable during Sleep mode" ]
    pub fn gpioflpen(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - IO port G clock enable during Sleep mode" ]
    pub fn gpioglpen(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - IO port H clock enable during Sleep mode" ]
    pub fn gpiohlpen(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - IO port I clock enable during Sleep mode" ]
    pub fn gpioilpen(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - IO port J clock enable during Sleep mode" ]
    pub fn gpiojlpen(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - IO port K clock enable during Sleep mode" ]
    pub fn gpioklpen(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 12 - CRC clock enable during Sleep mode" ]
    pub fn crclpen(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 15 - Flash interface clock enable during Sleep mode" ]
    pub fn flitflpen(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 16 - SRAM 1interface clock enable during Sleep mode" ]
    pub fn sram1lpen(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - SRAM 2 interface clock enable during Sleep mode" ]
    pub fn sram2lpen(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bit 18 - Backup SRAM interface clock enable during Sleep mode" ]
    pub fn bkpsramlpen(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 19 - SRAM 3 interface clock enable during Sleep mode" ]
    pub fn sram3lpen(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 21 - DMA1 clock enable during Sleep mode" ]
    pub fn dma1lpen(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 22 - DMA2 clock enable during Sleep mode" ]
    pub fn dma2lpen(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bit 23 - DMA2D clock enable during Sleep mode" ]
    pub fn dma2dlpen(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bit 25 - Ethernet MAC clock enable during Sleep mode" ]
    pub fn ethmaclpen(&self) -> bool {
        self.bits.get_bit(25u8)
    }
    # [ doc = "Bit 26 - Ethernet transmission clock enable during Sleep mode" ]
    pub fn ethmactxlpen(&self) -> bool {
        self.bits.get_bit(26u8)
    }
    # [ doc = "Bit 27 - Ethernet reception clock enable during Sleep mode" ]
    pub fn ethmacrxlpen(&self) -> bool {
        self.bits.get_bit(27u8)
    }
    # [ doc = "Bit 28 - Ethernet PTP clock enable during Sleep mode" ]
    pub fn ethmacptplpen(&self) -> bool {
        self.bits.get_bit(28u8)
    }
    # [ doc = "Bit 29 - USB OTG HS clock enable during Sleep mode" ]
    pub fn otghslpen(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - USB OTG HS ULPI clock enable during Sleep mode" ]
    pub fn otghsulpilpen(&self) -> bool {
        self.bits.get_bit(30u8)
    }
}

impl Default for Ahb1lpenr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ahb1lpenr { bits: 2120716799u32 }
    }
}

impl Ahb1lpenr {
    # [ doc = "Bit 0 - IO port A clock enable during sleep mode" ]
    pub fn set_gpioalpen(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - IO port B clock enable during Sleep mode" ]
    pub fn set_gpioblpen(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - IO port C clock enable during Sleep mode" ]
    pub fn set_gpioclpen(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - IO port D clock enable during Sleep mode" ]
    pub fn set_gpiodlpen(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - IO port E clock enable during Sleep mode" ]
    pub fn set_gpioelpen(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - IO port F clock enable during Sleep mode" ]
    pub fn set_gpioflpen(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - IO port G clock enable during Sleep mode" ]
    pub fn set_gpioglpen(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - IO port H clock enable during Sleep mode" ]
    pub fn set_gpiohlpen(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - IO port I clock enable during Sleep mode" ]
    pub fn set_gpioilpen(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - IO port J clock enable during Sleep mode" ]
    pub fn set_gpiojlpen(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - IO port K clock enable during Sleep mode" ]
    pub fn set_gpioklpen(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 12 - CRC clock enable during Sleep mode" ]
    pub fn set_crclpen(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 15 - Flash interface clock enable during Sleep mode" ]
    pub fn set_flitflpen(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 16 - SRAM 1interface clock enable during Sleep mode" ]
    pub fn set_sram1lpen(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 17 - SRAM 2 interface clock enable during Sleep mode" ]
    pub fn set_sram2lpen(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bit 18 - Backup SRAM interface clock enable during Sleep mode" ]
    pub fn set_bkpsramlpen(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 19 - SRAM 3 interface clock enable during Sleep mode" ]
    pub fn set_sram3lpen(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 21 - DMA1 clock enable during Sleep mode" ]
    pub fn set_dma1lpen(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 22 - DMA2 clock enable during Sleep mode" ]
    pub fn set_dma2lpen(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 23 - DMA2D clock enable during Sleep mode" ]
    pub fn set_dma2dlpen(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 25 - Ethernet MAC clock enable during Sleep mode" ]
    pub fn set_ethmaclpen(&mut self, value: bool) {
        self.bits.set_bit(25u8, value);
    }
    # [ doc = "Bit 26 - Ethernet transmission clock enable during Sleep mode" ]
    pub fn set_ethmactxlpen(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 27 - Ethernet reception clock enable during Sleep mode" ]
    pub fn set_ethmacrxlpen(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 28 - Ethernet PTP clock enable during Sleep mode" ]
    pub fn set_ethmacptplpen(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 29 - USB OTG HS clock enable during Sleep mode" ]
    pub fn set_otghslpen(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - USB OTG HS ULPI clock enable during Sleep mode" ]
    pub fn set_otghsulpilpen(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Ahb2lpenr {
    bits: u32,
}

impl Ahb2lpenr {
    # [ doc = "Bit 7 - USB OTG FS clock enable during Sleep mode" ]
    pub fn otgfslpen(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 6 - Random number generator clock enable during Sleep mode" ]
    pub fn rnglpen(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 5 - Hash modules clock enable during Sleep mode" ]
    pub fn hashlpen(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Cryptography modules clock enable during Sleep mode" ]
    pub fn cryplpen(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 0 - Camera interface enable during Sleep mode" ]
    pub fn dcmilpen(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Ahb2lpenr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ahb2lpenr { bits: 241u32 }
    }
}

impl Ahb2lpenr {
    # [ doc = "Bit 7 - USB OTG FS clock enable during Sleep mode" ]
    pub fn set_otgfslpen(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 6 - Random number generator clock enable during Sleep mode" ]
    pub fn set_rnglpen(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 5 - Hash modules clock enable during Sleep mode" ]
    pub fn set_hashlpen(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Cryptography modules clock enable during Sleep mode" ]
    pub fn set_cryplpen(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 0 - Camera interface enable during Sleep mode" ]
    pub fn set_dcmilpen(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Ahb3lpenr {
    bits: u32,
}

impl Ahb3lpenr {
    # [ doc = "Bit 0 - Flexible memory controller module clock enable during Sleep mode" ]
    pub fn fmclpen(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Quand SPI memory controller clock enable during Sleep mode" ]
    pub fn qspilpen(&self) -> bool {
        self.bits.get_bit(1u8)
    }
}

impl Default for Ahb3lpenr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ahb3lpenr { bits: 1u32 }
    }
}

impl Ahb3lpenr {
    # [ doc = "Bit 0 - Flexible memory controller module clock enable during Sleep mode" ]
    pub fn set_fmclpen(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Quand SPI memory controller clock enable during Sleep mode" ]
    pub fn set_qspilpen(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Apb1lpenr {
    bits: u32,
}

impl Apb1lpenr {
    # [ doc = "Bit 0 - TIM2 clock enable during Sleep mode" ]
    pub fn tim2lpen(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - TIM3 clock enable during Sleep mode" ]
    pub fn tim3lpen(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - TIM4 clock enable during Sleep mode" ]
    pub fn tim4lpen(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - TIM5 clock enable during Sleep mode" ]
    pub fn tim5lpen(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - TIM6 clock enable during Sleep mode" ]
    pub fn tim6lpen(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - TIM7 clock enable during Sleep mode" ]
    pub fn tim7lpen(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - TIM12 clock enable during Sleep mode" ]
    pub fn tim12lpen(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - TIM13 clock enable during Sleep mode" ]
    pub fn tim13lpen(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - TIM14 clock enable during Sleep mode" ]
    pub fn tim14lpen(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 11 - Window watchdog clock enable during Sleep mode" ]
    pub fn wwdglpen(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 14 - SPI2 clock enable during Sleep mode" ]
    pub fn spi2lpen(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 15 - SPI3 clock enable during Sleep mode" ]
    pub fn spi3lpen(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - USART2 clock enable during Sleep mode" ]
    pub fn usart2lpen(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bit 18 - USART3 clock enable during Sleep mode" ]
    pub fn usart3lpen(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 19 - UART4 clock enable during Sleep mode" ]
    pub fn uart4lpen(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 20 - UART5 clock enable during Sleep mode" ]
    pub fn uart5lpen(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 21 - I2C1 clock enable during Sleep mode" ]
    pub fn i2c1lpen(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 22 - I2C2 clock enable during Sleep mode" ]
    pub fn i2c2lpen(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bit 23 - I2C3 clock enable during Sleep mode" ]
    pub fn i2c3lpen(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bit 25 - CAN 1 clock enable during Sleep mode" ]
    pub fn can1lpen(&self) -> bool {
        self.bits.get_bit(25u8)
    }
    # [ doc = "Bit 26 - CAN 2 clock enable during Sleep mode" ]
    pub fn can2lpen(&self) -> bool {
        self.bits.get_bit(26u8)
    }
    # [ doc = "Bit 28 - Power interface clock enable during Sleep mode" ]
    pub fn pwrlpen(&self) -> bool {
        self.bits.get_bit(28u8)
    }
    # [ doc = "Bit 29 - DAC interface clock enable during Sleep mode" ]
    pub fn daclpen(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - UART7 clock enable during Sleep mode" ]
    pub fn uart7lpen(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - UART8 clock enable during Sleep mode" ]
    pub fn uart8lpen(&self) -> bool {
        self.bits.get_bit(31u8)
    }
    # [ doc = "Bit 16 - SPDIF-RX clock enable during sleep mode" ]
    pub fn spdifrxlpen(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 27 - HDMI-CEN clock enable during Sleep mode" ]
    pub fn ceclpen(&self) -> bool {
        self.bits.get_bit(27u8)
    }
    # [ doc = "Bit 9 - low power timer 1 clock enable during Sleep mode" ]
    pub fn lptim1lpen(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 24 - I2C4 clock enable during Sleep mode" ]
    pub fn i2c4lpen(&self) -> bool {
        self.bits.get_bit(24u8)
    }
}

impl Default for Apb1lpenr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Apb1lpenr { bits: 922667519u32 }
    }
}

impl Apb1lpenr {
    # [ doc = "Bit 0 - TIM2 clock enable during Sleep mode" ]
    pub fn set_tim2lpen(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - TIM3 clock enable during Sleep mode" ]
    pub fn set_tim3lpen(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - TIM4 clock enable during Sleep mode" ]
    pub fn set_tim4lpen(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - TIM5 clock enable during Sleep mode" ]
    pub fn set_tim5lpen(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - TIM6 clock enable during Sleep mode" ]
    pub fn set_tim6lpen(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - TIM7 clock enable during Sleep mode" ]
    pub fn set_tim7lpen(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - TIM12 clock enable during Sleep mode" ]
    pub fn set_tim12lpen(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - TIM13 clock enable during Sleep mode" ]
    pub fn set_tim13lpen(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - TIM14 clock enable during Sleep mode" ]
    pub fn set_tim14lpen(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 11 - Window watchdog clock enable during Sleep mode" ]
    pub fn set_wwdglpen(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 14 - SPI2 clock enable during Sleep mode" ]
    pub fn set_spi2lpen(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 15 - SPI3 clock enable during Sleep mode" ]
    pub fn set_spi3lpen(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - USART2 clock enable during Sleep mode" ]
    pub fn set_usart2lpen(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bit 18 - USART3 clock enable during Sleep mode" ]
    pub fn set_usart3lpen(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 19 - UART4 clock enable during Sleep mode" ]
    pub fn set_uart4lpen(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 20 - UART5 clock enable during Sleep mode" ]
    pub fn set_uart5lpen(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 21 - I2C1 clock enable during Sleep mode" ]
    pub fn set_i2c1lpen(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 22 - I2C2 clock enable during Sleep mode" ]
    pub fn set_i2c2lpen(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 23 - I2C3 clock enable during Sleep mode" ]
    pub fn set_i2c3lpen(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 25 - CAN 1 clock enable during Sleep mode" ]
    pub fn set_can1lpen(&mut self, value: bool) {
        self.bits.set_bit(25u8, value);
    }
    # [ doc = "Bit 26 - CAN 2 clock enable during Sleep mode" ]
    pub fn set_can2lpen(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 28 - Power interface clock enable during Sleep mode" ]
    pub fn set_pwrlpen(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 29 - DAC interface clock enable during Sleep mode" ]
    pub fn set_daclpen(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - UART7 clock enable during Sleep mode" ]
    pub fn set_uart7lpen(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - UART8 clock enable during Sleep mode" ]
    pub fn set_uart8lpen(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
    # [ doc = "Bit 16 - SPDIF-RX clock enable during sleep mode" ]
    pub fn set_spdifrxlpen(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 27 - HDMI-CEN clock enable during Sleep mode" ]
    pub fn set_ceclpen(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 9 - low power timer 1 clock enable during Sleep mode" ]
    pub fn set_lptim1lpen(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 24 - I2C4 clock enable during Sleep mode" ]
    pub fn set_i2c4lpen(&mut self, value: bool) {
        self.bits.set_bit(24u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Apb2lpenr {
    bits: u32,
}

impl Apb2lpenr {
    # [ doc = "Bit 0 - TIM1 clock enable during Sleep mode" ]
    pub fn tim1lpen(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - TIM8 clock enable during Sleep mode" ]
    pub fn tim8lpen(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 4 - USART1 clock enable during Sleep mode" ]
    pub fn usart1lpen(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - USART6 clock enable during Sleep mode" ]
    pub fn usart6lpen(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 8 - ADC1 clock enable during Sleep mode" ]
    pub fn adc1lpen(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - ADC2 clock enable during Sleep mode" ]
    pub fn adc2lpen(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - ADC 3 clock enable during Sleep mode" ]
    pub fn adc3lpen(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 12 - SPI 1 clock enable during Sleep mode" ]
    pub fn spi1lpen(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 13 - SPI 4 clock enable during Sleep mode" ]
    pub fn spi4lpen(&self) -> bool {
        self.bits.get_bit(13u8)
    }
    # [ doc = "Bit 14 - System configuration controller clock enable during Sleep mode" ]
    pub fn syscfglpen(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 16 - TIM9 clock enable during sleep mode" ]
    pub fn tim9lpen(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - TIM10 clock enable during Sleep mode" ]
    pub fn tim10lpen(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bit 18 - TIM11 clock enable during Sleep mode" ]
    pub fn tim11lpen(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 20 - SPI 5 clock enable during Sleep mode" ]
    pub fn spi5lpen(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 21 - SPI 6 clock enable during Sleep mode" ]
    pub fn spi6lpen(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 22 - SAI1 clock enable during sleep mode" ]
    pub fn sai1lpen(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bit 26 - LTDC clock enable during sleep mode" ]
    pub fn ltdclpen(&self) -> bool {
        self.bits.get_bit(26u8)
    }
    # [ doc = "Bit 23 - SAI2 clock enable during sleep mode" ]
    pub fn sai2lpen(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bit 11 - SDMMC1 clock enable during Sleep mode" ]
    pub fn sdmmc1lpen(&self) -> bool {
        self.bits.get_bit(11u8)
    }
}

impl Default for Apb2lpenr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Apb2lpenr { bits: 483123u32 }
    }
}

impl Apb2lpenr {
    # [ doc = "Bit 0 - TIM1 clock enable during Sleep mode" ]
    pub fn set_tim1lpen(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - TIM8 clock enable during Sleep mode" ]
    pub fn set_tim8lpen(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 4 - USART1 clock enable during Sleep mode" ]
    pub fn set_usart1lpen(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - USART6 clock enable during Sleep mode" ]
    pub fn set_usart6lpen(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 8 - ADC1 clock enable during Sleep mode" ]
    pub fn set_adc1lpen(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - ADC2 clock enable during Sleep mode" ]
    pub fn set_adc2lpen(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - ADC 3 clock enable during Sleep mode" ]
    pub fn set_adc3lpen(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 12 - SPI 1 clock enable during Sleep mode" ]
    pub fn set_spi1lpen(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 13 - SPI 4 clock enable during Sleep mode" ]
    pub fn set_spi4lpen(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
    # [ doc = "Bit 14 - System configuration controller clock enable during Sleep mode" ]
    pub fn set_syscfglpen(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 16 - TIM9 clock enable during sleep mode" ]
    pub fn set_tim9lpen(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 17 - TIM10 clock enable during Sleep mode" ]
    pub fn set_tim10lpen(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bit 18 - TIM11 clock enable during Sleep mode" ]
    pub fn set_tim11lpen(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 20 - SPI 5 clock enable during Sleep mode" ]
    pub fn set_spi5lpen(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 21 - SPI 6 clock enable during Sleep mode" ]
    pub fn set_spi6lpen(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 22 - SAI1 clock enable during sleep mode" ]
    pub fn set_sai1lpen(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 26 - LTDC clock enable during sleep mode" ]
    pub fn set_ltdclpen(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 23 - SAI2 clock enable during sleep mode" ]
    pub fn set_sai2lpen(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 11 - SDMMC1 clock enable during Sleep mode" ]
    pub fn set_sdmmc1lpen(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Bdcr {
    bits: u32,
}

impl Bdcr {
    # [ doc = "Bit 16 - Backup domain software reset" ]
    pub fn bdrst(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 15 - RTC clock enable" ]
    pub fn rtcen(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 9 - RTC clock source selection" ]
    pub fn rtcsel1(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - RTC clock source selection" ]
    pub fn rtcsel0(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 2 - External low-speed oscillator bypass" ]
    pub fn lsebyp(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - External low-speed oscillator ready" ]
    pub fn lserdy(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - External low-speed oscillator enable" ]
    pub fn lseon(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Bdcr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bdcr { bits: 0u32 }
    }
}

impl Bdcr {
    # [ doc = "Bit 16 - Backup domain software reset" ]
    pub fn set_bdrst(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 15 - RTC clock enable" ]
    pub fn set_rtcen(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 9 - RTC clock source selection" ]
    pub fn set_rtcsel1(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - RTC clock source selection" ]
    pub fn set_rtcsel0(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 2 - External low-speed oscillator bypass" ]
    pub fn set_lsebyp(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 0 - External low-speed oscillator enable" ]
    pub fn set_lseon(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Csr {
    bits: u32,
}

impl Csr {
    # [ doc = "Bit 31 - Low-power reset flag" ]
    pub fn lpwrrstf(&self) -> bool {
        self.bits.get_bit(31u8)
    }
    # [ doc = "Bit 30 - Window watchdog reset flag" ]
    pub fn wwdgrstf(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 29 - Independent watchdog reset flag" ]
    pub fn wdgrstf(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 28 - Software reset flag" ]
    pub fn sftrstf(&self) -> bool {
        self.bits.get_bit(28u8)
    }
    # [ doc = "Bit 27 - POR/PDR reset flag" ]
    pub fn porrstf(&self) -> bool {
        self.bits.get_bit(27u8)
    }
    # [ doc = "Bit 26 - PIN reset flag" ]
    pub fn padrstf(&self) -> bool {
        self.bits.get_bit(26u8)
    }
    # [ doc = "Bit 25 - BOR reset flag" ]
    pub fn borrstf(&self) -> bool {
        self.bits.get_bit(25u8)
    }
    # [ doc = "Bit 24 - Remove reset flag" ]
    pub fn rmvf(&self) -> bool {
        self.bits.get_bit(24u8)
    }
    # [ doc = "Bit 1 - Internal low-speed oscillator ready" ]
    pub fn lsirdy(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Internal low-speed oscillator enable" ]
    pub fn lsion(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Csr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Csr { bits: 234881024u32 }
    }
}

impl Csr {
    # [ doc = "Bit 31 - Low-power reset flag" ]
    pub fn set_lpwrrstf(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
    # [ doc = "Bit 30 - Window watchdog reset flag" ]
    pub fn set_wwdgrstf(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 29 - Independent watchdog reset flag" ]
    pub fn set_wdgrstf(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 28 - Software reset flag" ]
    pub fn set_sftrstf(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 27 - POR/PDR reset flag" ]
    pub fn set_porrstf(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 26 - PIN reset flag" ]
    pub fn set_padrstf(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 25 - BOR reset flag" ]
    pub fn set_borrstf(&mut self, value: bool) {
        self.bits.set_bit(25u8, value);
    }
    # [ doc = "Bit 24 - Remove reset flag" ]
    pub fn set_rmvf(&mut self, value: bool) {
        self.bits.set_bit(24u8, value);
    }
    # [ doc = "Bit 0 - Internal low-speed oscillator enable" ]
    pub fn set_lsion(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Sscgr {
    bits: u32,
}

impl Sscgr {
    # [ doc = "Bit 31 - Spread spectrum modulation enable" ]
    pub fn sscgen(&self) -> bool {
        self.bits.get_bit(31u8)
    }
    # [ doc = "Bit 30 - Spread Select" ]
    pub fn spreadsel(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bits 13:27 - Incrementation step" ]
    pub fn incstep(&self) -> u16 {
        self.bits.get_range(13u8..28u8) as u16
    }
    # [ doc = "Bits 0:12 - Modulation period" ]
    pub fn modper(&self) -> u16 {
        self.bits.get_range(0u8..13u8) as u16
    }
}

impl Default for Sscgr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Sscgr { bits: 0u32 }
    }
}

impl Sscgr {
    # [ doc = "Bit 31 - Spread spectrum modulation enable" ]
    pub fn set_sscgen(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
    # [ doc = "Bit 30 - Spread Select" ]
    pub fn set_spreadsel(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bits 13:27 - Incrementation step" ]
    pub fn set_incstep(&mut self, value: u16) {
        self.bits.set_range(13u8..28u8, value as u32);
    }
    # [ doc = "Bits 0:12 - Modulation period" ]
    pub fn set_modper(&mut self, value: u16) {
        self.bits.set_range(0u8..13u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Plli2scfgr {
    bits: u32,
}

impl Plli2scfgr {
    # [ doc = "Bits 28:30 - PLLI2S division factor for I2S clocks" ]
    pub fn plli2sr(&self) -> u8 {
        self.bits.get_range(28u8..31u8) as u8
    }
    # [ doc = "Bits 24:27 - PLLI2S division factor for SAI1 clock" ]
    pub fn plli2sq(&self) -> u8 {
        self.bits.get_range(24u8..28u8) as u8
    }
    # [ doc = "Bits 6:14 - PLLI2S multiplication factor for VCO" ]
    pub fn plli2sn(&self) -> u16 {
        self.bits.get_range(6u8..15u8) as u16
    }
}

impl Default for Plli2scfgr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Plli2scfgr { bits: 536883200u32 }
    }
}

impl Plli2scfgr {
    # [ doc = "Bits 28:30 - PLLI2S division factor for I2S clocks" ]
    pub fn set_plli2sr(&mut self, value: u8) {
        self.bits.set_range(28u8..31u8, value as u32);
    }
    # [ doc = "Bits 24:27 - PLLI2S division factor for SAI1 clock" ]
    pub fn set_plli2sq(&mut self, value: u8) {
        self.bits.set_range(24u8..28u8, value as u32);
    }
    # [ doc = "Bits 6:14 - PLLI2S multiplication factor for VCO" ]
    pub fn set_plli2sn(&mut self, value: u16) {
        self.bits.set_range(6u8..15u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Pllsaicfgr {
    bits: u32,
}

impl Pllsaicfgr {
    # [ doc = "Bits 6:14 - PLLSAI division factor for VCO" ]
    pub fn pllsain(&self) -> u16 {
        self.bits.get_range(6u8..15u8) as u16
    }
    # [ doc = "Bits 16:17 - PLLSAI division factor for 48MHz clock" ]
    pub fn pllsaip(&self) -> u8 {
        self.bits.get_range(16u8..18u8) as u8
    }
    # [ doc = "Bits 24:27 - PLLSAI division factor for SAI clock" ]
    pub fn pllsaiq(&self) -> u8 {
        self.bits.get_range(24u8..28u8) as u8
    }
    # [ doc = "Bits 28:30 - PLLSAI division factor for LCD clock" ]
    pub fn pllsair(&self) -> u8 {
        self.bits.get_range(28u8..31u8) as u8
    }
}

impl Default for Pllsaicfgr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Pllsaicfgr { bits: 536883200u32 }
    }
}

impl Pllsaicfgr {
    # [ doc = "Bits 6:14 - PLLSAI division factor for VCO" ]
    pub fn set_pllsain(&mut self, value: u16) {
        self.bits.set_range(6u8..15u8, value as u32);
    }
    # [ doc = "Bits 16:17 - PLLSAI division factor for 48MHz clock" ]
    pub fn set_pllsaip(&mut self, value: u8) {
        self.bits.set_range(16u8..18u8, value as u32);
    }
    # [ doc = "Bits 24:27 - PLLSAI division factor for SAI clock" ]
    pub fn set_pllsaiq(&mut self, value: u8) {
        self.bits.set_range(24u8..28u8, value as u32);
    }
    # [ doc = "Bits 28:30 - PLLSAI division factor for LCD clock" ]
    pub fn set_pllsair(&mut self, value: u8) {
        self.bits.set_range(28u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Dkcfgr1 {
    bits: u32,
}

impl Dkcfgr1 {
    # [ doc = "Bits 0:4 - PLLI2S division factor for SAI1 clock" ]
    pub fn plli2sdiv(&self) -> u8 {
        self.bits.get_range(0u8..5u8) as u8
    }
    # [ doc = "Bits 8:12 - PLLSAI division factor for SAI1 clock" ]
    pub fn pllsaidivq(&self) -> u8 {
        self.bits.get_range(8u8..13u8) as u8
    }
    # [ doc = "Bits 16:17 - division factor for LCD_CLK" ]
    pub fn pllsaidivr(&self) -> u8 {
        self.bits.get_range(16u8..18u8) as u8
    }
    # [ doc = "Bits 20:21 - SAI1 clock source selection" ]
    pub fn sai1sel(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:23 - SAI2 clock source selection" ]
    pub fn sai2sel(&self) -> u8 {
        self.bits.get_range(22u8..24u8) as u8
    }
    # [ doc = "Bit 24 - Timers clocks prescalers selection" ]
    pub fn timpre(&self) -> bool {
        self.bits.get_bit(24u8)
    }
}

impl Default for Dkcfgr1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Dkcfgr1 { bits: 536883200u32 }
    }
}

impl Dkcfgr1 {
    # [ doc = "Bits 0:4 - PLLI2S division factor for SAI1 clock" ]
    pub fn set_plli2sdiv(&mut self, value: u8) {
        self.bits.set_range(0u8..5u8, value as u32);
    }
    # [ doc = "Bits 8:12 - PLLSAI division factor for SAI1 clock" ]
    pub fn set_pllsaidivq(&mut self, value: u8) {
        self.bits.set_range(8u8..13u8, value as u32);
    }
    # [ doc = "Bits 16:17 - division factor for LCD_CLK" ]
    pub fn set_pllsaidivr(&mut self, value: u8) {
        self.bits.set_range(16u8..18u8, value as u32);
    }
    # [ doc = "Bits 20:21 - SAI1 clock source selection" ]
    pub fn set_sai1sel(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:23 - SAI2 clock source selection" ]
    pub fn set_sai2sel(&mut self, value: u8) {
        self.bits.set_range(22u8..24u8, value as u32);
    }
    # [ doc = "Bit 24 - Timers clocks prescalers selection" ]
    pub fn set_timpre(&mut self, value: bool) {
        self.bits.set_bit(24u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Dkcfgr2 {
    bits: u32,
}

impl Dkcfgr2 {
    # [ doc = "Bits 0:1 - USART 1 clock source selection" ]
    pub fn usart1sel(&self) -> u8 {
        self.bits.get_range(0u8..2u8) as u8
    }
    # [ doc = "Bits 2:3 - USART 2 clock source selection" ]
    pub fn usart2sel(&self) -> u8 {
        self.bits.get_range(2u8..4u8) as u8
    }
    # [ doc = "Bits 4:5 - USART 3 clock source selection" ]
    pub fn usart3sel(&self) -> u8 {
        self.bits.get_range(4u8..6u8) as u8
    }
    # [ doc = "Bits 6:7 - UART 4 clock source selection" ]
    pub fn uart4sel(&self) -> u8 {
        self.bits.get_range(6u8..8u8) as u8
    }
    # [ doc = "Bits 8:9 - UART 5 clock source selection" ]
    pub fn uart5sel(&self) -> u8 {
        self.bits.get_range(8u8..10u8) as u8
    }
    # [ doc = "Bits 10:11 - USART 6 clock source selection" ]
    pub fn usart6sel(&self) -> u8 {
        self.bits.get_range(10u8..12u8) as u8
    }
    # [ doc = "Bits 12:13 - UART 7 clock source selection" ]
    pub fn uart7sel(&self) -> u8 {
        self.bits.get_range(12u8..14u8) as u8
    }
    # [ doc = "Bits 14:15 - UART 8 clock source selection" ]
    pub fn uart8sel(&self) -> u8 {
        self.bits.get_range(14u8..16u8) as u8
    }
    # [ doc = "Bits 16:17 - I2C1 clock source selection" ]
    pub fn i2c1sel(&self) -> u8 {
        self.bits.get_range(16u8..18u8) as u8
    }
    # [ doc = "Bits 18:19 - I2C2 clock source selection" ]
    pub fn i2c2sel(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - I2C3 clock source selection" ]
    pub fn i2c3sel(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:23 - I2C4 clock source selection" ]
    pub fn i2c4sel(&self) -> u8 {
        self.bits.get_range(22u8..24u8) as u8
    }
    # [ doc = "Bits 24:25 - Low power timer 1 clock source selection" ]
    pub fn lptim1sel(&self) -> u8 {
        self.bits.get_range(24u8..26u8) as u8
    }
    # [ doc = "Bit 26 - HDMI-CEC clock source selection" ]
    pub fn cecsel(&self) -> bool {
        self.bits.get_bit(26u8)
    }
    # [ doc = "Bit 27 - 48MHz clock source selection" ]
    pub fn ck48msel(&self) -> bool {
        self.bits.get_bit(27u8)
    }
    # [ doc = "Bit 28 - SDMMC clock source selection" ]
    pub fn sdmmcsel(&self) -> bool {
        self.bits.get_bit(28u8)
    }
}

impl Default for Dkcfgr2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Dkcfgr2 { bits: 536883200u32 }
    }
}

impl Dkcfgr2 {
    # [ doc = "Bits 0:1 - USART 1 clock source selection" ]
    pub fn set_usart1sel(&mut self, value: u8) {
        self.bits.set_range(0u8..2u8, value as u32);
    }
    # [ doc = "Bits 2:3 - USART 2 clock source selection" ]
    pub fn set_usart2sel(&mut self, value: u8) {
        self.bits.set_range(2u8..4u8, value as u32);
    }
    # [ doc = "Bits 4:5 - USART 3 clock source selection" ]
    pub fn set_usart3sel(&mut self, value: u8) {
        self.bits.set_range(4u8..6u8, value as u32);
    }
    # [ doc = "Bits 6:7 - UART 4 clock source selection" ]
    pub fn set_uart4sel(&mut self, value: u8) {
        self.bits.set_range(6u8..8u8, value as u32);
    }
    # [ doc = "Bits 8:9 - UART 5 clock source selection" ]
    pub fn set_uart5sel(&mut self, value: u8) {
        self.bits.set_range(8u8..10u8, value as u32);
    }
    # [ doc = "Bits 10:11 - USART 6 clock source selection" ]
    pub fn set_usart6sel(&mut self, value: u8) {
        self.bits.set_range(10u8..12u8, value as u32);
    }
    # [ doc = "Bits 12:13 - UART 7 clock source selection" ]
    pub fn set_uart7sel(&mut self, value: u8) {
        self.bits.set_range(12u8..14u8, value as u32);
    }
    # [ doc = "Bits 14:15 - UART 8 clock source selection" ]
    pub fn set_uart8sel(&mut self, value: u8) {
        self.bits.set_range(14u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:17 - I2C1 clock source selection" ]
    pub fn set_i2c1sel(&mut self, value: u8) {
        self.bits.set_range(16u8..18u8, value as u32);
    }
    # [ doc = "Bits 18:19 - I2C2 clock source selection" ]
    pub fn set_i2c2sel(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - I2C3 clock source selection" ]
    pub fn set_i2c3sel(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:23 - I2C4 clock source selection" ]
    pub fn set_i2c4sel(&mut self, value: u8) {
        self.bits.set_range(22u8..24u8, value as u32);
    }
    # [ doc = "Bits 24:25 - Low power timer 1 clock source selection" ]
    pub fn set_lptim1sel(&mut self, value: u8) {
        self.bits.set_range(24u8..26u8, value as u32);
    }
    # [ doc = "Bit 26 - HDMI-CEC clock source selection" ]
    pub fn set_cecsel(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 27 - 48MHz clock source selection" ]
    pub fn set_ck48msel(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 28 - SDMMC clock source selection" ]
    pub fn set_sdmmcsel(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
}
