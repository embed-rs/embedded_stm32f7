// autogenerated

use volatile;
use bit_field::BitField;

# [ doc = "Flexible memory controller" ]
# [ repr ( C ) ]
pub struct Fmc {
    # [ doc = "0x00 - SRAM/NOR-Flash chip-select control register 1" ]
    pub bcr1: volatile::ReadWrite<Bcr1>,
    # [ doc = "0x04 - SRAM/NOR-Flash chip-select timing register 1" ]
    pub btr1: volatile::ReadWrite<Btr1>,
    # [ doc = "0x08 - SRAM/NOR-Flash chip-select control register 2" ]
    pub bcr2: volatile::ReadWrite<Bcr2>,
    # [ doc = "0x0c - SRAM/NOR-Flash chip-select timing register 2" ]
    pub btr2: volatile::ReadWrite<Btr2>,
    # [ doc = "0x10 - SRAM/NOR-Flash chip-select control register 3" ]
    pub bcr3: volatile::ReadWrite<Bcr3>,
    # [ doc = "0x14 - SRAM/NOR-Flash chip-select timing register 3" ]
    pub btr3: volatile::ReadWrite<Btr3>,
    # [ doc = "0x18 - SRAM/NOR-Flash chip-select control register 4" ]
    pub bcr4: volatile::ReadWrite<Bcr4>,
    # [ doc = "0x1c - SRAM/NOR-Flash chip-select timing register 4" ]
    pub btr4: volatile::ReadWrite<Btr4>,
    _reserved0: [u8; 96usize],
    # [ doc = "0x80 - PC Card/NAND Flash control register" ]
    pub pcr: volatile::ReadWrite<Pcr>,
    # [ doc = "0x84 - FIFO status and interrupt register" ]
    pub sr: volatile::ReadWrite<Sr>,
    # [ doc = "0x88 - Common memory space timing register" ]
    pub pmem: volatile::ReadWrite<Pmem>,
    # [ doc = "0x8c - Attribute memory space timing register" ]
    pub patt: volatile::ReadWrite<Patt>,
    _reserved1: [u8; 4usize],
    # [ doc = "0x94 - ECC result register" ]
    pub eccr: volatile::ReadOnly<Eccr>,
    _reserved2: [u8; 108usize],
    # [ doc = "0x104 - SRAM/NOR-Flash write timing registers 1" ]
    pub bwtr1: volatile::ReadWrite<Bwtr1>,
    _reserved3: [u8; 4usize],
    # [ doc = "0x10c - SRAM/NOR-Flash write timing registers 2" ]
    pub bwtr2: volatile::ReadWrite<Bwtr2>,
    _reserved4: [u8; 4usize],
    # [ doc = "0x114 - SRAM/NOR-Flash write timing registers 3" ]
    pub bwtr3: volatile::ReadWrite<Bwtr3>,
    _reserved5: [u8; 4usize],
    # [ doc = "0x11c - SRAM/NOR-Flash write timing registers 4" ]
    pub bwtr4: volatile::ReadWrite<Bwtr4>,
    _reserved6: [u8; 32usize],
    # [ doc = "0x140 - SDRAM Control Register 1" ]
    pub sdcr1: volatile::ReadWrite<Sdcr1>,
    # [ doc = "0x144 - SDRAM Control Register 2" ]
    pub sdcr2: volatile::ReadWrite<Sdcr2>,
    # [ doc = "0x148 - SDRAM Timing register 1" ]
    pub sdtr1: volatile::ReadWrite<Sdtr1>,
    # [ doc = "0x14c - SDRAM Timing register 2" ]
    pub sdtr2: volatile::ReadWrite<Sdtr2>,
    # [ doc = "0x150 - SDRAM Command Mode register" ]
    pub sdcmr: volatile::ReadWrite<Sdcmr>,
    # [ doc = "0x154 - SDRAM Refresh Timer register" ]
    pub sdrtr: volatile::ReadWrite<Sdrtr>,
    # [ doc = "0x158 - SDRAM Status register" ]
    pub sdsr: volatile::ReadOnly<Sdsr>,
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Bcr1 {
    bits: u32,
}

impl Bcr1 {
    # [ doc = "Bit 20 - CCLKEN" ]
    pub fn cclken(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 19 - CBURSTRW" ]
    pub fn cburstrw(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 15 - ASYNCWAIT" ]
    pub fn asyncwait(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 14 - EXTMOD" ]
    pub fn extmod(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 13 - WAITEN" ]
    pub fn waiten(&self) -> bool {
        self.bits.get_bit(13u8)
    }
    # [ doc = "Bit 12 - WREN" ]
    pub fn wren(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 11 - WAITCFG" ]
    pub fn waitcfg(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 9 - WAITPOL" ]
    pub fn waitpol(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - BURSTEN" ]
    pub fn bursten(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 6 - FACCEN" ]
    pub fn faccen(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bits 4:5 - MWID" ]
    pub fn mwid(&self) -> u8 {
        self.bits.get_range(4u8..6u8) as u8
    }
    # [ doc = "Bits 2:3 - MTYP" ]
    pub fn mtyp(&self) -> u8 {
        self.bits.get_range(2u8..4u8) as u8
    }
    # [ doc = "Bit 1 - MUXEN" ]
    pub fn muxen(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - MBKEN" ]
    pub fn mbken(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Bcr1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bcr1 { bits: 12496u32 }
    }
}

impl Bcr1 {
    # [ doc = "Bit 20 - CCLKEN" ]
    pub fn set_cclken(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 19 - CBURSTRW" ]
    pub fn set_cburstrw(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 15 - ASYNCWAIT" ]
    pub fn set_asyncwait(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 14 - EXTMOD" ]
    pub fn set_extmod(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 13 - WAITEN" ]
    pub fn set_waiten(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
    # [ doc = "Bit 12 - WREN" ]
    pub fn set_wren(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 11 - WAITCFG" ]
    pub fn set_waitcfg(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 9 - WAITPOL" ]
    pub fn set_waitpol(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - BURSTEN" ]
    pub fn set_bursten(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 6 - FACCEN" ]
    pub fn set_faccen(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bits 4:5 - MWID" ]
    pub fn set_mwid(&mut self, value: u8) {
        self.bits.set_range(4u8..6u8, value as u32);
    }
    # [ doc = "Bits 2:3 - MTYP" ]
    pub fn set_mtyp(&mut self, value: u8) {
        self.bits.set_range(2u8..4u8, value as u32);
    }
    # [ doc = "Bit 1 - MUXEN" ]
    pub fn set_muxen(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - MBKEN" ]
    pub fn set_mbken(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Btr1 {
    bits: u32,
}

impl Btr1 {
    # [ doc = "Bits 28:29 - ACCMOD" ]
    pub fn accmod(&self) -> u8 {
        self.bits.get_range(28u8..30u8) as u8
    }
    # [ doc = "Bits 24:27 - DATLAT" ]
    pub fn datlat(&self) -> u8 {
        self.bits.get_range(24u8..28u8) as u8
    }
    # [ doc = "Bits 20:23 - CLKDIV" ]
    pub fn clkdiv(&self) -> u8 {
        self.bits.get_range(20u8..24u8) as u8
    }
    # [ doc = "Bits 16:19 - BUSTURN" ]
    pub fn busturn(&self) -> u8 {
        self.bits.get_range(16u8..20u8) as u8
    }
    # [ doc = "Bits 8:15 - DATAST" ]
    pub fn datast(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bits 4:7 - ADDHLD" ]
    pub fn addhld(&self) -> u8 {
        self.bits.get_range(4u8..8u8) as u8
    }
    # [ doc = "Bits 0:3 - ADDSET" ]
    pub fn addset(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
}

impl Default for Btr1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Btr1 { bits: 4294967295u32 }
    }
}

impl Btr1 {
    # [ doc = "Bits 28:29 - ACCMOD" ]
    pub fn set_accmod(&mut self, value: u8) {
        self.bits.set_range(28u8..30u8, value as u32);
    }
    # [ doc = "Bits 24:27 - DATLAT" ]
    pub fn set_datlat(&mut self, value: u8) {
        self.bits.set_range(24u8..28u8, value as u32);
    }
    # [ doc = "Bits 20:23 - CLKDIV" ]
    pub fn set_clkdiv(&mut self, value: u8) {
        self.bits.set_range(20u8..24u8, value as u32);
    }
    # [ doc = "Bits 16:19 - BUSTURN" ]
    pub fn set_busturn(&mut self, value: u8) {
        self.bits.set_range(16u8..20u8, value as u32);
    }
    # [ doc = "Bits 8:15 - DATAST" ]
    pub fn set_datast(&mut self, value: u8) {
        self.bits.set_range(8u8..16u8, value as u32);
    }
    # [ doc = "Bits 4:7 - ADDHLD" ]
    pub fn set_addhld(&mut self, value: u8) {
        self.bits.set_range(4u8..8u8, value as u32);
    }
    # [ doc = "Bits 0:3 - ADDSET" ]
    pub fn set_addset(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Bcr2 {
    bits: u32,
}

impl Bcr2 {
    # [ doc = "Bit 19 - CBURSTRW" ]
    pub fn cburstrw(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 15 - ASYNCWAIT" ]
    pub fn asyncwait(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 14 - EXTMOD" ]
    pub fn extmod(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 13 - WAITEN" ]
    pub fn waiten(&self) -> bool {
        self.bits.get_bit(13u8)
    }
    # [ doc = "Bit 12 - WREN" ]
    pub fn wren(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 11 - WAITCFG" ]
    pub fn waitcfg(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 10 - WRAPMOD" ]
    pub fn wrapmod(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - WAITPOL" ]
    pub fn waitpol(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - BURSTEN" ]
    pub fn bursten(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 6 - FACCEN" ]
    pub fn faccen(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bits 4:5 - MWID" ]
    pub fn mwid(&self) -> u8 {
        self.bits.get_range(4u8..6u8) as u8
    }
    # [ doc = "Bits 2:3 - MTYP" ]
    pub fn mtyp(&self) -> u8 {
        self.bits.get_range(2u8..4u8) as u8
    }
    # [ doc = "Bit 1 - MUXEN" ]
    pub fn muxen(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - MBKEN" ]
    pub fn mbken(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Bcr2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bcr2 { bits: 12496u32 }
    }
}

impl Bcr2 {
    # [ doc = "Bit 19 - CBURSTRW" ]
    pub fn set_cburstrw(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 15 - ASYNCWAIT" ]
    pub fn set_asyncwait(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 14 - EXTMOD" ]
    pub fn set_extmod(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 13 - WAITEN" ]
    pub fn set_waiten(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
    # [ doc = "Bit 12 - WREN" ]
    pub fn set_wren(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 11 - WAITCFG" ]
    pub fn set_waitcfg(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 10 - WRAPMOD" ]
    pub fn set_wrapmod(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - WAITPOL" ]
    pub fn set_waitpol(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - BURSTEN" ]
    pub fn set_bursten(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 6 - FACCEN" ]
    pub fn set_faccen(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bits 4:5 - MWID" ]
    pub fn set_mwid(&mut self, value: u8) {
        self.bits.set_range(4u8..6u8, value as u32);
    }
    # [ doc = "Bits 2:3 - MTYP" ]
    pub fn set_mtyp(&mut self, value: u8) {
        self.bits.set_range(2u8..4u8, value as u32);
    }
    # [ doc = "Bit 1 - MUXEN" ]
    pub fn set_muxen(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - MBKEN" ]
    pub fn set_mbken(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Btr2 {
    bits: u32,
}

impl Btr2 {
    # [ doc = "Bits 28:29 - ACCMOD" ]
    pub fn accmod(&self) -> u8 {
        self.bits.get_range(28u8..30u8) as u8
    }
    # [ doc = "Bits 24:27 - DATLAT" ]
    pub fn datlat(&self) -> u8 {
        self.bits.get_range(24u8..28u8) as u8
    }
    # [ doc = "Bits 20:23 - CLKDIV" ]
    pub fn clkdiv(&self) -> u8 {
        self.bits.get_range(20u8..24u8) as u8
    }
    # [ doc = "Bits 16:19 - BUSTURN" ]
    pub fn busturn(&self) -> u8 {
        self.bits.get_range(16u8..20u8) as u8
    }
    # [ doc = "Bits 8:15 - DATAST" ]
    pub fn datast(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bits 4:7 - ADDHLD" ]
    pub fn addhld(&self) -> u8 {
        self.bits.get_range(4u8..8u8) as u8
    }
    # [ doc = "Bits 0:3 - ADDSET" ]
    pub fn addset(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
}

impl Default for Btr2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Btr2 { bits: 4294967295u32 }
    }
}

impl Btr2 {
    # [ doc = "Bits 28:29 - ACCMOD" ]
    pub fn set_accmod(&mut self, value: u8) {
        self.bits.set_range(28u8..30u8, value as u32);
    }
    # [ doc = "Bits 24:27 - DATLAT" ]
    pub fn set_datlat(&mut self, value: u8) {
        self.bits.set_range(24u8..28u8, value as u32);
    }
    # [ doc = "Bits 20:23 - CLKDIV" ]
    pub fn set_clkdiv(&mut self, value: u8) {
        self.bits.set_range(20u8..24u8, value as u32);
    }
    # [ doc = "Bits 16:19 - BUSTURN" ]
    pub fn set_busturn(&mut self, value: u8) {
        self.bits.set_range(16u8..20u8, value as u32);
    }
    # [ doc = "Bits 8:15 - DATAST" ]
    pub fn set_datast(&mut self, value: u8) {
        self.bits.set_range(8u8..16u8, value as u32);
    }
    # [ doc = "Bits 4:7 - ADDHLD" ]
    pub fn set_addhld(&mut self, value: u8) {
        self.bits.set_range(4u8..8u8, value as u32);
    }
    # [ doc = "Bits 0:3 - ADDSET" ]
    pub fn set_addset(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Bcr3 {
    bits: u32,
}

impl Bcr3 {
    # [ doc = "Bit 19 - CBURSTRW" ]
    pub fn cburstrw(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 15 - ASYNCWAIT" ]
    pub fn asyncwait(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 14 - EXTMOD" ]
    pub fn extmod(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 13 - WAITEN" ]
    pub fn waiten(&self) -> bool {
        self.bits.get_bit(13u8)
    }
    # [ doc = "Bit 12 - WREN" ]
    pub fn wren(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 11 - WAITCFG" ]
    pub fn waitcfg(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 10 - WRAPMOD" ]
    pub fn wrapmod(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - WAITPOL" ]
    pub fn waitpol(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - BURSTEN" ]
    pub fn bursten(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 6 - FACCEN" ]
    pub fn faccen(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bits 4:5 - MWID" ]
    pub fn mwid(&self) -> u8 {
        self.bits.get_range(4u8..6u8) as u8
    }
    # [ doc = "Bits 2:3 - MTYP" ]
    pub fn mtyp(&self) -> u8 {
        self.bits.get_range(2u8..4u8) as u8
    }
    # [ doc = "Bit 1 - MUXEN" ]
    pub fn muxen(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - MBKEN" ]
    pub fn mbken(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Bcr3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bcr3 { bits: 12496u32 }
    }
}

impl Bcr3 {
    # [ doc = "Bit 19 - CBURSTRW" ]
    pub fn set_cburstrw(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 15 - ASYNCWAIT" ]
    pub fn set_asyncwait(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 14 - EXTMOD" ]
    pub fn set_extmod(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 13 - WAITEN" ]
    pub fn set_waiten(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
    # [ doc = "Bit 12 - WREN" ]
    pub fn set_wren(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 11 - WAITCFG" ]
    pub fn set_waitcfg(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 10 - WRAPMOD" ]
    pub fn set_wrapmod(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - WAITPOL" ]
    pub fn set_waitpol(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - BURSTEN" ]
    pub fn set_bursten(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 6 - FACCEN" ]
    pub fn set_faccen(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bits 4:5 - MWID" ]
    pub fn set_mwid(&mut self, value: u8) {
        self.bits.set_range(4u8..6u8, value as u32);
    }
    # [ doc = "Bits 2:3 - MTYP" ]
    pub fn set_mtyp(&mut self, value: u8) {
        self.bits.set_range(2u8..4u8, value as u32);
    }
    # [ doc = "Bit 1 - MUXEN" ]
    pub fn set_muxen(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - MBKEN" ]
    pub fn set_mbken(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Btr3 {
    bits: u32,
}

impl Btr3 {
    # [ doc = "Bits 28:29 - ACCMOD" ]
    pub fn accmod(&self) -> u8 {
        self.bits.get_range(28u8..30u8) as u8
    }
    # [ doc = "Bits 24:27 - DATLAT" ]
    pub fn datlat(&self) -> u8 {
        self.bits.get_range(24u8..28u8) as u8
    }
    # [ doc = "Bits 20:23 - CLKDIV" ]
    pub fn clkdiv(&self) -> u8 {
        self.bits.get_range(20u8..24u8) as u8
    }
    # [ doc = "Bits 16:19 - BUSTURN" ]
    pub fn busturn(&self) -> u8 {
        self.bits.get_range(16u8..20u8) as u8
    }
    # [ doc = "Bits 8:15 - DATAST" ]
    pub fn datast(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bits 4:7 - ADDHLD" ]
    pub fn addhld(&self) -> u8 {
        self.bits.get_range(4u8..8u8) as u8
    }
    # [ doc = "Bits 0:3 - ADDSET" ]
    pub fn addset(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
}

impl Default for Btr3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Btr3 { bits: 4294967295u32 }
    }
}

impl Btr3 {
    # [ doc = "Bits 28:29 - ACCMOD" ]
    pub fn set_accmod(&mut self, value: u8) {
        self.bits.set_range(28u8..30u8, value as u32);
    }
    # [ doc = "Bits 24:27 - DATLAT" ]
    pub fn set_datlat(&mut self, value: u8) {
        self.bits.set_range(24u8..28u8, value as u32);
    }
    # [ doc = "Bits 20:23 - CLKDIV" ]
    pub fn set_clkdiv(&mut self, value: u8) {
        self.bits.set_range(20u8..24u8, value as u32);
    }
    # [ doc = "Bits 16:19 - BUSTURN" ]
    pub fn set_busturn(&mut self, value: u8) {
        self.bits.set_range(16u8..20u8, value as u32);
    }
    # [ doc = "Bits 8:15 - DATAST" ]
    pub fn set_datast(&mut self, value: u8) {
        self.bits.set_range(8u8..16u8, value as u32);
    }
    # [ doc = "Bits 4:7 - ADDHLD" ]
    pub fn set_addhld(&mut self, value: u8) {
        self.bits.set_range(4u8..8u8, value as u32);
    }
    # [ doc = "Bits 0:3 - ADDSET" ]
    pub fn set_addset(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Bcr4 {
    bits: u32,
}

impl Bcr4 {
    # [ doc = "Bit 19 - CBURSTRW" ]
    pub fn cburstrw(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 15 - ASYNCWAIT" ]
    pub fn asyncwait(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 14 - EXTMOD" ]
    pub fn extmod(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 13 - WAITEN" ]
    pub fn waiten(&self) -> bool {
        self.bits.get_bit(13u8)
    }
    # [ doc = "Bit 12 - WREN" ]
    pub fn wren(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 11 - WAITCFG" ]
    pub fn waitcfg(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 10 - WRAPMOD" ]
    pub fn wrapmod(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - WAITPOL" ]
    pub fn waitpol(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - BURSTEN" ]
    pub fn bursten(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 6 - FACCEN" ]
    pub fn faccen(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bits 4:5 - MWID" ]
    pub fn mwid(&self) -> u8 {
        self.bits.get_range(4u8..6u8) as u8
    }
    # [ doc = "Bits 2:3 - MTYP" ]
    pub fn mtyp(&self) -> u8 {
        self.bits.get_range(2u8..4u8) as u8
    }
    # [ doc = "Bit 1 - MUXEN" ]
    pub fn muxen(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - MBKEN" ]
    pub fn mbken(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Bcr4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bcr4 { bits: 12496u32 }
    }
}

impl Bcr4 {
    # [ doc = "Bit 19 - CBURSTRW" ]
    pub fn set_cburstrw(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 15 - ASYNCWAIT" ]
    pub fn set_asyncwait(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 14 - EXTMOD" ]
    pub fn set_extmod(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 13 - WAITEN" ]
    pub fn set_waiten(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
    # [ doc = "Bit 12 - WREN" ]
    pub fn set_wren(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 11 - WAITCFG" ]
    pub fn set_waitcfg(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 10 - WRAPMOD" ]
    pub fn set_wrapmod(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - WAITPOL" ]
    pub fn set_waitpol(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - BURSTEN" ]
    pub fn set_bursten(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 6 - FACCEN" ]
    pub fn set_faccen(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bits 4:5 - MWID" ]
    pub fn set_mwid(&mut self, value: u8) {
        self.bits.set_range(4u8..6u8, value as u32);
    }
    # [ doc = "Bits 2:3 - MTYP" ]
    pub fn set_mtyp(&mut self, value: u8) {
        self.bits.set_range(2u8..4u8, value as u32);
    }
    # [ doc = "Bit 1 - MUXEN" ]
    pub fn set_muxen(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - MBKEN" ]
    pub fn set_mbken(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Btr4 {
    bits: u32,
}

impl Btr4 {
    # [ doc = "Bits 28:29 - ACCMOD" ]
    pub fn accmod(&self) -> u8 {
        self.bits.get_range(28u8..30u8) as u8
    }
    # [ doc = "Bits 24:27 - DATLAT" ]
    pub fn datlat(&self) -> u8 {
        self.bits.get_range(24u8..28u8) as u8
    }
    # [ doc = "Bits 20:23 - CLKDIV" ]
    pub fn clkdiv(&self) -> u8 {
        self.bits.get_range(20u8..24u8) as u8
    }
    # [ doc = "Bits 16:19 - BUSTURN" ]
    pub fn busturn(&self) -> u8 {
        self.bits.get_range(16u8..20u8) as u8
    }
    # [ doc = "Bits 8:15 - DATAST" ]
    pub fn datast(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bits 4:7 - ADDHLD" ]
    pub fn addhld(&self) -> u8 {
        self.bits.get_range(4u8..8u8) as u8
    }
    # [ doc = "Bits 0:3 - ADDSET" ]
    pub fn addset(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
}

impl Default for Btr4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Btr4 { bits: 4294967295u32 }
    }
}

impl Btr4 {
    # [ doc = "Bits 28:29 - ACCMOD" ]
    pub fn set_accmod(&mut self, value: u8) {
        self.bits.set_range(28u8..30u8, value as u32);
    }
    # [ doc = "Bits 24:27 - DATLAT" ]
    pub fn set_datlat(&mut self, value: u8) {
        self.bits.set_range(24u8..28u8, value as u32);
    }
    # [ doc = "Bits 20:23 - CLKDIV" ]
    pub fn set_clkdiv(&mut self, value: u8) {
        self.bits.set_range(20u8..24u8, value as u32);
    }
    # [ doc = "Bits 16:19 - BUSTURN" ]
    pub fn set_busturn(&mut self, value: u8) {
        self.bits.set_range(16u8..20u8, value as u32);
    }
    # [ doc = "Bits 8:15 - DATAST" ]
    pub fn set_datast(&mut self, value: u8) {
        self.bits.set_range(8u8..16u8, value as u32);
    }
    # [ doc = "Bits 4:7 - ADDHLD" ]
    pub fn set_addhld(&mut self, value: u8) {
        self.bits.set_range(4u8..8u8, value as u32);
    }
    # [ doc = "Bits 0:3 - ADDSET" ]
    pub fn set_addset(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Pcr {
    bits: u32,
}

impl Pcr {
    # [ doc = "Bits 17:19 - ECCPS" ]
    pub fn eccps(&self) -> u8 {
        self.bits.get_range(17u8..20u8) as u8
    }
    # [ doc = "Bits 13:16 - TAR" ]
    pub fn tar(&self) -> u8 {
        self.bits.get_range(13u8..17u8) as u8
    }
    # [ doc = "Bits 9:12 - TCLR" ]
    pub fn tclr(&self) -> u8 {
        self.bits.get_range(9u8..13u8) as u8
    }
    # [ doc = "Bit 6 - ECCEN" ]
    pub fn eccen(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bits 4:5 - PWID" ]
    pub fn pwid(&self) -> u8 {
        self.bits.get_range(4u8..6u8) as u8
    }
    # [ doc = "Bit 3 - PTYP" ]
    pub fn ptyp(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - PBKEN" ]
    pub fn pbken(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - PWAITEN" ]
    pub fn pwaiten(&self) -> bool {
        self.bits.get_bit(1u8)
    }
}

impl Default for Pcr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Pcr { bits: 24u32 }
    }
}

impl Pcr {
    # [ doc = "Bits 17:19 - ECCPS" ]
    pub fn set_eccps(&mut self, value: u8) {
        self.bits.set_range(17u8..20u8, value as u32);
    }
    # [ doc = "Bits 13:16 - TAR" ]
    pub fn set_tar(&mut self, value: u8) {
        self.bits.set_range(13u8..17u8, value as u32);
    }
    # [ doc = "Bits 9:12 - TCLR" ]
    pub fn set_tclr(&mut self, value: u8) {
        self.bits.set_range(9u8..13u8, value as u32);
    }
    # [ doc = "Bit 6 - ECCEN" ]
    pub fn set_eccen(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bits 4:5 - PWID" ]
    pub fn set_pwid(&mut self, value: u8) {
        self.bits.set_range(4u8..6u8, value as u32);
    }
    # [ doc = "Bit 3 - PTYP" ]
    pub fn set_ptyp(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - PBKEN" ]
    pub fn set_pbken(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - PWAITEN" ]
    pub fn set_pwaiten(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Sr {
    bits: u32,
}

impl Sr {
    # [ doc = "Bit 6 - FEMPT" ]
    pub fn fempt(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 5 - IFEN" ]
    pub fn ifen(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - ILEN" ]
    pub fn ilen(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - IREN" ]
    pub fn iren(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - IFS" ]
    pub fn ifs(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - ILS" ]
    pub fn ils(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - IRS" ]
    pub fn irs(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Sr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Sr { bits: 64u32 }
    }
}

impl Sr {
    # [ doc = "Bit 5 - IFEN" ]
    pub fn set_ifen(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - ILEN" ]
    pub fn set_ilen(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - IREN" ]
    pub fn set_iren(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - IFS" ]
    pub fn set_ifs(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - ILS" ]
    pub fn set_ils(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - IRS" ]
    pub fn set_irs(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Pmem {
    bits: u32,
}

impl Pmem {
    # [ doc = "Bits 24:31 - MEMHIZx" ]
    pub fn memhizx(&self) -> u8 {
        self.bits.get_range(24u8..32u8) as u8
    }
    # [ doc = "Bits 16:23 - MEMHOLDx" ]
    pub fn memholdx(&self) -> u8 {
        self.bits.get_range(16u8..24u8) as u8
    }
    # [ doc = "Bits 8:15 - MEMWAITx" ]
    pub fn memwaitx(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bits 0:7 - MEMSETx" ]
    pub fn memsetx(&self) -> u8 {
        self.bits.get_range(0u8..8u8) as u8
    }
}

impl Default for Pmem {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Pmem { bits: 4244438268u32 }
    }
}

impl Pmem {
    # [ doc = "Bits 24:31 - MEMHIZx" ]
    pub fn set_memhizx(&mut self, value: u8) {
        self.bits.set_range(24u8..32u8, value as u32);
    }
    # [ doc = "Bits 16:23 - MEMHOLDx" ]
    pub fn set_memholdx(&mut self, value: u8) {
        self.bits.set_range(16u8..24u8, value as u32);
    }
    # [ doc = "Bits 8:15 - MEMWAITx" ]
    pub fn set_memwaitx(&mut self, value: u8) {
        self.bits.set_range(8u8..16u8, value as u32);
    }
    # [ doc = "Bits 0:7 - MEMSETx" ]
    pub fn set_memsetx(&mut self, value: u8) {
        self.bits.set_range(0u8..8u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Patt {
    bits: u32,
}

impl Patt {
    # [ doc = "Bits 24:31 - ATTHIZx" ]
    pub fn atthizx(&self) -> u8 {
        self.bits.get_range(24u8..32u8) as u8
    }
    # [ doc = "Bits 16:23 - ATTHOLDx" ]
    pub fn attholdx(&self) -> u8 {
        self.bits.get_range(16u8..24u8) as u8
    }
    # [ doc = "Bits 8:15 - ATTWAITx" ]
    pub fn attwaitx(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bits 0:7 - ATTSETx" ]
    pub fn attsetx(&self) -> u8 {
        self.bits.get_range(0u8..8u8) as u8
    }
}

impl Default for Patt {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Patt { bits: 4244438268u32 }
    }
}

impl Patt {
    # [ doc = "Bits 24:31 - ATTHIZx" ]
    pub fn set_atthizx(&mut self, value: u8) {
        self.bits.set_range(24u8..32u8, value as u32);
    }
    # [ doc = "Bits 16:23 - ATTHOLDx" ]
    pub fn set_attholdx(&mut self, value: u8) {
        self.bits.set_range(16u8..24u8, value as u32);
    }
    # [ doc = "Bits 8:15 - ATTWAITx" ]
    pub fn set_attwaitx(&mut self, value: u8) {
        self.bits.set_range(8u8..16u8, value as u32);
    }
    # [ doc = "Bits 0:7 - ATTSETx" ]
    pub fn set_attsetx(&mut self, value: u8) {
        self.bits.set_range(0u8..8u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Eccr {
    bits: u32,
}

impl Eccr {
    # [ doc = "Bits 0:31 - ECCx" ]
    pub fn eccx(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Eccr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Eccr { bits: 0u32 }
    }
}

impl Eccr {
    # [ doc = "Bits 0:31 - ECCx" ]
    pub fn set_eccx(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Bwtr1 {
    bits: u32,
}

impl Bwtr1 {
    # [ doc = "Bits 28:29 - ACCMOD" ]
    pub fn accmod(&self) -> u8 {
        self.bits.get_range(28u8..30u8) as u8
    }
    # [ doc = "Bits 24:27 - DATLAT" ]
    pub fn datlat(&self) -> u8 {
        self.bits.get_range(24u8..28u8) as u8
    }
    # [ doc = "Bits 20:23 - CLKDIV" ]
    pub fn clkdiv(&self) -> u8 {
        self.bits.get_range(20u8..24u8) as u8
    }
    # [ doc = "Bits 8:15 - DATAST" ]
    pub fn datast(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bits 4:7 - ADDHLD" ]
    pub fn addhld(&self) -> u8 {
        self.bits.get_range(4u8..8u8) as u8
    }
    # [ doc = "Bits 0:3 - ADDSET" ]
    pub fn addset(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
}

impl Default for Bwtr1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bwtr1 { bits: 268435455u32 }
    }
}

impl Bwtr1 {
    # [ doc = "Bits 28:29 - ACCMOD" ]
    pub fn set_accmod(&mut self, value: u8) {
        self.bits.set_range(28u8..30u8, value as u32);
    }
    # [ doc = "Bits 24:27 - DATLAT" ]
    pub fn set_datlat(&mut self, value: u8) {
        self.bits.set_range(24u8..28u8, value as u32);
    }
    # [ doc = "Bits 20:23 - CLKDIV" ]
    pub fn set_clkdiv(&mut self, value: u8) {
        self.bits.set_range(20u8..24u8, value as u32);
    }
    # [ doc = "Bits 8:15 - DATAST" ]
    pub fn set_datast(&mut self, value: u8) {
        self.bits.set_range(8u8..16u8, value as u32);
    }
    # [ doc = "Bits 4:7 - ADDHLD" ]
    pub fn set_addhld(&mut self, value: u8) {
        self.bits.set_range(4u8..8u8, value as u32);
    }
    # [ doc = "Bits 0:3 - ADDSET" ]
    pub fn set_addset(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Bwtr2 {
    bits: u32,
}

impl Bwtr2 {
    # [ doc = "Bits 28:29 - ACCMOD" ]
    pub fn accmod(&self) -> u8 {
        self.bits.get_range(28u8..30u8) as u8
    }
    # [ doc = "Bits 24:27 - DATLAT" ]
    pub fn datlat(&self) -> u8 {
        self.bits.get_range(24u8..28u8) as u8
    }
    # [ doc = "Bits 20:23 - CLKDIV" ]
    pub fn clkdiv(&self) -> u8 {
        self.bits.get_range(20u8..24u8) as u8
    }
    # [ doc = "Bits 8:15 - DATAST" ]
    pub fn datast(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bits 4:7 - ADDHLD" ]
    pub fn addhld(&self) -> u8 {
        self.bits.get_range(4u8..8u8) as u8
    }
    # [ doc = "Bits 0:3 - ADDSET" ]
    pub fn addset(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
}

impl Default for Bwtr2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bwtr2 { bits: 268435455u32 }
    }
}

impl Bwtr2 {
    # [ doc = "Bits 28:29 - ACCMOD" ]
    pub fn set_accmod(&mut self, value: u8) {
        self.bits.set_range(28u8..30u8, value as u32);
    }
    # [ doc = "Bits 24:27 - DATLAT" ]
    pub fn set_datlat(&mut self, value: u8) {
        self.bits.set_range(24u8..28u8, value as u32);
    }
    # [ doc = "Bits 20:23 - CLKDIV" ]
    pub fn set_clkdiv(&mut self, value: u8) {
        self.bits.set_range(20u8..24u8, value as u32);
    }
    # [ doc = "Bits 8:15 - DATAST" ]
    pub fn set_datast(&mut self, value: u8) {
        self.bits.set_range(8u8..16u8, value as u32);
    }
    # [ doc = "Bits 4:7 - ADDHLD" ]
    pub fn set_addhld(&mut self, value: u8) {
        self.bits.set_range(4u8..8u8, value as u32);
    }
    # [ doc = "Bits 0:3 - ADDSET" ]
    pub fn set_addset(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Bwtr3 {
    bits: u32,
}

impl Bwtr3 {
    # [ doc = "Bits 28:29 - ACCMOD" ]
    pub fn accmod(&self) -> u8 {
        self.bits.get_range(28u8..30u8) as u8
    }
    # [ doc = "Bits 24:27 - DATLAT" ]
    pub fn datlat(&self) -> u8 {
        self.bits.get_range(24u8..28u8) as u8
    }
    # [ doc = "Bits 20:23 - CLKDIV" ]
    pub fn clkdiv(&self) -> u8 {
        self.bits.get_range(20u8..24u8) as u8
    }
    # [ doc = "Bits 8:15 - DATAST" ]
    pub fn datast(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bits 4:7 - ADDHLD" ]
    pub fn addhld(&self) -> u8 {
        self.bits.get_range(4u8..8u8) as u8
    }
    # [ doc = "Bits 0:3 - ADDSET" ]
    pub fn addset(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
}

impl Default for Bwtr3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bwtr3 { bits: 268435455u32 }
    }
}

impl Bwtr3 {
    # [ doc = "Bits 28:29 - ACCMOD" ]
    pub fn set_accmod(&mut self, value: u8) {
        self.bits.set_range(28u8..30u8, value as u32);
    }
    # [ doc = "Bits 24:27 - DATLAT" ]
    pub fn set_datlat(&mut self, value: u8) {
        self.bits.set_range(24u8..28u8, value as u32);
    }
    # [ doc = "Bits 20:23 - CLKDIV" ]
    pub fn set_clkdiv(&mut self, value: u8) {
        self.bits.set_range(20u8..24u8, value as u32);
    }
    # [ doc = "Bits 8:15 - DATAST" ]
    pub fn set_datast(&mut self, value: u8) {
        self.bits.set_range(8u8..16u8, value as u32);
    }
    # [ doc = "Bits 4:7 - ADDHLD" ]
    pub fn set_addhld(&mut self, value: u8) {
        self.bits.set_range(4u8..8u8, value as u32);
    }
    # [ doc = "Bits 0:3 - ADDSET" ]
    pub fn set_addset(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Bwtr4 {
    bits: u32,
}

impl Bwtr4 {
    # [ doc = "Bits 28:29 - ACCMOD" ]
    pub fn accmod(&self) -> u8 {
        self.bits.get_range(28u8..30u8) as u8
    }
    # [ doc = "Bits 24:27 - DATLAT" ]
    pub fn datlat(&self) -> u8 {
        self.bits.get_range(24u8..28u8) as u8
    }
    # [ doc = "Bits 20:23 - CLKDIV" ]
    pub fn clkdiv(&self) -> u8 {
        self.bits.get_range(20u8..24u8) as u8
    }
    # [ doc = "Bits 8:15 - DATAST" ]
    pub fn datast(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bits 4:7 - ADDHLD" ]
    pub fn addhld(&self) -> u8 {
        self.bits.get_range(4u8..8u8) as u8
    }
    # [ doc = "Bits 0:3 - ADDSET" ]
    pub fn addset(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
}

impl Default for Bwtr4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bwtr4 { bits: 268435455u32 }
    }
}

impl Bwtr4 {
    # [ doc = "Bits 28:29 - ACCMOD" ]
    pub fn set_accmod(&mut self, value: u8) {
        self.bits.set_range(28u8..30u8, value as u32);
    }
    # [ doc = "Bits 24:27 - DATLAT" ]
    pub fn set_datlat(&mut self, value: u8) {
        self.bits.set_range(24u8..28u8, value as u32);
    }
    # [ doc = "Bits 20:23 - CLKDIV" ]
    pub fn set_clkdiv(&mut self, value: u8) {
        self.bits.set_range(20u8..24u8, value as u32);
    }
    # [ doc = "Bits 8:15 - DATAST" ]
    pub fn set_datast(&mut self, value: u8) {
        self.bits.set_range(8u8..16u8, value as u32);
    }
    # [ doc = "Bits 4:7 - ADDHLD" ]
    pub fn set_addhld(&mut self, value: u8) {
        self.bits.set_range(4u8..8u8, value as u32);
    }
    # [ doc = "Bits 0:3 - ADDSET" ]
    pub fn set_addset(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Sdcr1 {
    bits: u32,
}

impl Sdcr1 {
    # [ doc = "Bits 0:1 - Number of column address bits" ]
    pub fn nc(&self) -> u8 {
        self.bits.get_range(0u8..2u8) as u8
    }
    # [ doc = "Bits 2:3 - Number of row address bits" ]
    pub fn nr(&self) -> u8 {
        self.bits.get_range(2u8..4u8) as u8
    }
    # [ doc = "Bits 4:5 - Memory data bus width" ]
    pub fn mwid(&self) -> u8 {
        self.bits.get_range(4u8..6u8) as u8
    }
    # [ doc = "Bit 6 - Number of internal banks" ]
    pub fn nb(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bits 7:8 - CAS latency" ]
    pub fn cas(&self) -> u8 {
        self.bits.get_range(7u8..9u8) as u8
    }
    # [ doc = "Bit 9 - Write protection" ]
    pub fn wp(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bits 10:11 - SDRAM clock configuration" ]
    pub fn sdclk(&self) -> u8 {
        self.bits.get_range(10u8..12u8) as u8
    }
    # [ doc = "Bit 12 - Burst read" ]
    pub fn rburst(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bits 13:14 - Read pipe" ]
    pub fn rpipe(&self) -> u8 {
        self.bits.get_range(13u8..15u8) as u8
    }
}

impl Default for Sdcr1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Sdcr1 { bits: 720u32 }
    }
}

impl Sdcr1 {
    # [ doc = "Bits 0:1 - Number of column address bits" ]
    pub fn set_nc(&mut self, value: u8) {
        self.bits.set_range(0u8..2u8, value as u32);
    }
    # [ doc = "Bits 2:3 - Number of row address bits" ]
    pub fn set_nr(&mut self, value: u8) {
        self.bits.set_range(2u8..4u8, value as u32);
    }
    # [ doc = "Bits 4:5 - Memory data bus width" ]
    pub fn set_mwid(&mut self, value: u8) {
        self.bits.set_range(4u8..6u8, value as u32);
    }
    # [ doc = "Bit 6 - Number of internal banks" ]
    pub fn set_nb(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bits 7:8 - CAS latency" ]
    pub fn set_cas(&mut self, value: u8) {
        self.bits.set_range(7u8..9u8, value as u32);
    }
    # [ doc = "Bit 9 - Write protection" ]
    pub fn set_wp(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bits 10:11 - SDRAM clock configuration" ]
    pub fn set_sdclk(&mut self, value: u8) {
        self.bits.set_range(10u8..12u8, value as u32);
    }
    # [ doc = "Bit 12 - Burst read" ]
    pub fn set_rburst(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bits 13:14 - Read pipe" ]
    pub fn set_rpipe(&mut self, value: u8) {
        self.bits.set_range(13u8..15u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Sdcr2 {
    bits: u32,
}

impl Sdcr2 {
    # [ doc = "Bits 0:1 - Number of column address bits" ]
    pub fn nc(&self) -> u8 {
        self.bits.get_range(0u8..2u8) as u8
    }
    # [ doc = "Bits 2:3 - Number of row address bits" ]
    pub fn nr(&self) -> u8 {
        self.bits.get_range(2u8..4u8) as u8
    }
    # [ doc = "Bits 4:5 - Memory data bus width" ]
    pub fn mwid(&self) -> u8 {
        self.bits.get_range(4u8..6u8) as u8
    }
    # [ doc = "Bit 6 - Number of internal banks" ]
    pub fn nb(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bits 7:8 - CAS latency" ]
    pub fn cas(&self) -> u8 {
        self.bits.get_range(7u8..9u8) as u8
    }
    # [ doc = "Bit 9 - Write protection" ]
    pub fn wp(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bits 10:11 - SDRAM clock configuration" ]
    pub fn sdclk(&self) -> u8 {
        self.bits.get_range(10u8..12u8) as u8
    }
    # [ doc = "Bit 12 - Burst read" ]
    pub fn rburst(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bits 13:14 - Read pipe" ]
    pub fn rpipe(&self) -> u8 {
        self.bits.get_range(13u8..15u8) as u8
    }
}

impl Default for Sdcr2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Sdcr2 { bits: 720u32 }
    }
}

impl Sdcr2 {
    # [ doc = "Bits 0:1 - Number of column address bits" ]
    pub fn set_nc(&mut self, value: u8) {
        self.bits.set_range(0u8..2u8, value as u32);
    }
    # [ doc = "Bits 2:3 - Number of row address bits" ]
    pub fn set_nr(&mut self, value: u8) {
        self.bits.set_range(2u8..4u8, value as u32);
    }
    # [ doc = "Bits 4:5 - Memory data bus width" ]
    pub fn set_mwid(&mut self, value: u8) {
        self.bits.set_range(4u8..6u8, value as u32);
    }
    # [ doc = "Bit 6 - Number of internal banks" ]
    pub fn set_nb(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bits 7:8 - CAS latency" ]
    pub fn set_cas(&mut self, value: u8) {
        self.bits.set_range(7u8..9u8, value as u32);
    }
    # [ doc = "Bit 9 - Write protection" ]
    pub fn set_wp(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bits 10:11 - SDRAM clock configuration" ]
    pub fn set_sdclk(&mut self, value: u8) {
        self.bits.set_range(10u8..12u8, value as u32);
    }
    # [ doc = "Bit 12 - Burst read" ]
    pub fn set_rburst(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bits 13:14 - Read pipe" ]
    pub fn set_rpipe(&mut self, value: u8) {
        self.bits.set_range(13u8..15u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Sdtr1 {
    bits: u32,
}

impl Sdtr1 {
    # [ doc = "Bits 0:3 - Load Mode Register to Active" ]
    pub fn tmrd(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
    # [ doc = "Bits 4:7 - Exit self-refresh delay" ]
    pub fn txsr(&self) -> u8 {
        self.bits.get_range(4u8..8u8) as u8
    }
    # [ doc = "Bits 8:11 - Self refresh time" ]
    pub fn tras(&self) -> u8 {
        self.bits.get_range(8u8..12u8) as u8
    }
    # [ doc = "Bits 12:15 - Row cycle delay" ]
    pub fn trc(&self) -> u8 {
        self.bits.get_range(12u8..16u8) as u8
    }
    # [ doc = "Bits 16:19 - Recovery delay" ]
    pub fn twr(&self) -> u8 {
        self.bits.get_range(16u8..20u8) as u8
    }
    # [ doc = "Bits 20:23 - Row precharge delay" ]
    pub fn trp(&self) -> u8 {
        self.bits.get_range(20u8..24u8) as u8
    }
    # [ doc = "Bits 24:27 - Row to column delay" ]
    pub fn trcd(&self) -> u8 {
        self.bits.get_range(24u8..28u8) as u8
    }
}

impl Default for Sdtr1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Sdtr1 { bits: 268435455u32 }
    }
}

impl Sdtr1 {
    # [ doc = "Bits 0:3 - Load Mode Register to Active" ]
    pub fn set_tmrd(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
    # [ doc = "Bits 4:7 - Exit self-refresh delay" ]
    pub fn set_txsr(&mut self, value: u8) {
        self.bits.set_range(4u8..8u8, value as u32);
    }
    # [ doc = "Bits 8:11 - Self refresh time" ]
    pub fn set_tras(&mut self, value: u8) {
        self.bits.set_range(8u8..12u8, value as u32);
    }
    # [ doc = "Bits 12:15 - Row cycle delay" ]
    pub fn set_trc(&mut self, value: u8) {
        self.bits.set_range(12u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:19 - Recovery delay" ]
    pub fn set_twr(&mut self, value: u8) {
        self.bits.set_range(16u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:23 - Row precharge delay" ]
    pub fn set_trp(&mut self, value: u8) {
        self.bits.set_range(20u8..24u8, value as u32);
    }
    # [ doc = "Bits 24:27 - Row to column delay" ]
    pub fn set_trcd(&mut self, value: u8) {
        self.bits.set_range(24u8..28u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Sdtr2 {
    bits: u32,
}

impl Sdtr2 {
    # [ doc = "Bits 0:3 - Load Mode Register to Active" ]
    pub fn tmrd(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
    # [ doc = "Bits 4:7 - Exit self-refresh delay" ]
    pub fn txsr(&self) -> u8 {
        self.bits.get_range(4u8..8u8) as u8
    }
    # [ doc = "Bits 8:11 - Self refresh time" ]
    pub fn tras(&self) -> u8 {
        self.bits.get_range(8u8..12u8) as u8
    }
    # [ doc = "Bits 12:15 - Row cycle delay" ]
    pub fn trc(&self) -> u8 {
        self.bits.get_range(12u8..16u8) as u8
    }
    # [ doc = "Bits 16:19 - Recovery delay" ]
    pub fn twr(&self) -> u8 {
        self.bits.get_range(16u8..20u8) as u8
    }
    # [ doc = "Bits 20:23 - Row precharge delay" ]
    pub fn trp(&self) -> u8 {
        self.bits.get_range(20u8..24u8) as u8
    }
    # [ doc = "Bits 24:27 - Row to column delay" ]
    pub fn trcd(&self) -> u8 {
        self.bits.get_range(24u8..28u8) as u8
    }
}

impl Default for Sdtr2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Sdtr2 { bits: 268435455u32 }
    }
}

impl Sdtr2 {
    # [ doc = "Bits 0:3 - Load Mode Register to Active" ]
    pub fn set_tmrd(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
    # [ doc = "Bits 4:7 - Exit self-refresh delay" ]
    pub fn set_txsr(&mut self, value: u8) {
        self.bits.set_range(4u8..8u8, value as u32);
    }
    # [ doc = "Bits 8:11 - Self refresh time" ]
    pub fn set_tras(&mut self, value: u8) {
        self.bits.set_range(8u8..12u8, value as u32);
    }
    # [ doc = "Bits 12:15 - Row cycle delay" ]
    pub fn set_trc(&mut self, value: u8) {
        self.bits.set_range(12u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:19 - Recovery delay" ]
    pub fn set_twr(&mut self, value: u8) {
        self.bits.set_range(16u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:23 - Row precharge delay" ]
    pub fn set_trp(&mut self, value: u8) {
        self.bits.set_range(20u8..24u8, value as u32);
    }
    # [ doc = "Bits 24:27 - Row to column delay" ]
    pub fn set_trcd(&mut self, value: u8) {
        self.bits.set_range(24u8..28u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Sdcmr {
    bits: u32,
}

impl Sdcmr {
    # [ doc = "Bits 5:8 - Number of Auto-refresh" ]
    pub fn nrfs(&self) -> u8 {
        self.bits.get_range(5u8..9u8) as u8
    }
    # [ doc = "Bits 9:21 - Mode Register definition" ]
    pub fn mrd(&self) -> u16 {
        self.bits.get_range(9u8..22u8) as u16
    }
}

impl Default for Sdcmr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Sdcmr { bits: 0u32 }
    }
}

impl Sdcmr {
    # [ doc = "Bits 0:2 - Command mode" ]
    pub fn set_mode(&mut self, value: u8) {
        self.bits.set_range(0u8..3u8, value as u32);
    }
    # [ doc = "Bit 3 - Command target bank 2" ]
    pub fn set_ctb2(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - Command target bank 1" ]
    pub fn set_ctb1(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bits 5:8 - Number of Auto-refresh" ]
    pub fn set_nrfs(&mut self, value: u8) {
        self.bits.set_range(5u8..9u8, value as u32);
    }
    # [ doc = "Bits 9:21 - Mode Register definition" ]
    pub fn set_mrd(&mut self, value: u16) {
        self.bits.set_range(9u8..22u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Sdrtr {
    bits: u32,
}

impl Sdrtr {
    # [ doc = "Bits 1:13 - Refresh Timer Count" ]
    pub fn count(&self) -> u16 {
        self.bits.get_range(1u8..14u8) as u16
    }
    # [ doc = "Bit 14 - RES Interrupt Enable" ]
    pub fn reie(&self) -> bool {
        self.bits.get_bit(14u8)
    }
}

impl Default for Sdrtr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Sdrtr { bits: 0u32 }
    }
}

impl Sdrtr {
    # [ doc = "Bit 0 - Clear Refresh error flag" ]
    pub fn set_cre(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bits 1:13 - Refresh Timer Count" ]
    pub fn set_count(&mut self, value: u16) {
        self.bits.set_range(1u8..14u8, value as u32);
    }
    # [ doc = "Bit 14 - RES Interrupt Enable" ]
    pub fn set_reie(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Sdsr {
    bits: u32,
}

impl Sdsr {
    # [ doc = "Bit 0 - Refresh error flag" ]
    pub fn re(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bits 1:2 - Status Mode for Bank 1" ]
    pub fn modes1(&self) -> u8 {
        self.bits.get_range(1u8..3u8) as u8
    }
    # [ doc = "Bits 3:4 - Status Mode for Bank 2" ]
    pub fn modes2(&self) -> u8 {
        self.bits.get_range(3u8..5u8) as u8
    }
    # [ doc = "Bit 5 - Busy status" ]
    pub fn busy(&self) -> bool {
        self.bits.get_bit(5u8)
    }
}

impl Default for Sdsr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Sdsr { bits: 0u32 }
    }
}

impl Sdsr {
    # [ doc = "Bit 0 - Refresh error flag" ]
    pub fn set_re(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bits 1:2 - Status Mode for Bank 1" ]
    pub fn set_modes1(&mut self, value: u8) {
        self.bits.set_range(1u8..3u8, value as u32);
    }
    # [ doc = "Bits 3:4 - Status Mode for Bank 2" ]
    pub fn set_modes2(&mut self, value: u8) {
        self.bits.set_range(3u8..5u8, value as u32);
    }
    # [ doc = "Bit 5 - Busy status" ]
    pub fn set_busy(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
}
