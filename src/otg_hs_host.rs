// autogenerated

use volatile;
use bit_field::BitField;

# [ doc = "USB on the go high speed" ]
# [ repr ( C ) ]
pub struct OtgHsHost {
    # [ doc = "0x00 - OTG_HS host configuration register" ]
    pub otg_hs_hcfg: volatile::ReadWrite<OtgHsHcfg>,
    # [ doc = "0x04 - OTG_HS Host frame interval register" ]
    pub otg_hs_hfir: volatile::ReadWrite<OtgHsHfir>,
    # [ doc = "0x08 - OTG_HS host frame number/frame time remaining register" ]
    pub otg_hs_hfnum: volatile::ReadOnly<OtgHsHfnum>,
    _reserved0: [u8; 4usize],
    # [ doc = "0x10 - OTG_HS_Host periodic transmit FIFO/queue status register" ]
    pub otg_hs_hptxsts: volatile::ReadWrite<OtgHsHptxsts>,
    # [ doc = "0x14 - OTG_HS Host all channels interrupt register" ]
    pub otg_hs_haint: volatile::ReadOnly<OtgHsHaint>,
    # [ doc = "0x18 - OTG_HS host all channels interrupt mask register" ]
    pub otg_hs_haintmsk: volatile::ReadWrite<OtgHsHaintmsk>,
    _reserved1: [u8; 36usize],
    # [ doc = "0x40 - OTG_HS host port control and status register" ]
    pub otg_hs_hprt: volatile::ReadWrite<OtgHsHprt>,
    _reserved2: [u8; 188usize],
    # [ doc = "0x100 - OTG_HS host channel-0 characteristics register" ]
    pub otg_hs_hcchar0: volatile::ReadWrite<OtgHsHcchar0>,
    # [ doc = "0x104 - OTG_HS host channel-0 split control register" ]
    pub otg_hs_hcsplt0: volatile::ReadWrite<OtgHsHcsplt0>,
    # [ doc = "0x108 - OTG_HS host channel-11 interrupt register" ]
    pub otg_hs_hcint0: volatile::ReadWrite<OtgHsHcint0>,
    # [ doc = "0x10c - OTG_HS host channel-11 interrupt mask register" ]
    pub otg_hs_hcintmsk0: volatile::ReadWrite<OtgHsHcintmsk0>,
    # [ doc = "0x110 - OTG_HS host channel-11 transfer size register" ]
    pub otg_hs_hctsiz0: volatile::ReadWrite<OtgHsHctsiz0>,
    # [ doc = "0x114 - OTG_HS host channel-0 DMA address register" ]
    pub otg_hs_hcdma0: volatile::ReadWrite<OtgHsHcdma0>,
    _reserved3: [u8; 8usize],
    # [ doc = "0x120 - OTG_HS host channel-1 characteristics register" ]
    pub otg_hs_hcchar1: volatile::ReadWrite<OtgHsHcchar1>,
    # [ doc = "0x124 - OTG_HS host channel-1 split control register" ]
    pub otg_hs_hcsplt1: volatile::ReadWrite<OtgHsHcsplt1>,
    # [ doc = "0x128 - OTG_HS host channel-1 interrupt register" ]
    pub otg_hs_hcint1: volatile::ReadWrite<OtgHsHcint1>,
    # [ doc = "0x12c - OTG_HS host channel-1 interrupt mask register" ]
    pub otg_hs_hcintmsk1: volatile::ReadWrite<OtgHsHcintmsk1>,
    # [ doc = "0x130 - OTG_HS host channel-1 transfer size register" ]
    pub otg_hs_hctsiz1: volatile::ReadWrite<OtgHsHctsiz1>,
    # [ doc = "0x134 - OTG_HS host channel-1 DMA address register" ]
    pub otg_hs_hcdma1: volatile::ReadWrite<OtgHsHcdma1>,
    _reserved4: [u8; 8usize],
    # [ doc = "0x140 - OTG_HS host channel-2 characteristics register" ]
    pub otg_hs_hcchar2: volatile::ReadWrite<OtgHsHcchar2>,
    # [ doc = "0x144 - OTG_HS host channel-2 split control register" ]
    pub otg_hs_hcsplt2: volatile::ReadWrite<OtgHsHcsplt2>,
    # [ doc = "0x148 - OTG_HS host channel-2 interrupt register" ]
    pub otg_hs_hcint2: volatile::ReadWrite<OtgHsHcint2>,
    # [ doc = "0x14c - OTG_HS host channel-2 interrupt mask register" ]
    pub otg_hs_hcintmsk2: volatile::ReadWrite<OtgHsHcintmsk2>,
    # [ doc = "0x150 - OTG_HS host channel-2 transfer size register" ]
    pub otg_hs_hctsiz2: volatile::ReadWrite<OtgHsHctsiz2>,
    # [ doc = "0x154 - OTG_HS host channel-2 DMA address register" ]
    pub otg_hs_hcdma2: volatile::ReadWrite<OtgHsHcdma2>,
    _reserved5: [u8; 8usize],
    # [ doc = "0x160 - OTG_HS host channel-3 characteristics register" ]
    pub otg_hs_hcchar3: volatile::ReadWrite<OtgHsHcchar3>,
    # [ doc = "0x164 - OTG_HS host channel-3 split control register" ]
    pub otg_hs_hcsplt3: volatile::ReadWrite<OtgHsHcsplt3>,
    # [ doc = "0x168 - OTG_HS host channel-3 interrupt register" ]
    pub otg_hs_hcint3: volatile::ReadWrite<OtgHsHcint3>,
    # [ doc = "0x16c - OTG_HS host channel-3 interrupt mask register" ]
    pub otg_hs_hcintmsk3: volatile::ReadWrite<OtgHsHcintmsk3>,
    # [ doc = "0x170 - OTG_HS host channel-3 transfer size register" ]
    pub otg_hs_hctsiz3: volatile::ReadWrite<OtgHsHctsiz3>,
    # [ doc = "0x174 - OTG_HS host channel-3 DMA address register" ]
    pub otg_hs_hcdma3: volatile::ReadWrite<OtgHsHcdma3>,
    _reserved6: [u8; 8usize],
    # [ doc = "0x180 - OTG_HS host channel-4 characteristics register" ]
    pub otg_hs_hcchar4: volatile::ReadWrite<OtgHsHcchar4>,
    # [ doc = "0x184 - OTG_HS host channel-4 split control register" ]
    pub otg_hs_hcsplt4: volatile::ReadWrite<OtgHsHcsplt4>,
    # [ doc = "0x188 - OTG_HS host channel-4 interrupt register" ]
    pub otg_hs_hcint4: volatile::ReadWrite<OtgHsHcint4>,
    # [ doc = "0x18c - OTG_HS host channel-4 interrupt mask register" ]
    pub otg_hs_hcintmsk4: volatile::ReadWrite<OtgHsHcintmsk4>,
    # [ doc = "0x190 - OTG_HS host channel-4 transfer size register" ]
    pub otg_hs_hctsiz4: volatile::ReadWrite<OtgHsHctsiz4>,
    # [ doc = "0x194 - OTG_HS host channel-4 DMA address register" ]
    pub otg_hs_hcdma4: volatile::ReadWrite<OtgHsHcdma4>,
    _reserved7: [u8; 8usize],
    # [ doc = "0x1a0 - OTG_HS host channel-5 characteristics register" ]
    pub otg_hs_hcchar5: volatile::ReadWrite<OtgHsHcchar5>,
    # [ doc = "0x1a4 - OTG_HS host channel-5 split control register" ]
    pub otg_hs_hcsplt5: volatile::ReadWrite<OtgHsHcsplt5>,
    # [ doc = "0x1a8 - OTG_HS host channel-5 interrupt register" ]
    pub otg_hs_hcint5: volatile::ReadWrite<OtgHsHcint5>,
    # [ doc = "0x1ac - OTG_HS host channel-5 interrupt mask register" ]
    pub otg_hs_hcintmsk5: volatile::ReadWrite<OtgHsHcintmsk5>,
    # [ doc = "0x1b0 - OTG_HS host channel-5 transfer size register" ]
    pub otg_hs_hctsiz5: volatile::ReadWrite<OtgHsHctsiz5>,
    # [ doc = "0x1b4 - OTG_HS host channel-5 DMA address register" ]
    pub otg_hs_hcdma5: volatile::ReadWrite<OtgHsHcdma5>,
    _reserved8: [u8; 8usize],
    # [ doc = "0x1c0 - OTG_HS host channel-6 characteristics register" ]
    pub otg_hs_hcchar6: volatile::ReadWrite<OtgHsHcchar6>,
    # [ doc = "0x1c4 - OTG_HS host channel-6 split control register" ]
    pub otg_hs_hcsplt6: volatile::ReadWrite<OtgHsHcsplt6>,
    # [ doc = "0x1c8 - OTG_HS host channel-6 interrupt register" ]
    pub otg_hs_hcint6: volatile::ReadWrite<OtgHsHcint6>,
    # [ doc = "0x1cc - OTG_HS host channel-6 interrupt mask register" ]
    pub otg_hs_hcintmsk6: volatile::ReadWrite<OtgHsHcintmsk6>,
    # [ doc = "0x1d0 - OTG_HS host channel-6 transfer size register" ]
    pub otg_hs_hctsiz6: volatile::ReadWrite<OtgHsHctsiz6>,
    # [ doc = "0x1d4 - OTG_HS host channel-6 DMA address register" ]
    pub otg_hs_hcdma6: volatile::ReadWrite<OtgHsHcdma6>,
    _reserved9: [u8; 8usize],
    # [ doc = "0x1e0 - OTG_HS host channel-7 characteristics register" ]
    pub otg_hs_hcchar7: volatile::ReadWrite<OtgHsHcchar7>,
    # [ doc = "0x1e4 - OTG_HS host channel-7 split control register" ]
    pub otg_hs_hcsplt7: volatile::ReadWrite<OtgHsHcsplt7>,
    # [ doc = "0x1e8 - OTG_HS host channel-7 interrupt register" ]
    pub otg_hs_hcint7: volatile::ReadWrite<OtgHsHcint7>,
    # [ doc = "0x1ec - OTG_HS host channel-7 interrupt mask register" ]
    pub otg_hs_hcintmsk7: volatile::ReadWrite<OtgHsHcintmsk7>,
    # [ doc = "0x1f0 - OTG_HS host channel-7 transfer size register" ]
    pub otg_hs_hctsiz7: volatile::ReadWrite<OtgHsHctsiz7>,
    # [ doc = "0x1f4 - OTG_HS host channel-7 DMA address register" ]
    pub otg_hs_hcdma7: volatile::ReadWrite<OtgHsHcdma7>,
    _reserved10: [u8; 8usize],
    # [ doc = "0x200 - OTG_HS host channel-8 characteristics register" ]
    pub otg_hs_hcchar8: volatile::ReadWrite<OtgHsHcchar8>,
    # [ doc = "0x204 - OTG_HS host channel-8 split control register" ]
    pub otg_hs_hcsplt8: volatile::ReadWrite<OtgHsHcsplt8>,
    # [ doc = "0x208 - OTG_HS host channel-8 interrupt register" ]
    pub otg_hs_hcint8: volatile::ReadWrite<OtgHsHcint8>,
    # [ doc = "0x20c - OTG_HS host channel-8 interrupt mask register" ]
    pub otg_hs_hcintmsk8: volatile::ReadWrite<OtgHsHcintmsk8>,
    # [ doc = "0x210 - OTG_HS host channel-8 transfer size register" ]
    pub otg_hs_hctsiz8: volatile::ReadWrite<OtgHsHctsiz8>,
    # [ doc = "0x214 - OTG_HS host channel-8 DMA address register" ]
    pub otg_hs_hcdma8: volatile::ReadWrite<OtgHsHcdma8>,
    _reserved11: [u8; 8usize],
    # [ doc = "0x220 - OTG_HS host channel-9 characteristics register" ]
    pub otg_hs_hcchar9: volatile::ReadWrite<OtgHsHcchar9>,
    # [ doc = "0x224 - OTG_HS host channel-9 split control register" ]
    pub otg_hs_hcsplt9: volatile::ReadWrite<OtgHsHcsplt9>,
    # [ doc = "0x228 - OTG_HS host channel-9 interrupt register" ]
    pub otg_hs_hcint9: volatile::ReadWrite<OtgHsHcint9>,
    # [ doc = "0x22c - OTG_HS host channel-9 interrupt mask register" ]
    pub otg_hs_hcintmsk9: volatile::ReadWrite<OtgHsHcintmsk9>,
    # [ doc = "0x230 - OTG_HS host channel-9 transfer size register" ]
    pub otg_hs_hctsiz9: volatile::ReadWrite<OtgHsHctsiz9>,
    # [ doc = "0x234 - OTG_HS host channel-9 DMA address register" ]
    pub otg_hs_hcdma9: volatile::ReadWrite<OtgHsHcdma9>,
    _reserved12: [u8; 8usize],
    # [ doc = "0x240 - OTG_HS host channel-10 characteristics register" ]
    pub otg_hs_hcchar10: volatile::ReadWrite<OtgHsHcchar10>,
    # [ doc = "0x244 - OTG_HS host channel-10 split control register" ]
    pub otg_hs_hcsplt10: volatile::ReadWrite<OtgHsHcsplt10>,
    # [ doc = "0x248 - OTG_HS host channel-10 interrupt register" ]
    pub otg_hs_hcint10: volatile::ReadWrite<OtgHsHcint10>,
    # [ doc = "0x24c - OTG_HS host channel-10 interrupt mask register" ]
    pub otg_hs_hcintmsk10: volatile::ReadWrite<OtgHsHcintmsk10>,
    # [ doc = "0x250 - OTG_HS host channel-10 transfer size register" ]
    pub otg_hs_hctsiz10: volatile::ReadWrite<OtgHsHctsiz10>,
    # [ doc = "0x254 - OTG_HS host channel-10 DMA address register" ]
    pub otg_hs_hcdma10: volatile::ReadWrite<OtgHsHcdma10>,
    _reserved13: [u8; 8usize],
    # [ doc = "0x260 - OTG_HS host channel-11 characteristics register" ]
    pub otg_hs_hcchar11: volatile::ReadWrite<OtgHsHcchar11>,
    # [ doc = "0x264 - OTG_HS host channel-11 split control register" ]
    pub otg_hs_hcsplt11: volatile::ReadWrite<OtgHsHcsplt11>,
    # [ doc = "0x268 - OTG_HS host channel-11 interrupt register" ]
    pub otg_hs_hcint11: volatile::ReadWrite<OtgHsHcint11>,
    # [ doc = "0x26c - OTG_HS host channel-11 interrupt mask register" ]
    pub otg_hs_hcintmsk11: volatile::ReadWrite<OtgHsHcintmsk11>,
    # [ doc = "0x270 - OTG_HS host channel-11 transfer size register" ]
    pub otg_hs_hctsiz11: volatile::ReadWrite<OtgHsHctsiz11>,
    # [ doc = "0x274 - OTG_HS host channel-11 DMA address register" ]
    pub otg_hs_hcdma11: volatile::ReadWrite<OtgHsHcdma11>,
    # [ doc = "0x278 - OTG_HS host channel-12 characteristics register" ]
    pub otg_hs_hcchar12: volatile::ReadWrite<OtgHsHcchar12>,
    # [ doc = "0x27c - OTG_HS host channel-12 split control register" ]
    pub otg_hs_hcsplt12: volatile::ReadWrite<OtgHsHcsplt12>,
    # [ doc = "0x280 - OTG_HS host channel-12 interrupt register" ]
    pub otg_hs_hcint12: volatile::ReadWrite<OtgHsHcint12>,
    # [ doc = "0x284 - OTG_HS host channel-12 interrupt mask register" ]
    pub otg_hs_hcintmsk12: volatile::ReadWrite<OtgHsHcintmsk12>,
    # [ doc = "0x288 - OTG_HS host channel-12 transfer size register" ]
    pub otg_hs_hctsiz12: volatile::ReadWrite<OtgHsHctsiz12>,
    # [ doc = "0x28c - OTG_HS host channel-12 DMA address register" ]
    pub otg_hs_hcdma12: volatile::ReadWrite<OtgHsHcdma12>,
    # [ doc = "0x290 - OTG_HS host channel-13 characteristics register" ]
    pub otg_hs_hcchar13: volatile::ReadWrite<OtgHsHcchar13>,
    # [ doc = "0x294 - OTG_HS host channel-13 split control register" ]
    pub otg_hs_hcsplt13: volatile::ReadWrite<OtgHsHcsplt13>,
    # [ doc = "0x298 - OTG_HS host channel-13 interrupt register" ]
    pub otg_hs_hcint13: volatile::ReadWrite<OtgHsHcint13>,
    # [ doc = "0x29c - OTG_HS host channel-13 interrupt mask register" ]
    pub otg_hs_hcintmsk13: volatile::ReadWrite<OtgHsHcintmsk13>,
    # [ doc = "0x2a0 - OTG_HS host channel-13 transfer size register" ]
    pub otg_hs_hctsiz13: volatile::ReadWrite<OtgHsHctsiz13>,
    # [ doc = "0x2a4 - OTG_HS host channel-13 DMA address register" ]
    pub otg_hs_hcdma13: volatile::ReadWrite<OtgHsHcdma13>,
    # [ doc = "0x2a8 - OTG_HS host channel-14 characteristics register" ]
    pub otg_hs_hcchar14: volatile::ReadWrite<OtgHsHcchar14>,
    # [ doc = "0x2ac - OTG_HS host channel-14 split control register" ]
    pub otg_hs_hcsplt14: volatile::ReadWrite<OtgHsHcsplt14>,
    # [ doc = "0x2b0 - OTG_HS host channel-14 interrupt register" ]
    pub otg_hs_hcint14: volatile::ReadWrite<OtgHsHcint14>,
    # [ doc = "0x2b4 - OTG_HS host channel-14 interrupt mask register" ]
    pub otg_hs_hcintmsk14: volatile::ReadWrite<OtgHsHcintmsk14>,
    # [ doc = "0x2b8 - OTG_HS host channel-14 transfer size register" ]
    pub otg_hs_hctsiz14: volatile::ReadWrite<OtgHsHctsiz14>,
    # [ doc = "0x2bc - OTG_HS host channel-14 DMA address register" ]
    pub otg_hs_hcdma14: volatile::ReadWrite<OtgHsHcdma14>,
    # [ doc = "0x2c0 - OTG_HS host channel-15 characteristics register" ]
    pub otg_hs_hcchar15: volatile::ReadWrite<OtgHsHcchar15>,
    # [ doc = "0x2c4 - OTG_HS host channel-15 split control register" ]
    pub otg_hs_hcsplt15: volatile::ReadWrite<OtgHsHcsplt15>,
    # [ doc = "0x2c8 - OTG_HS host channel-15 interrupt register" ]
    pub otg_hs_hcint15: volatile::ReadWrite<OtgHsHcint15>,
    # [ doc = "0x2cc - OTG_HS host channel-15 interrupt mask register" ]
    pub otg_hs_hcintmsk15: volatile::ReadWrite<OtgHsHcintmsk15>,
    # [ doc = "0x2d0 - OTG_HS host channel-15 transfer size register" ]
    pub otg_hs_hctsiz15: volatile::ReadWrite<OtgHsHctsiz15>,
    # [ doc = "0x2d4 - OTG_HS host channel-15 DMA address register" ]
    pub otg_hs_hcdma15: volatile::ReadWrite<OtgHsHcdma15>,
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcfg {
    bits: u32,
}

impl OtgHsHcfg {
    # [ doc = "Bits 0:1 - FS/LS PHY clock select" ]
    pub fn fslspcs(&self) -> u8 {
        self.bits.get_range(0u8..2u8) as u8
    }
    # [ doc = "Bit 2 - FS- and LS-only support" ]
    pub fn fslss(&self) -> bool {
        self.bits.get_bit(2u8)
    }
}

impl Default for OtgHsHcfg {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcfg { bits: 0u32 }
    }
}

impl OtgHsHcfg {
    # [ doc = "Bits 0:1 - FS/LS PHY clock select" ]
    pub fn set_fslspcs(&mut self, value: u8) {
        self.bits.set_range(0u8..2u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHfir {
    bits: u32,
}

impl OtgHsHfir {
    # [ doc = "Bits 0:15 - Frame interval" ]
    pub fn frivl(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for OtgHsHfir {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHfir { bits: 60000u32 }
    }
}

impl OtgHsHfir {
    # [ doc = "Bits 0:15 - Frame interval" ]
    pub fn set_frivl(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHfnum {
    bits: u32,
}

impl OtgHsHfnum {
    # [ doc = "Bits 0:15 - Frame number" ]
    pub fn frnum(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:31 - Frame time remaining" ]
    pub fn ftrem(&self) -> u16 {
        self.bits.get_range(16u8..32u8) as u16
    }
}

impl Default for OtgHsHfnum {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHfnum { bits: 16383u32 }
    }
}

impl OtgHsHfnum {
    # [ doc = "Bits 0:15 - Frame number" ]
    pub fn set_frnum(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:31 - Frame time remaining" ]
    pub fn set_ftrem(&mut self, value: u16) {
        self.bits.set_range(16u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHptxsts {
    bits: u32,
}

impl OtgHsHptxsts {
    # [ doc = "Bits 0:15 - Periodic transmit data FIFO space available" ]
    pub fn ptxfsavl(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:23 - Periodic transmit request queue space available" ]
    pub fn ptxqsav(&self) -> u8 {
        self.bits.get_range(16u8..24u8) as u8
    }
    # [ doc = "Bits 24:31 - Top of the periodic transmit request queue" ]
    pub fn ptxqtop(&self) -> u8 {
        self.bits.get_range(24u8..32u8) as u8
    }
}

impl Default for OtgHsHptxsts {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHptxsts { bits: 524544u32 }
    }
}

impl OtgHsHptxsts {
    # [ doc = "Bits 0:15 - Periodic transmit data FIFO space available" ]
    pub fn set_ptxfsavl(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHaint {
    bits: u32,
}

impl OtgHsHaint {
    # [ doc = "Bits 0:15 - Channel interrupts" ]
    pub fn haint(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for OtgHsHaint {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHaint { bits: 0u32 }
    }
}

impl OtgHsHaint {
    # [ doc = "Bits 0:15 - Channel interrupts" ]
    pub fn set_haint(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHaintmsk {
    bits: u32,
}

impl OtgHsHaintmsk {
    # [ doc = "Bits 0:15 - Channel interrupt mask" ]
    pub fn haintm(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for OtgHsHaintmsk {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHaintmsk { bits: 0u32 }
    }
}

impl OtgHsHaintmsk {
    # [ doc = "Bits 0:15 - Channel interrupt mask" ]
    pub fn set_haintm(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHprt {
    bits: u32,
}

impl OtgHsHprt {
    # [ doc = "Bit 0 - Port connect status" ]
    pub fn pcsts(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Port connect detected" ]
    pub fn pcdet(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - Port enable" ]
    pub fn pena(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - Port enable/disable change" ]
    pub fn penchng(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - Port overcurrent active" ]
    pub fn poca(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - Port overcurrent change" ]
    pub fn pocchng(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Port resume" ]
    pub fn pres(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Port suspend" ]
    pub fn psusp(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Port reset" ]
    pub fn prst(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bits 10:11 - Port line status" ]
    pub fn plsts(&self) -> u8 {
        self.bits.get_range(10u8..12u8) as u8
    }
    # [ doc = "Bit 12 - Port power" ]
    pub fn ppwr(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bits 13:16 - Port test control" ]
    pub fn ptctl(&self) -> u8 {
        self.bits.get_range(13u8..17u8) as u8
    }
    # [ doc = "Bits 17:18 - Port speed" ]
    pub fn pspd(&self) -> u8 {
        self.bits.get_range(17u8..19u8) as u8
    }
}

impl Default for OtgHsHprt {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHprt { bits: 0u32 }
    }
}

impl OtgHsHprt {
    # [ doc = "Bit 1 - Port connect detected" ]
    pub fn set_pcdet(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - Port enable" ]
    pub fn set_pena(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - Port enable/disable change" ]
    pub fn set_penchng(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 5 - Port overcurrent change" ]
    pub fn set_pocchng(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Port resume" ]
    pub fn set_pres(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Port suspend" ]
    pub fn set_psusp(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Port reset" ]
    pub fn set_prst(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 12 - Port power" ]
    pub fn set_ppwr(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bits 13:16 - Port test control" ]
    pub fn set_ptctl(&mut self, value: u8) {
        self.bits.set_range(13u8..17u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcchar0 {
    bits: u32,
}

impl OtgHsHcchar0 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn mc(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcchar0 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcchar0 { bits: 0u32 }
    }
}

impl OtgHsHcchar0 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn set_mc(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcsplt0 {
    bits: u32,
}

impl OtgHsHcsplt0 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn prtaddr(&self) -> u8 {
        self.bits.get_range(0u8..7u8) as u8
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn hubaddr(&self) -> u8 {
        self.bits.get_range(7u8..14u8) as u8
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn xactpos(&self) -> u8 {
        self.bits.get_range(14u8..16u8) as u8
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn complsplt(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn spliten(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcsplt0 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcsplt0 { bits: 0u32 }
    }
}

impl OtgHsHcsplt0 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn set_prtaddr(&mut self, value: u8) {
        self.bits.set_range(0u8..7u8, value as u32);
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn set_hubaddr(&mut self, value: u8) {
        self.bits.set_range(7u8..14u8, value as u32);
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn set_xactpos(&mut self, value: u8) {
        self.bits.set_range(14u8..16u8, value as u32);
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn set_complsplt(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn set_spliten(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcint0 {
    bits: u32,
}

impl OtgHsHcint0 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcint0 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcint0 { bits: 0u32 }
    }
}

impl OtgHsHcint0 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcintmsk0 {
    bits: u32,
}

impl OtgHsHcintmsk0 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcintmsk0 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcintmsk0 { bits: 0u32 }
    }
}

impl OtgHsHcintmsk0 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHctsiz0 {
    bits: u32,
}

impl OtgHsHctsiz0 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsHctsiz0 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHctsiz0 { bits: 0u32 }
    }
}

impl OtgHsHctsiz0 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcdma0 {
    bits: u32,
}

impl OtgHsHcdma0 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn dmaaddr(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for OtgHsHcdma0 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcdma0 { bits: 0u32 }
    }
}

impl OtgHsHcdma0 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn set_dmaaddr(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcchar1 {
    bits: u32,
}

impl OtgHsHcchar1 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn mc(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcchar1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcchar1 { bits: 0u32 }
    }
}

impl OtgHsHcchar1 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn set_mc(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcsplt1 {
    bits: u32,
}

impl OtgHsHcsplt1 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn prtaddr(&self) -> u8 {
        self.bits.get_range(0u8..7u8) as u8
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn hubaddr(&self) -> u8 {
        self.bits.get_range(7u8..14u8) as u8
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn xactpos(&self) -> u8 {
        self.bits.get_range(14u8..16u8) as u8
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn complsplt(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn spliten(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcsplt1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcsplt1 { bits: 0u32 }
    }
}

impl OtgHsHcsplt1 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn set_prtaddr(&mut self, value: u8) {
        self.bits.set_range(0u8..7u8, value as u32);
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn set_hubaddr(&mut self, value: u8) {
        self.bits.set_range(7u8..14u8, value as u32);
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn set_xactpos(&mut self, value: u8) {
        self.bits.set_range(14u8..16u8, value as u32);
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn set_complsplt(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn set_spliten(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcint1 {
    bits: u32,
}

impl OtgHsHcint1 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcint1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcint1 { bits: 0u32 }
    }
}

impl OtgHsHcint1 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcintmsk1 {
    bits: u32,
}

impl OtgHsHcintmsk1 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcintmsk1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcintmsk1 { bits: 0u32 }
    }
}

impl OtgHsHcintmsk1 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHctsiz1 {
    bits: u32,
}

impl OtgHsHctsiz1 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsHctsiz1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHctsiz1 { bits: 0u32 }
    }
}

impl OtgHsHctsiz1 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcdma1 {
    bits: u32,
}

impl OtgHsHcdma1 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn dmaaddr(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for OtgHsHcdma1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcdma1 { bits: 0u32 }
    }
}

impl OtgHsHcdma1 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn set_dmaaddr(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcchar2 {
    bits: u32,
}

impl OtgHsHcchar2 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn mc(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcchar2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcchar2 { bits: 0u32 }
    }
}

impl OtgHsHcchar2 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn set_mc(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcsplt2 {
    bits: u32,
}

impl OtgHsHcsplt2 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn prtaddr(&self) -> u8 {
        self.bits.get_range(0u8..7u8) as u8
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn hubaddr(&self) -> u8 {
        self.bits.get_range(7u8..14u8) as u8
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn xactpos(&self) -> u8 {
        self.bits.get_range(14u8..16u8) as u8
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn complsplt(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn spliten(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcsplt2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcsplt2 { bits: 0u32 }
    }
}

impl OtgHsHcsplt2 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn set_prtaddr(&mut self, value: u8) {
        self.bits.set_range(0u8..7u8, value as u32);
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn set_hubaddr(&mut self, value: u8) {
        self.bits.set_range(7u8..14u8, value as u32);
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn set_xactpos(&mut self, value: u8) {
        self.bits.set_range(14u8..16u8, value as u32);
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn set_complsplt(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn set_spliten(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcint2 {
    bits: u32,
}

impl OtgHsHcint2 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcint2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcint2 { bits: 0u32 }
    }
}

impl OtgHsHcint2 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcintmsk2 {
    bits: u32,
}

impl OtgHsHcintmsk2 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcintmsk2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcintmsk2 { bits: 0u32 }
    }
}

impl OtgHsHcintmsk2 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHctsiz2 {
    bits: u32,
}

impl OtgHsHctsiz2 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsHctsiz2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHctsiz2 { bits: 0u32 }
    }
}

impl OtgHsHctsiz2 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcdma2 {
    bits: u32,
}

impl OtgHsHcdma2 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn dmaaddr(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for OtgHsHcdma2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcdma2 { bits: 0u32 }
    }
}

impl OtgHsHcdma2 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn set_dmaaddr(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcchar3 {
    bits: u32,
}

impl OtgHsHcchar3 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn mc(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcchar3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcchar3 { bits: 0u32 }
    }
}

impl OtgHsHcchar3 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn set_mc(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcsplt3 {
    bits: u32,
}

impl OtgHsHcsplt3 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn prtaddr(&self) -> u8 {
        self.bits.get_range(0u8..7u8) as u8
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn hubaddr(&self) -> u8 {
        self.bits.get_range(7u8..14u8) as u8
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn xactpos(&self) -> u8 {
        self.bits.get_range(14u8..16u8) as u8
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn complsplt(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn spliten(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcsplt3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcsplt3 { bits: 0u32 }
    }
}

impl OtgHsHcsplt3 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn set_prtaddr(&mut self, value: u8) {
        self.bits.set_range(0u8..7u8, value as u32);
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn set_hubaddr(&mut self, value: u8) {
        self.bits.set_range(7u8..14u8, value as u32);
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn set_xactpos(&mut self, value: u8) {
        self.bits.set_range(14u8..16u8, value as u32);
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn set_complsplt(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn set_spliten(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcint3 {
    bits: u32,
}

impl OtgHsHcint3 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcint3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcint3 { bits: 0u32 }
    }
}

impl OtgHsHcint3 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcintmsk3 {
    bits: u32,
}

impl OtgHsHcintmsk3 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcintmsk3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcintmsk3 { bits: 0u32 }
    }
}

impl OtgHsHcintmsk3 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHctsiz3 {
    bits: u32,
}

impl OtgHsHctsiz3 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsHctsiz3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHctsiz3 { bits: 0u32 }
    }
}

impl OtgHsHctsiz3 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcdma3 {
    bits: u32,
}

impl OtgHsHcdma3 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn dmaaddr(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for OtgHsHcdma3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcdma3 { bits: 0u32 }
    }
}

impl OtgHsHcdma3 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn set_dmaaddr(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcchar4 {
    bits: u32,
}

impl OtgHsHcchar4 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn mc(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcchar4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcchar4 { bits: 0u32 }
    }
}

impl OtgHsHcchar4 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn set_mc(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcsplt4 {
    bits: u32,
}

impl OtgHsHcsplt4 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn prtaddr(&self) -> u8 {
        self.bits.get_range(0u8..7u8) as u8
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn hubaddr(&self) -> u8 {
        self.bits.get_range(7u8..14u8) as u8
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn xactpos(&self) -> u8 {
        self.bits.get_range(14u8..16u8) as u8
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn complsplt(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn spliten(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcsplt4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcsplt4 { bits: 0u32 }
    }
}

impl OtgHsHcsplt4 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn set_prtaddr(&mut self, value: u8) {
        self.bits.set_range(0u8..7u8, value as u32);
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn set_hubaddr(&mut self, value: u8) {
        self.bits.set_range(7u8..14u8, value as u32);
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn set_xactpos(&mut self, value: u8) {
        self.bits.set_range(14u8..16u8, value as u32);
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn set_complsplt(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn set_spliten(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcint4 {
    bits: u32,
}

impl OtgHsHcint4 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcint4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcint4 { bits: 0u32 }
    }
}

impl OtgHsHcint4 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcintmsk4 {
    bits: u32,
}

impl OtgHsHcintmsk4 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcintmsk4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcintmsk4 { bits: 0u32 }
    }
}

impl OtgHsHcintmsk4 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHctsiz4 {
    bits: u32,
}

impl OtgHsHctsiz4 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsHctsiz4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHctsiz4 { bits: 0u32 }
    }
}

impl OtgHsHctsiz4 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcdma4 {
    bits: u32,
}

impl OtgHsHcdma4 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn dmaaddr(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for OtgHsHcdma4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcdma4 { bits: 0u32 }
    }
}

impl OtgHsHcdma4 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn set_dmaaddr(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcchar5 {
    bits: u32,
}

impl OtgHsHcchar5 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn mc(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcchar5 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcchar5 { bits: 0u32 }
    }
}

impl OtgHsHcchar5 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn set_mc(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcsplt5 {
    bits: u32,
}

impl OtgHsHcsplt5 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn prtaddr(&self) -> u8 {
        self.bits.get_range(0u8..7u8) as u8
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn hubaddr(&self) -> u8 {
        self.bits.get_range(7u8..14u8) as u8
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn xactpos(&self) -> u8 {
        self.bits.get_range(14u8..16u8) as u8
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn complsplt(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn spliten(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcsplt5 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcsplt5 { bits: 0u32 }
    }
}

impl OtgHsHcsplt5 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn set_prtaddr(&mut self, value: u8) {
        self.bits.set_range(0u8..7u8, value as u32);
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn set_hubaddr(&mut self, value: u8) {
        self.bits.set_range(7u8..14u8, value as u32);
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn set_xactpos(&mut self, value: u8) {
        self.bits.set_range(14u8..16u8, value as u32);
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn set_complsplt(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn set_spliten(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcint5 {
    bits: u32,
}

impl OtgHsHcint5 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcint5 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcint5 { bits: 0u32 }
    }
}

impl OtgHsHcint5 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcintmsk5 {
    bits: u32,
}

impl OtgHsHcintmsk5 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcintmsk5 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcintmsk5 { bits: 0u32 }
    }
}

impl OtgHsHcintmsk5 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHctsiz5 {
    bits: u32,
}

impl OtgHsHctsiz5 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsHctsiz5 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHctsiz5 { bits: 0u32 }
    }
}

impl OtgHsHctsiz5 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcdma5 {
    bits: u32,
}

impl OtgHsHcdma5 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn dmaaddr(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for OtgHsHcdma5 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcdma5 { bits: 0u32 }
    }
}

impl OtgHsHcdma5 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn set_dmaaddr(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcchar6 {
    bits: u32,
}

impl OtgHsHcchar6 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn mc(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcchar6 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcchar6 { bits: 0u32 }
    }
}

impl OtgHsHcchar6 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn set_mc(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcsplt6 {
    bits: u32,
}

impl OtgHsHcsplt6 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn prtaddr(&self) -> u8 {
        self.bits.get_range(0u8..7u8) as u8
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn hubaddr(&self) -> u8 {
        self.bits.get_range(7u8..14u8) as u8
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn xactpos(&self) -> u8 {
        self.bits.get_range(14u8..16u8) as u8
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn complsplt(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn spliten(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcsplt6 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcsplt6 { bits: 0u32 }
    }
}

impl OtgHsHcsplt6 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn set_prtaddr(&mut self, value: u8) {
        self.bits.set_range(0u8..7u8, value as u32);
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn set_hubaddr(&mut self, value: u8) {
        self.bits.set_range(7u8..14u8, value as u32);
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn set_xactpos(&mut self, value: u8) {
        self.bits.set_range(14u8..16u8, value as u32);
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn set_complsplt(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn set_spliten(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcint6 {
    bits: u32,
}

impl OtgHsHcint6 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcint6 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcint6 { bits: 0u32 }
    }
}

impl OtgHsHcint6 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcintmsk6 {
    bits: u32,
}

impl OtgHsHcintmsk6 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcintmsk6 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcintmsk6 { bits: 0u32 }
    }
}

impl OtgHsHcintmsk6 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHctsiz6 {
    bits: u32,
}

impl OtgHsHctsiz6 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsHctsiz6 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHctsiz6 { bits: 0u32 }
    }
}

impl OtgHsHctsiz6 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcdma6 {
    bits: u32,
}

impl OtgHsHcdma6 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn dmaaddr(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for OtgHsHcdma6 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcdma6 { bits: 0u32 }
    }
}

impl OtgHsHcdma6 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn set_dmaaddr(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcchar7 {
    bits: u32,
}

impl OtgHsHcchar7 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn mc(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcchar7 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcchar7 { bits: 0u32 }
    }
}

impl OtgHsHcchar7 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn set_mc(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcsplt7 {
    bits: u32,
}

impl OtgHsHcsplt7 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn prtaddr(&self) -> u8 {
        self.bits.get_range(0u8..7u8) as u8
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn hubaddr(&self) -> u8 {
        self.bits.get_range(7u8..14u8) as u8
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn xactpos(&self) -> u8 {
        self.bits.get_range(14u8..16u8) as u8
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn complsplt(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn spliten(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcsplt7 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcsplt7 { bits: 0u32 }
    }
}

impl OtgHsHcsplt7 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn set_prtaddr(&mut self, value: u8) {
        self.bits.set_range(0u8..7u8, value as u32);
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn set_hubaddr(&mut self, value: u8) {
        self.bits.set_range(7u8..14u8, value as u32);
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn set_xactpos(&mut self, value: u8) {
        self.bits.set_range(14u8..16u8, value as u32);
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn set_complsplt(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn set_spliten(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcint7 {
    bits: u32,
}

impl OtgHsHcint7 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcint7 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcint7 { bits: 0u32 }
    }
}

impl OtgHsHcint7 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcintmsk7 {
    bits: u32,
}

impl OtgHsHcintmsk7 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcintmsk7 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcintmsk7 { bits: 0u32 }
    }
}

impl OtgHsHcintmsk7 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHctsiz7 {
    bits: u32,
}

impl OtgHsHctsiz7 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsHctsiz7 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHctsiz7 { bits: 0u32 }
    }
}

impl OtgHsHctsiz7 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcdma7 {
    bits: u32,
}

impl OtgHsHcdma7 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn dmaaddr(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for OtgHsHcdma7 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcdma7 { bits: 0u32 }
    }
}

impl OtgHsHcdma7 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn set_dmaaddr(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcchar8 {
    bits: u32,
}

impl OtgHsHcchar8 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn mc(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcchar8 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcchar8 { bits: 0u32 }
    }
}

impl OtgHsHcchar8 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn set_mc(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcsplt8 {
    bits: u32,
}

impl OtgHsHcsplt8 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn prtaddr(&self) -> u8 {
        self.bits.get_range(0u8..7u8) as u8
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn hubaddr(&self) -> u8 {
        self.bits.get_range(7u8..14u8) as u8
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn xactpos(&self) -> u8 {
        self.bits.get_range(14u8..16u8) as u8
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn complsplt(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn spliten(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcsplt8 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcsplt8 { bits: 0u32 }
    }
}

impl OtgHsHcsplt8 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn set_prtaddr(&mut self, value: u8) {
        self.bits.set_range(0u8..7u8, value as u32);
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn set_hubaddr(&mut self, value: u8) {
        self.bits.set_range(7u8..14u8, value as u32);
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn set_xactpos(&mut self, value: u8) {
        self.bits.set_range(14u8..16u8, value as u32);
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn set_complsplt(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn set_spliten(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcint8 {
    bits: u32,
}

impl OtgHsHcint8 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcint8 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcint8 { bits: 0u32 }
    }
}

impl OtgHsHcint8 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcintmsk8 {
    bits: u32,
}

impl OtgHsHcintmsk8 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcintmsk8 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcintmsk8 { bits: 0u32 }
    }
}

impl OtgHsHcintmsk8 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHctsiz8 {
    bits: u32,
}

impl OtgHsHctsiz8 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsHctsiz8 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHctsiz8 { bits: 0u32 }
    }
}

impl OtgHsHctsiz8 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcdma8 {
    bits: u32,
}

impl OtgHsHcdma8 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn dmaaddr(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for OtgHsHcdma8 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcdma8 { bits: 0u32 }
    }
}

impl OtgHsHcdma8 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn set_dmaaddr(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcchar9 {
    bits: u32,
}

impl OtgHsHcchar9 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn mc(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcchar9 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcchar9 { bits: 0u32 }
    }
}

impl OtgHsHcchar9 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn set_mc(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcsplt9 {
    bits: u32,
}

impl OtgHsHcsplt9 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn prtaddr(&self) -> u8 {
        self.bits.get_range(0u8..7u8) as u8
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn hubaddr(&self) -> u8 {
        self.bits.get_range(7u8..14u8) as u8
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn xactpos(&self) -> u8 {
        self.bits.get_range(14u8..16u8) as u8
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn complsplt(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn spliten(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcsplt9 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcsplt9 { bits: 0u32 }
    }
}

impl OtgHsHcsplt9 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn set_prtaddr(&mut self, value: u8) {
        self.bits.set_range(0u8..7u8, value as u32);
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn set_hubaddr(&mut self, value: u8) {
        self.bits.set_range(7u8..14u8, value as u32);
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn set_xactpos(&mut self, value: u8) {
        self.bits.set_range(14u8..16u8, value as u32);
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn set_complsplt(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn set_spliten(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcint9 {
    bits: u32,
}

impl OtgHsHcint9 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcint9 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcint9 { bits: 0u32 }
    }
}

impl OtgHsHcint9 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcintmsk9 {
    bits: u32,
}

impl OtgHsHcintmsk9 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcintmsk9 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcintmsk9 { bits: 0u32 }
    }
}

impl OtgHsHcintmsk9 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHctsiz9 {
    bits: u32,
}

impl OtgHsHctsiz9 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsHctsiz9 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHctsiz9 { bits: 0u32 }
    }
}

impl OtgHsHctsiz9 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcdma9 {
    bits: u32,
}

impl OtgHsHcdma9 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn dmaaddr(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for OtgHsHcdma9 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcdma9 { bits: 0u32 }
    }
}

impl OtgHsHcdma9 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn set_dmaaddr(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcchar10 {
    bits: u32,
}

impl OtgHsHcchar10 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn mc(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcchar10 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcchar10 { bits: 0u32 }
    }
}

impl OtgHsHcchar10 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn set_mc(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcsplt10 {
    bits: u32,
}

impl OtgHsHcsplt10 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn prtaddr(&self) -> u8 {
        self.bits.get_range(0u8..7u8) as u8
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn hubaddr(&self) -> u8 {
        self.bits.get_range(7u8..14u8) as u8
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn xactpos(&self) -> u8 {
        self.bits.get_range(14u8..16u8) as u8
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn complsplt(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn spliten(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcsplt10 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcsplt10 { bits: 0u32 }
    }
}

impl OtgHsHcsplt10 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn set_prtaddr(&mut self, value: u8) {
        self.bits.set_range(0u8..7u8, value as u32);
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn set_hubaddr(&mut self, value: u8) {
        self.bits.set_range(7u8..14u8, value as u32);
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn set_xactpos(&mut self, value: u8) {
        self.bits.set_range(14u8..16u8, value as u32);
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn set_complsplt(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn set_spliten(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcint10 {
    bits: u32,
}

impl OtgHsHcint10 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcint10 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcint10 { bits: 0u32 }
    }
}

impl OtgHsHcint10 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcintmsk10 {
    bits: u32,
}

impl OtgHsHcintmsk10 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcintmsk10 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcintmsk10 { bits: 0u32 }
    }
}

impl OtgHsHcintmsk10 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHctsiz10 {
    bits: u32,
}

impl OtgHsHctsiz10 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsHctsiz10 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHctsiz10 { bits: 0u32 }
    }
}

impl OtgHsHctsiz10 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcdma10 {
    bits: u32,
}

impl OtgHsHcdma10 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn dmaaddr(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for OtgHsHcdma10 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcdma10 { bits: 0u32 }
    }
}

impl OtgHsHcdma10 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn set_dmaaddr(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcchar11 {
    bits: u32,
}

impl OtgHsHcchar11 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn mc(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcchar11 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcchar11 { bits: 0u32 }
    }
}

impl OtgHsHcchar11 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn set_mc(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcsplt11 {
    bits: u32,
}

impl OtgHsHcsplt11 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn prtaddr(&self) -> u8 {
        self.bits.get_range(0u8..7u8) as u8
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn hubaddr(&self) -> u8 {
        self.bits.get_range(7u8..14u8) as u8
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn xactpos(&self) -> u8 {
        self.bits.get_range(14u8..16u8) as u8
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn complsplt(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn spliten(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcsplt11 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcsplt11 { bits: 0u32 }
    }
}

impl OtgHsHcsplt11 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn set_prtaddr(&mut self, value: u8) {
        self.bits.set_range(0u8..7u8, value as u32);
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn set_hubaddr(&mut self, value: u8) {
        self.bits.set_range(7u8..14u8, value as u32);
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn set_xactpos(&mut self, value: u8) {
        self.bits.set_range(14u8..16u8, value as u32);
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn set_complsplt(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn set_spliten(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcint11 {
    bits: u32,
}

impl OtgHsHcint11 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcint11 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcint11 { bits: 0u32 }
    }
}

impl OtgHsHcint11 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcintmsk11 {
    bits: u32,
}

impl OtgHsHcintmsk11 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcintmsk11 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcintmsk11 { bits: 0u32 }
    }
}

impl OtgHsHcintmsk11 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHctsiz11 {
    bits: u32,
}

impl OtgHsHctsiz11 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsHctsiz11 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHctsiz11 { bits: 0u32 }
    }
}

impl OtgHsHctsiz11 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcdma11 {
    bits: u32,
}

impl OtgHsHcdma11 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn dmaaddr(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for OtgHsHcdma11 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcdma11 { bits: 0u32 }
    }
}

impl OtgHsHcdma11 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn set_dmaaddr(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcchar12 {
    bits: u32,
}

impl OtgHsHcchar12 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn mc(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcchar12 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcchar12 { bits: 0u32 }
    }
}

impl OtgHsHcchar12 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn set_mc(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcsplt12 {
    bits: u32,
}

impl OtgHsHcsplt12 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn prtaddr(&self) -> u8 {
        self.bits.get_range(0u8..7u8) as u8
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn hubaddr(&self) -> u8 {
        self.bits.get_range(7u8..14u8) as u8
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn xactpos(&self) -> u8 {
        self.bits.get_range(14u8..16u8) as u8
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn complsplt(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn spliten(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcsplt12 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcsplt12 { bits: 0u32 }
    }
}

impl OtgHsHcsplt12 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn set_prtaddr(&mut self, value: u8) {
        self.bits.set_range(0u8..7u8, value as u32);
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn set_hubaddr(&mut self, value: u8) {
        self.bits.set_range(7u8..14u8, value as u32);
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn set_xactpos(&mut self, value: u8) {
        self.bits.set_range(14u8..16u8, value as u32);
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn set_complsplt(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn set_spliten(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcint12 {
    bits: u32,
}

impl OtgHsHcint12 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcint12 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcint12 { bits: 0u32 }
    }
}

impl OtgHsHcint12 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcintmsk12 {
    bits: u32,
}

impl OtgHsHcintmsk12 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcintmsk12 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcintmsk12 { bits: 0u32 }
    }
}

impl OtgHsHcintmsk12 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHctsiz12 {
    bits: u32,
}

impl OtgHsHctsiz12 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsHctsiz12 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHctsiz12 { bits: 0u32 }
    }
}

impl OtgHsHctsiz12 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcdma12 {
    bits: u32,
}

impl OtgHsHcdma12 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn dmaaddr(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for OtgHsHcdma12 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcdma12 { bits: 0u32 }
    }
}

impl OtgHsHcdma12 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn set_dmaaddr(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcchar13 {
    bits: u32,
}

impl OtgHsHcchar13 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn mc(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcchar13 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcchar13 { bits: 0u32 }
    }
}

impl OtgHsHcchar13 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn set_mc(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcsplt13 {
    bits: u32,
}

impl OtgHsHcsplt13 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn prtaddr(&self) -> u8 {
        self.bits.get_range(0u8..7u8) as u8
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn hubaddr(&self) -> u8 {
        self.bits.get_range(7u8..14u8) as u8
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn xactpos(&self) -> u8 {
        self.bits.get_range(14u8..16u8) as u8
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn complsplt(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn spliten(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcsplt13 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcsplt13 { bits: 0u32 }
    }
}

impl OtgHsHcsplt13 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn set_prtaddr(&mut self, value: u8) {
        self.bits.set_range(0u8..7u8, value as u32);
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn set_hubaddr(&mut self, value: u8) {
        self.bits.set_range(7u8..14u8, value as u32);
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn set_xactpos(&mut self, value: u8) {
        self.bits.set_range(14u8..16u8, value as u32);
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn set_complsplt(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn set_spliten(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcint13 {
    bits: u32,
}

impl OtgHsHcint13 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcint13 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcint13 { bits: 0u32 }
    }
}

impl OtgHsHcint13 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcintmsk13 {
    bits: u32,
}

impl OtgHsHcintmsk13 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALLM response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcintmsk13 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcintmsk13 { bits: 0u32 }
    }
}

impl OtgHsHcintmsk13 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALLM response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHctsiz13 {
    bits: u32,
}

impl OtgHsHctsiz13 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsHctsiz13 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHctsiz13 { bits: 0u32 }
    }
}

impl OtgHsHctsiz13 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcdma13 {
    bits: u32,
}

impl OtgHsHcdma13 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn dmaaddr(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for OtgHsHcdma13 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcdma13 { bits: 0u32 }
    }
}

impl OtgHsHcdma13 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn set_dmaaddr(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcchar14 {
    bits: u32,
}

impl OtgHsHcchar14 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn mc(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcchar14 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcchar14 { bits: 0u32 }
    }
}

impl OtgHsHcchar14 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn set_mc(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcsplt14 {
    bits: u32,
}

impl OtgHsHcsplt14 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn prtaddr(&self) -> u8 {
        self.bits.get_range(0u8..7u8) as u8
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn hubaddr(&self) -> u8 {
        self.bits.get_range(7u8..14u8) as u8
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn xactpos(&self) -> u8 {
        self.bits.get_range(14u8..16u8) as u8
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn complsplt(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn spliten(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcsplt14 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcsplt14 { bits: 0u32 }
    }
}

impl OtgHsHcsplt14 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn set_prtaddr(&mut self, value: u8) {
        self.bits.set_range(0u8..7u8, value as u32);
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn set_hubaddr(&mut self, value: u8) {
        self.bits.set_range(7u8..14u8, value as u32);
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn set_xactpos(&mut self, value: u8) {
        self.bits.set_range(14u8..16u8, value as u32);
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn set_complsplt(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn set_spliten(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcint14 {
    bits: u32,
}

impl OtgHsHcint14 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcint14 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcint14 { bits: 0u32 }
    }
}

impl OtgHsHcint14 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcintmsk14 {
    bits: u32,
}

impl OtgHsHcintmsk14 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAKM response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACKM response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcintmsk14 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcintmsk14 { bits: 0u32 }
    }
}

impl OtgHsHcintmsk14 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAKM response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACKM response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHctsiz14 {
    bits: u32,
}

impl OtgHsHctsiz14 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsHctsiz14 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHctsiz14 { bits: 0u32 }
    }
}

impl OtgHsHctsiz14 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcdma14 {
    bits: u32,
}

impl OtgHsHcdma14 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn dmaaddr(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for OtgHsHcdma14 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcdma14 { bits: 0u32 }
    }
}

impl OtgHsHcdma14 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn set_dmaaddr(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcchar15 {
    bits: u32,
}

impl OtgHsHcchar15 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn mc(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcchar15 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcchar15 { bits: 0u32 }
    }
}

impl OtgHsHcchar15 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multi Count (MC) / Error Count (EC)" ]
    pub fn set_mc(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcsplt15 {
    bits: u32,
}

impl OtgHsHcsplt15 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn prtaddr(&self) -> u8 {
        self.bits.get_range(0u8..7u8) as u8
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn hubaddr(&self) -> u8 {
        self.bits.get_range(7u8..14u8) as u8
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn xactpos(&self) -> u8 {
        self.bits.get_range(14u8..16u8) as u8
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn complsplt(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn spliten(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsHcsplt15 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcsplt15 { bits: 0u32 }
    }
}

impl OtgHsHcsplt15 {
    # [ doc = "Bits 0:6 - Port address" ]
    pub fn set_prtaddr(&mut self, value: u8) {
        self.bits.set_range(0u8..7u8, value as u32);
    }
    # [ doc = "Bits 7:13 - Hub address" ]
    pub fn set_hubaddr(&mut self, value: u8) {
        self.bits.set_range(7u8..14u8, value as u32);
    }
    # [ doc = "Bits 14:15 - XACTPOS" ]
    pub fn set_xactpos(&mut self, value: u8) {
        self.bits.set_range(14u8..16u8, value as u32);
    }
    # [ doc = "Bit 16 - Do complete split" ]
    pub fn set_complsplt(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 31 - Split enable" ]
    pub fn set_spliten(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcint15 {
    bits: u32,
}

impl OtgHsHcint15 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcint15 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcint15 { bits: 0u32 }
    }
}

impl OtgHsHcint15 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcintmsk15 {
    bits: u32,
}

impl OtgHsHcintmsk15 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn ahberr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgHsHcintmsk15 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcintmsk15 { bits: 0u32 }
    }
}

impl OtgHsHcintmsk15 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - AHB error" ]
    pub fn set_ahberr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Response received interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHctsiz15 {
    bits: u32,
}

impl OtgHsHctsiz15 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsHctsiz15 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHctsiz15 { bits: 0u32 }
    }
}

impl OtgHsHctsiz15 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHcdma15 {
    bits: u32,
}

impl OtgHsHcdma15 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn dmaaddr(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for OtgHsHcdma15 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHcdma15 { bits: 0u32 }
    }
}

impl OtgHsHcdma15 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn set_dmaaddr(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}
