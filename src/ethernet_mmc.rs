// autogenerated

use volatile;
use bit_field::BitField;

# [ doc = "Ethernet: MAC management counters" ]
# [ repr ( C ) ]
pub struct EthernetMmc {
    # [ doc = "0x00 - Ethernet MMC control register" ]
    pub mmccr: volatile::ReadWrite<Mmccr>,
    # [ doc = "0x04 - Ethernet MMC receive interrupt register" ]
    pub mmcrir: volatile::ReadWrite<Mmcrir>,
    # [ doc = "0x08 - Ethernet MMC transmit interrupt register" ]
    pub mmctir: volatile::ReadOnly<Mmctir>,
    # [ doc = "0x0c - Ethernet MMC receive interrupt mask register" ]
    pub mmcrimr: volatile::ReadWrite<Mmcrimr>,
    # [ doc = "0x10 - Ethernet MMC transmit interrupt mask register" ]
    pub mmctimr: volatile::ReadWrite<Mmctimr>,
    _reserved0: [u8; 56usize],
    # [ doc = "0x4c - Ethernet MMC transmitted good frames after a single collision counter" ]
    pub mmctgfsccr: volatile::ReadOnly<Mmctgfsccr>,
    # [ doc = "0x50 - Ethernet MMC transmitted good frames after more than a single collision" ]
    pub mmctgfmsccr: volatile::ReadOnly<Mmctgfmsccr>,
    _reserved1: [u8; 20usize],
    # [ doc = "0x68 - Ethernet MMC transmitted good frames counter register" ]
    pub mmctgfcr: volatile::ReadOnly<Mmctgfcr>,
    _reserved2: [u8; 40usize],
    # [ doc = "0x94 - Ethernet MMC received frames with CRC error counter register" ]
    pub mmcrfcecr: volatile::ReadOnly<Mmcrfcecr>,
    # [ doc = "0x98 - Ethernet MMC received frames with alignment error counter register" ]
    pub mmcrfaecr: volatile::ReadOnly<Mmcrfaecr>,
    _reserved3: [u8; 40usize],
    # [ doc = "0xc4 - MMC received good unicast frames counter register" ]
    pub mmcrgufcr: volatile::ReadOnly<Mmcrgufcr>,
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Mmccr {
    bits: u32,
}

impl Mmccr {
    # [ doc = "Bit 0 - no description available" ]
    pub fn cr(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - no description available" ]
    pub fn csr(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - no description available" ]
    pub fn ror(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - no description available" ]
    pub fn mcf(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - no description available" ]
    pub fn mcp(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - no description available" ]
    pub fn mcfhp(&self) -> bool {
        self.bits.get_bit(5u8)
    }
}

impl Default for Mmccr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Mmccr { bits: 0u32 }
    }
}

impl Mmccr {
    # [ doc = "Bit 0 - no description available" ]
    pub fn set_cr(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - no description available" ]
    pub fn set_csr(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - no description available" ]
    pub fn set_ror(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - no description available" ]
    pub fn set_mcf(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - no description available" ]
    pub fn set_mcp(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - no description available" ]
    pub fn set_mcfhp(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Mmcrir {
    bits: u32,
}

impl Mmcrir {
    # [ doc = "Bit 5 - no description available" ]
    pub fn rfces(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - no description available" ]
    pub fn rfaes(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 17 - no description available" ]
    pub fn rgufs(&self) -> bool {
        self.bits.get_bit(17u8)
    }
}

impl Default for Mmcrir {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Mmcrir { bits: 0u32 }
    }
}

impl Mmcrir {
    # [ doc = "Bit 5 - no description available" ]
    pub fn set_rfces(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - no description available" ]
    pub fn set_rfaes(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 17 - no description available" ]
    pub fn set_rgufs(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Mmctir {
    bits: u32,
}

impl Mmctir {
    # [ doc = "Bit 14 - no description available" ]
    pub fn tgfscs(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 15 - no description available" ]
    pub fn tgfmscs(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 21 - no description available" ]
    pub fn tgfs(&self) -> bool {
        self.bits.get_bit(21u8)
    }
}

impl Default for Mmctir {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Mmctir { bits: 0u32 }
    }
}

impl Mmctir {
    # [ doc = "Bit 14 - no description available" ]
    pub fn set_tgfscs(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 15 - no description available" ]
    pub fn set_tgfmscs(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 21 - no description available" ]
    pub fn set_tgfs(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Mmcrimr {
    bits: u32,
}

impl Mmcrimr {
    # [ doc = "Bit 5 - no description available" ]
    pub fn rfcem(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - no description available" ]
    pub fn rfaem(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 17 - no description available" ]
    pub fn rgufm(&self) -> bool {
        self.bits.get_bit(17u8)
    }
}

impl Default for Mmcrimr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Mmcrimr { bits: 0u32 }
    }
}

impl Mmcrimr {
    # [ doc = "Bit 5 - no description available" ]
    pub fn set_rfcem(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - no description available" ]
    pub fn set_rfaem(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 17 - no description available" ]
    pub fn set_rgufm(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Mmctimr {
    bits: u32,
}

impl Mmctimr {
    # [ doc = "Bit 14 - no description available" ]
    pub fn tgfscm(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 15 - no description available" ]
    pub fn tgfmscm(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 16 - no description available" ]
    pub fn tgfm(&self) -> bool {
        self.bits.get_bit(16u8)
    }
}

impl Default for Mmctimr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Mmctimr { bits: 0u32 }
    }
}

impl Mmctimr {
    # [ doc = "Bit 14 - no description available" ]
    pub fn set_tgfscm(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 15 - no description available" ]
    pub fn set_tgfmscm(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 16 - no description available" ]
    pub fn set_tgfm(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Mmctgfsccr {
    bits: u32,
}

impl Mmctgfsccr {
    # [ doc = "Bits 0:31 - no description available" ]
    pub fn tgfscc(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Mmctgfsccr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Mmctgfsccr { bits: 0u32 }
    }
}

impl Mmctgfsccr {
    # [ doc = "Bits 0:31 - no description available" ]
    pub fn set_tgfscc(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Mmctgfmsccr {
    bits: u32,
}

impl Mmctgfmsccr {
    # [ doc = "Bits 0:31 - no description available" ]
    pub fn tgfmscc(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Mmctgfmsccr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Mmctgfmsccr { bits: 0u32 }
    }
}

impl Mmctgfmsccr {
    # [ doc = "Bits 0:31 - no description available" ]
    pub fn set_tgfmscc(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Mmctgfcr {
    bits: u32,
}

impl Mmctgfcr {
    # [ doc = "Bits 0:31 - HTL" ]
    pub fn tgfc(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Mmctgfcr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Mmctgfcr { bits: 0u32 }
    }
}

impl Mmctgfcr {
    # [ doc = "Bits 0:31 - HTL" ]
    pub fn set_tgfc(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Mmcrfcecr {
    bits: u32,
}

impl Mmcrfcecr {
    # [ doc = "Bits 0:31 - no description available" ]
    pub fn rfcfc(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Mmcrfcecr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Mmcrfcecr { bits: 0u32 }
    }
}

impl Mmcrfcecr {
    # [ doc = "Bits 0:31 - no description available" ]
    pub fn set_rfcfc(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Mmcrfaecr {
    bits: u32,
}

impl Mmcrfaecr {
    # [ doc = "Bits 0:31 - no description available" ]
    pub fn rfaec(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Mmcrfaecr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Mmcrfaecr { bits: 0u32 }
    }
}

impl Mmcrfaecr {
    # [ doc = "Bits 0:31 - no description available" ]
    pub fn set_rfaec(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Mmcrgufcr {
    bits: u32,
}

impl Mmcrgufcr {
    # [ doc = "Bits 0:31 - no description available" ]
    pub fn rgufc(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Mmcrgufcr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Mmcrgufcr { bits: 0u32 }
    }
}

impl Mmcrgufcr {
    # [ doc = "Bits 0:31 - no description available" ]
    pub fn set_rgufc(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}
