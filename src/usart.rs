// autogenerated

use volatile;
use bit_field::BitField;

# [ doc = "Universal synchronous asynchronous receiver transmitter" ]
# [ repr ( C ) ]
pub struct Usart {
    # [ doc = "0x00 - Control register 1" ]
    pub cr1: volatile::ReadWrite<Cr1>,
    # [ doc = "0x04 - Control register 2" ]
    pub cr2: volatile::ReadWrite<Cr2>,
    # [ doc = "0x08 - Control register 3" ]
    pub cr3: volatile::ReadWrite<Cr3>,
    # [ doc = "0x0c - Baud rate register" ]
    pub brr: volatile::ReadWrite<Brr>,
    # [ doc = "0x10 - Guard time and prescaler register" ]
    pub gtpr: volatile::ReadWrite<Gtpr>,
    # [ doc = "0x14 - Receiver timeout register" ]
    pub rtor: volatile::ReadWrite<Rtor>,
    # [ doc = "0x18 - Request register" ]
    pub rqr: volatile::WriteOnly<Rqr>,
    # [ doc = "0x1c - Interrupt & status register" ]
    pub isr: volatile::ReadOnly<Isr>,
    # [ doc = "0x20 - Interrupt flag clear register" ]
    pub icr: volatile::WriteOnly<Icr>,
    # [ doc = "0x24 - Receive data register" ]
    pub rdr: volatile::ReadOnly<Rdr>,
    # [ doc = "0x28 - Transmit data register" ]
    pub tdr: volatile::ReadWrite<Tdr>,
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Cr1 {
    bits: u32,
}

impl Cr1 {
    # [ doc = "Bit 28 - Word length" ]
    pub fn m1(&self) -> bool {
        self.bits.get_bit(28u8)
    }
    # [ doc = "Bit 27 - End of Block interrupt enable" ]
    pub fn eobie(&self) -> bool {
        self.bits.get_bit(27u8)
    }
    # [ doc = "Bit 26 - Receiver timeout interrupt enable" ]
    pub fn rtoie(&self) -> bool {
        self.bits.get_bit(26u8)
    }
    # [ doc = "Bit 25 - Driver Enable assertion time" ]
    pub fn deat4(&self) -> bool {
        self.bits.get_bit(25u8)
    }
    # [ doc = "Bit 24 - DEAT3" ]
    pub fn deat3(&self) -> bool {
        self.bits.get_bit(24u8)
    }
    # [ doc = "Bit 23 - DEAT2" ]
    pub fn deat2(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bit 22 - DEAT1" ]
    pub fn deat1(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bit 21 - DEAT0" ]
    pub fn deat0(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 20 - Driver Enable de-assertion time" ]
    pub fn dedt4(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 19 - DEDT3" ]
    pub fn dedt3(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 18 - DEDT2" ]
    pub fn dedt2(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 17 - DEDT1" ]
    pub fn dedt1(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bit 16 - DEDT0" ]
    pub fn dedt0(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 15 - Oversampling mode" ]
    pub fn over8(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 14 - Character match interrupt enable" ]
    pub fn cmie(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 13 - Mute mode enable" ]
    pub fn mme(&self) -> bool {
        self.bits.get_bit(13u8)
    }
    # [ doc = "Bit 12 - Word length" ]
    pub fn m0(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 11 - Receiver wakeup method" ]
    pub fn wake(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 10 - Parity control enable" ]
    pub fn pce(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - Parity selection" ]
    pub fn ps(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - PE interrupt enable" ]
    pub fn peie(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 7 - interrupt enable" ]
    pub fn txeie(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 6 - Transmission complete interrupt enable" ]
    pub fn tcie(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 5 - RXNE interrupt enable" ]
    pub fn rxneie(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - IDLE interrupt enable" ]
    pub fn idleie(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Transmitter enable" ]
    pub fn te(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Receiver enable" ]
    pub fn re(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - USART enable in Stop mode" ]
    pub fn uesm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - USART enable" ]
    pub fn ue(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Cr1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Cr1 { bits: 0u32 }
    }
}

impl Cr1 {
    # [ doc = "Bit 28 - Word length" ]
    pub fn set_m1(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 27 - End of Block interrupt enable" ]
    pub fn set_eobie(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 26 - Receiver timeout interrupt enable" ]
    pub fn set_rtoie(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 25 - Driver Enable assertion time" ]
    pub fn set_deat4(&mut self, value: bool) {
        self.bits.set_bit(25u8, value);
    }
    # [ doc = "Bit 24 - DEAT3" ]
    pub fn set_deat3(&mut self, value: bool) {
        self.bits.set_bit(24u8, value);
    }
    # [ doc = "Bit 23 - DEAT2" ]
    pub fn set_deat2(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 22 - DEAT1" ]
    pub fn set_deat1(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 21 - DEAT0" ]
    pub fn set_deat0(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 20 - Driver Enable de-assertion time" ]
    pub fn set_dedt4(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 19 - DEDT3" ]
    pub fn set_dedt3(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 18 - DEDT2" ]
    pub fn set_dedt2(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 17 - DEDT1" ]
    pub fn set_dedt1(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bit 16 - DEDT0" ]
    pub fn set_dedt0(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 15 - Oversampling mode" ]
    pub fn set_over8(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 14 - Character match interrupt enable" ]
    pub fn set_cmie(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 13 - Mute mode enable" ]
    pub fn set_mme(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
    # [ doc = "Bit 12 - Word length" ]
    pub fn set_m0(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 11 - Receiver wakeup method" ]
    pub fn set_wake(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 10 - Parity control enable" ]
    pub fn set_pce(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - Parity selection" ]
    pub fn set_ps(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - PE interrupt enable" ]
    pub fn set_peie(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 7 - interrupt enable" ]
    pub fn set_txeie(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 6 - Transmission complete interrupt enable" ]
    pub fn set_tcie(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 5 - RXNE interrupt enable" ]
    pub fn set_rxneie(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - IDLE interrupt enable" ]
    pub fn set_idleie(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Transmitter enable" ]
    pub fn set_te(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Receiver enable" ]
    pub fn set_re(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - USART enable in Stop mode" ]
    pub fn set_uesm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - USART enable" ]
    pub fn set_ue(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Cr2 {
    bits: u32,
}

impl Cr2 {
    # [ doc = "Bits 28:31 - Address of the USART node" ]
    pub fn add4_7(&self) -> u8 {
        self.bits.get_range(28u8..32u8) as u8
    }
    # [ doc = "Bits 24:27 - Address of the USART node" ]
    pub fn add0_3(&self) -> u8 {
        self.bits.get_range(24u8..28u8) as u8
    }
    # [ doc = "Bit 23 - Receiver timeout enable" ]
    pub fn rtoen(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bit 22 - Auto baud rate mode" ]
    pub fn abrmod1(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bit 21 - ABRMOD0" ]
    pub fn abrmod0(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 20 - Auto baud rate enable" ]
    pub fn abren(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 19 - Most significant bit first" ]
    pub fn msbfirst(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 18 - Binary data inversion" ]
    pub fn tainv(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 17 - TX pin active level inversion" ]
    pub fn txinv(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bit 16 - RX pin active level inversion" ]
    pub fn rxinv(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 15 - Swap TX/RX pins" ]
    pub fn swap(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 14 - LIN mode enable" ]
    pub fn linen(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bits 12:13 - STOP bits" ]
    pub fn stop(&self) -> u8 {
        self.bits.get_range(12u8..14u8) as u8
    }
    # [ doc = "Bit 11 - Clock enable" ]
    pub fn clken(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 10 - Clock polarity" ]
    pub fn cpol(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - Clock phase" ]
    pub fn cpha(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - Last bit clock pulse" ]
    pub fn lbcl(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 6 - LIN break detection interrupt enable" ]
    pub fn lbdie(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 5 - LIN break detection length" ]
    pub fn lbdl(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - 7-bit Address Detection/4-bit Address Detection" ]
    pub fn addm7(&self) -> bool {
        self.bits.get_bit(4u8)
    }
}

impl Default for Cr2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Cr2 { bits: 0u32 }
    }
}

impl Cr2 {
    # [ doc = "Bits 28:31 - Address of the USART node" ]
    pub fn set_add4_7(&mut self, value: u8) {
        self.bits.set_range(28u8..32u8, value as u32);
    }
    # [ doc = "Bits 24:27 - Address of the USART node" ]
    pub fn set_add0_3(&mut self, value: u8) {
        self.bits.set_range(24u8..28u8, value as u32);
    }
    # [ doc = "Bit 23 - Receiver timeout enable" ]
    pub fn set_rtoen(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 22 - Auto baud rate mode" ]
    pub fn set_abrmod1(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 21 - ABRMOD0" ]
    pub fn set_abrmod0(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 20 - Auto baud rate enable" ]
    pub fn set_abren(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 19 - Most significant bit first" ]
    pub fn set_msbfirst(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 18 - Binary data inversion" ]
    pub fn set_tainv(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 17 - TX pin active level inversion" ]
    pub fn set_txinv(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bit 16 - RX pin active level inversion" ]
    pub fn set_rxinv(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 15 - Swap TX/RX pins" ]
    pub fn set_swap(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 14 - LIN mode enable" ]
    pub fn set_linen(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bits 12:13 - STOP bits" ]
    pub fn set_stop(&mut self, value: u8) {
        self.bits.set_range(12u8..14u8, value as u32);
    }
    # [ doc = "Bit 11 - Clock enable" ]
    pub fn set_clken(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 10 - Clock polarity" ]
    pub fn set_cpol(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - Clock phase" ]
    pub fn set_cpha(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - Last bit clock pulse" ]
    pub fn set_lbcl(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 6 - LIN break detection interrupt enable" ]
    pub fn set_lbdie(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 5 - LIN break detection length" ]
    pub fn set_lbdl(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - 7-bit Address Detection/4-bit Address Detection" ]
    pub fn set_addm7(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Cr3 {
    bits: u32,
}

impl Cr3 {
    # [ doc = "Bit 22 - Wakeup from Stop mode interrupt enable" ]
    pub fn wufie(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bits 20:21 - Wakeup from Stop mode interrupt flag selection" ]
    pub fn wus(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 17:19 - Smartcard auto-retry count" ]
    pub fn scarcnt(&self) -> u8 {
        self.bits.get_range(17u8..20u8) as u8
    }
    # [ doc = "Bit 15 - Driver enable polarity selection" ]
    pub fn dep(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 14 - Driver enable mode" ]
    pub fn dem(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 13 - DMA Disable on Reception Error" ]
    pub fn ddre(&self) -> bool {
        self.bits.get_bit(13u8)
    }
    # [ doc = "Bit 12 - Overrun Disable" ]
    pub fn ovrdis(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 11 - One sample bit method enable" ]
    pub fn onebit(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 10 - CTS interrupt enable" ]
    pub fn ctsie(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - CTS enable" ]
    pub fn ctse(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - RTS enable" ]
    pub fn rtse(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 7 - DMA enable transmitter" ]
    pub fn dmat(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 6 - DMA enable receiver" ]
    pub fn dmar(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 5 - Smartcard mode enable" ]
    pub fn scen(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Smartcard NACK enable" ]
    pub fn nack(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Half-duplex selection" ]
    pub fn hdsel(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Ir low-power" ]
    pub fn irlp(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Ir mode enable" ]
    pub fn iren(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Error interrupt enable" ]
    pub fn eie(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Cr3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Cr3 { bits: 0u32 }
    }
}

impl Cr3 {
    # [ doc = "Bit 22 - Wakeup from Stop mode interrupt enable" ]
    pub fn set_wufie(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bits 20:21 - Wakeup from Stop mode interrupt flag selection" ]
    pub fn set_wus(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 17:19 - Smartcard auto-retry count" ]
    pub fn set_scarcnt(&mut self, value: u8) {
        self.bits.set_range(17u8..20u8, value as u32);
    }
    # [ doc = "Bit 15 - Driver enable polarity selection" ]
    pub fn set_dep(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 14 - Driver enable mode" ]
    pub fn set_dem(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 13 - DMA Disable on Reception Error" ]
    pub fn set_ddre(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
    # [ doc = "Bit 12 - Overrun Disable" ]
    pub fn set_ovrdis(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 11 - One sample bit method enable" ]
    pub fn set_onebit(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 10 - CTS interrupt enable" ]
    pub fn set_ctsie(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - CTS enable" ]
    pub fn set_ctse(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - RTS enable" ]
    pub fn set_rtse(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 7 - DMA enable transmitter" ]
    pub fn set_dmat(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 6 - DMA enable receiver" ]
    pub fn set_dmar(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 5 - Smartcard mode enable" ]
    pub fn set_scen(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Smartcard NACK enable" ]
    pub fn set_nack(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Half-duplex selection" ]
    pub fn set_hdsel(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Ir low-power" ]
    pub fn set_irlp(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Ir mode enable" ]
    pub fn set_iren(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Error interrupt enable" ]
    pub fn set_eie(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Brr {
    bits: u32,
}

impl Brr {
    # [ doc = "Bits 4:15 - DIV_Mantissa" ]
    pub fn div_mantissa(&self) -> u16 {
        self.bits.get_range(4u8..16u8) as u16
    }
    # [ doc = "Bits 0:3 - DIV_Fraction" ]
    pub fn div_fraction(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
}

impl Default for Brr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Brr { bits: 0u32 }
    }
}

impl Brr {
    # [ doc = "Bits 4:15 - DIV_Mantissa" ]
    pub fn set_div_mantissa(&mut self, value: u16) {
        self.bits.set_range(4u8..16u8, value as u32);
    }
    # [ doc = "Bits 0:3 - DIV_Fraction" ]
    pub fn set_div_fraction(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Gtpr {
    bits: u32,
}

impl Gtpr {
    # [ doc = "Bits 8:15 - Guard time value" ]
    pub fn gt(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bits 0:7 - Prescaler value" ]
    pub fn psc(&self) -> u8 {
        self.bits.get_range(0u8..8u8) as u8
    }
}

impl Default for Gtpr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Gtpr { bits: 0u32 }
    }
}

impl Gtpr {
    # [ doc = "Bits 8:15 - Guard time value" ]
    pub fn set_gt(&mut self, value: u8) {
        self.bits.set_range(8u8..16u8, value as u32);
    }
    # [ doc = "Bits 0:7 - Prescaler value" ]
    pub fn set_psc(&mut self, value: u8) {
        self.bits.set_range(0u8..8u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Rtor {
    bits: u32,
}

impl Rtor {
    # [ doc = "Bits 24:31 - Block Length" ]
    pub fn blen(&self) -> u8 {
        self.bits.get_range(24u8..32u8) as u8
    }
    # [ doc = "Bits 0:23 - Receiver timeout value" ]
    pub fn rto(&self) -> u32 {
        self.bits.get_range(0u8..24u8) as u32
    }
}

impl Default for Rtor {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Rtor { bits: 0u32 }
    }
}

impl Rtor {
    # [ doc = "Bits 24:31 - Block Length" ]
    pub fn set_blen(&mut self, value: u8) {
        self.bits.set_range(24u8..32u8, value as u32);
    }
    # [ doc = "Bits 0:23 - Receiver timeout value" ]
    pub fn set_rto(&mut self, value: u32) {
        self.bits.set_range(0u8..24u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Rqr {
    bits: u32,
}

impl Rqr {
    # [ doc = "Bit 4 - Transmit data flush request" ]
    pub fn txfrq(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Receive data flush request" ]
    pub fn rxfrq(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Mute mode request" ]
    pub fn mmrq(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Send break request" ]
    pub fn sbkrq(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Auto baud rate request" ]
    pub fn abrrq(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Rqr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Rqr { bits: 0u32 }
    }
}

impl Rqr {
    # [ doc = "Bit 4 - Transmit data flush request" ]
    pub fn set_txfrq(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Receive data flush request" ]
    pub fn set_rxfrq(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Mute mode request" ]
    pub fn set_mmrq(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Send break request" ]
    pub fn set_sbkrq(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Auto baud rate request" ]
    pub fn set_abrrq(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Isr {
    bits: u32,
}

impl Isr {
    # [ doc = "Bit 22 - REACK" ]
    pub fn reack(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bit 21 - TEACK" ]
    pub fn teack(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 20 - WUF" ]
    pub fn wuf(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 19 - RWU" ]
    pub fn rwu(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 18 - SBKF" ]
    pub fn sbkf(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 17 - CMF" ]
    pub fn cmf(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bit 16 - BUSY" ]
    pub fn busy(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 15 - ABRF" ]
    pub fn abrf(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 14 - ABRE" ]
    pub fn abre(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 12 - EOBF" ]
    pub fn eobf(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 11 - RTOF" ]
    pub fn rtof(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 10 - CTS" ]
    pub fn cts(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - CTSIF" ]
    pub fn ctsif(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - LBDF" ]
    pub fn lbdf(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 7 - TXE" ]
    pub fn txe(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 6 - TC" ]
    pub fn tc(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 5 - RXNE" ]
    pub fn rxne(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - IDLE" ]
    pub fn idle(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - ORE" ]
    pub fn ore(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - NF" ]
    pub fn nf(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - FE" ]
    pub fn fe(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - PE" ]
    pub fn pe(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Isr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Isr { bits: 192u32 }
    }
}

impl Isr {
    # [ doc = "Bit 22 - REACK" ]
    pub fn set_reack(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 21 - TEACK" ]
    pub fn set_teack(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 20 - WUF" ]
    pub fn set_wuf(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 19 - RWU" ]
    pub fn set_rwu(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 18 - SBKF" ]
    pub fn set_sbkf(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 17 - CMF" ]
    pub fn set_cmf(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bit 16 - BUSY" ]
    pub fn set_busy(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 15 - ABRF" ]
    pub fn set_abrf(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 14 - ABRE" ]
    pub fn set_abre(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 12 - EOBF" ]
    pub fn set_eobf(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 11 - RTOF" ]
    pub fn set_rtof(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 10 - CTS" ]
    pub fn set_cts(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - CTSIF" ]
    pub fn set_ctsif(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - LBDF" ]
    pub fn set_lbdf(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 7 - TXE" ]
    pub fn set_txe(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 6 - TC" ]
    pub fn set_tc(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 5 - RXNE" ]
    pub fn set_rxne(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - IDLE" ]
    pub fn set_idle(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - ORE" ]
    pub fn set_ore(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - NF" ]
    pub fn set_nf(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - FE" ]
    pub fn set_fe(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - PE" ]
    pub fn set_pe(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Icr {
    bits: u32,
}

impl Icr {
    # [ doc = "Bit 20 - Wakeup from Stop mode clear flag" ]
    pub fn wucf(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 17 - Character match clear flag" ]
    pub fn cmcf(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bit 12 - End of block clear flag" ]
    pub fn eobcf(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 11 - Receiver timeout clear flag" ]
    pub fn rtocf(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 9 - CTS clear flag" ]
    pub fn ctscf(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - LIN break detection clear flag" ]
    pub fn lbdcf(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 6 - Transmission complete clear flag" ]
    pub fn tccf(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 4 - Idle line detected clear flag" ]
    pub fn idlecf(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Overrun error clear flag" ]
    pub fn orecf(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Noise detected clear flag" ]
    pub fn ncf(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Framing error clear flag" ]
    pub fn fecf(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Parity error clear flag" ]
    pub fn pecf(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Icr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Icr { bits: 0u32 }
    }
}

impl Icr {
    # [ doc = "Bit 20 - Wakeup from Stop mode clear flag" ]
    pub fn set_wucf(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 17 - Character match clear flag" ]
    pub fn set_cmcf(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bit 12 - End of block clear flag" ]
    pub fn set_eobcf(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 11 - Receiver timeout clear flag" ]
    pub fn set_rtocf(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 9 - CTS clear flag" ]
    pub fn set_ctscf(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - LIN break detection clear flag" ]
    pub fn set_lbdcf(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 6 - Transmission complete clear flag" ]
    pub fn set_tccf(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 4 - Idle line detected clear flag" ]
    pub fn set_idlecf(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Overrun error clear flag" ]
    pub fn set_orecf(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Noise detected clear flag" ]
    pub fn set_ncf(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Framing error clear flag" ]
    pub fn set_fecf(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Parity error clear flag" ]
    pub fn set_pecf(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Rdr {
    bits: u32,
}

impl Rdr {
    # [ doc = "Bits 0:8 - Receive data value" ]
    pub fn rdr(&self) -> u16 {
        self.bits.get_range(0u8..9u8) as u16
    }
}

impl Default for Rdr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Rdr { bits: 0u32 }
    }
}

impl Rdr {
    # [ doc = "Bits 0:8 - Receive data value" ]
    pub fn set_rdr(&mut self, value: u16) {
        self.bits.set_range(0u8..9u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Tdr {
    bits: u32,
}

impl Tdr {
    # [ doc = "Bits 0:8 - Transmit data value" ]
    pub fn tdr(&self) -> u16 {
        self.bits.get_range(0u8..9u8) as u16
    }
}

impl Default for Tdr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Tdr { bits: 0u32 }
    }
}

impl Tdr {
    # [ doc = "Bits 0:8 - Transmit data value" ]
    pub fn set_tdr(&mut self, value: u16) {
        self.bits.set_range(0u8..9u8, value as u32);
    }
}
