// autogenerated

use volatile;
use bit_field::BitField;

# [ doc = "USB on the go full speed" ]
# [ repr ( C ) ]
pub struct OtgFsGlobal {
    # [ doc = "0x00 - OTG_FS control and status register (OTG_FS_GOTGCTL)" ]
    pub otg_fs_gotgctl: volatile::ReadWrite<OtgFsGotgctl>,
    # [ doc = "0x04 - OTG_FS interrupt register (OTG_FS_GOTGINT)" ]
    pub otg_fs_gotgint: volatile::ReadWrite<OtgFsGotgint>,
    # [ doc = "0x08 - OTG_FS AHB configuration register (OTG_FS_GAHBCFG)" ]
    pub otg_fs_gahbcfg: volatile::ReadWrite<OtgFsGahbcfg>,
    # [ doc = "0x0c - OTG_FS USB configuration register (OTG_FS_GUSBCFG)" ]
    pub otg_fs_gusbcfg: volatile::ReadWrite<OtgFsGusbcfg>,
    # [ doc = "0x10 - OTG_FS reset register (OTG_FS_GRSTCTL)" ]
    pub otg_fs_grstctl: volatile::ReadWrite<OtgFsGrstctl>,
    # [ doc = "0x14 - OTG_FS core interrupt register (OTG_FS_GINTSTS)" ]
    pub otg_fs_gintsts: volatile::ReadWrite<OtgFsGintsts>,
    # [ doc = "0x18 - OTG_FS interrupt mask register (OTG_FS_GINTMSK)" ]
    pub otg_fs_gintmsk: volatile::ReadWrite<OtgFsGintmsk>,
    # [ doc = "0x1c - OTG_FS Receive status debug read(Device mode)" ]
    pub otg_fs_grxstsr_device: volatile::ReadOnly<OtgFsGrxstsrDevice>,
    # [ doc = "0x20 - OTG status read and pop register (Device mode)" ]
    pub otg_fs_grxstsp_device: volatile::ReadOnly<OtgFsGrxstspDevice>,
    # [ doc = "0x24 - OTG_FS Receive FIFO size register (OTG_FS_GRXFSIZ)" ]
    pub otg_fs_grxfsiz: volatile::ReadWrite<OtgFsGrxfsiz>,
    # [ doc = "0x28 - OTG_FS Endpoint 0 Transmit FIFO size" ]
    pub otg_fs_dieptxf0_device: volatile::ReadWrite<OtgFsDieptxf0Device>,
    # [ doc = "0x2c - OTG_FS non-periodic transmit FIFO/queue status register (OTG_FS_GNPTXSTS)" ]
    pub otg_fs_hnptxsts: volatile::ReadOnly<OtgFsHnptxsts>,
    # [ doc = "0x30 - OTG I2C access register" ]
    pub otg_fs_gi2cctl: volatile::ReadWrite<OtgFsGi2cctl>,
    _reserved0: [u8; 4usize],
    # [ doc = "0x38 - OTG_FS general core configuration register (OTG_FS_GCCFG)" ]
    pub otg_fs_gccfg: volatile::ReadWrite<OtgFsGccfg>,
    # [ doc = "0x3c - core ID register" ]
    pub otg_fs_cid: volatile::ReadWrite<OtgFsCid>,
    _reserved1: [u8; 20usize],
    # [ doc = "0x54 - OTG core LPM configuration register" ]
    pub otg_fs_glpmcfg: volatile::ReadWrite<OtgFsGlpmcfg>,
    # [ doc = "0x58 - OTG power down register" ]
    pub otg_fs_gpwrdn: volatile::ReadWrite<OtgFsGpwrdn>,
    _reserved2: [u8; 4usize],
    # [ doc = "0x60 - OTG ADP timer, control and status register" ]
    pub otg_fs_gadpctl: volatile::ReadWrite<OtgFsGadpctl>,
    _reserved3: [u8; 156usize],
    # [ doc = "0x100 - OTG_FS Host periodic transmit FIFO size register (OTG_FS_HPTXFSIZ)" ]
    pub otg_fs_hptxfsiz: volatile::ReadWrite<OtgFsHptxfsiz>,
    # [ doc = "0x104 - OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF1)" ]
    pub otg_fs_dieptxf1: volatile::ReadWrite<OtgFsDieptxf1>,
    # [ doc = "0x108 - OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF2)" ]
    pub otg_fs_dieptxf2: volatile::ReadWrite<OtgFsDieptxf2>,
    # [ doc = "0x10c - OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF3)" ]
    pub otg_fs_dieptxf3: volatile::ReadWrite<OtgFsDieptxf3>,
    # [ doc = "0x110 - OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF4)" ]
    pub otg_fs_dieptxf4: volatile::ReadWrite<OtgFsDieptxf4>,
    # [ doc = "0x114 - OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF5)" ]
    pub otg_fs_dieptxf5: volatile::ReadWrite<OtgFsDieptxf5>,
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsGotgctl {
    bits: u32,
}

impl OtgFsGotgctl {
    # [ doc = "Bit 0 - Session request success" ]
    pub fn srqscs(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Session request" ]
    pub fn srq(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 8 - Host negotiation success" ]
    pub fn hngscs(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - HNP request" ]
    pub fn hnprq(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Host set HNP enable" ]
    pub fn hshnpen(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 11 - Device HNP enabled" ]
    pub fn dhnpen(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 16 - Connector ID status" ]
    pub fn cidsts(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - Long/short debounce time" ]
    pub fn dbct(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bit 18 - A-session valid" ]
    pub fn asvld(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 19 - B-session valid" ]
    pub fn bsvld(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 2 - VBUS valid override enable" ]
    pub fn vbvaloen(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - VBUS valid override value" ]
    pub fn vbvaloval(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - A-peripheral session valid override enable" ]
    pub fn avaloen(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - A-peripheral session valid override value" ]
    pub fn avaloval(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - B-peripheral session valid override enable" ]
    pub fn bvaloen(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - B-peripheral session valid override value" ]
    pub fn bvaloval(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 12 - Embedded host enable" ]
    pub fn ehen(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 20 - OTG version" ]
    pub fn otgver(&self) -> bool {
        self.bits.get_bit(20u8)
    }
}

impl Default for OtgFsGotgctl {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsGotgctl { bits: 2048u32 }
    }
}

impl OtgFsGotgctl {
    # [ doc = "Bit 1 - Session request" ]
    pub fn set_srq(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 9 - HNP request" ]
    pub fn set_hnprq(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Host set HNP enable" ]
    pub fn set_hshnpen(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 11 - Device HNP enabled" ]
    pub fn set_dhnpen(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 2 - VBUS valid override enable" ]
    pub fn set_vbvaloen(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - VBUS valid override value" ]
    pub fn set_vbvaloval(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - A-peripheral session valid override enable" ]
    pub fn set_avaloen(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - A-peripheral session valid override value" ]
    pub fn set_avaloval(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - B-peripheral session valid override enable" ]
    pub fn set_bvaloen(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - B-peripheral session valid override value" ]
    pub fn set_bvaloval(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 12 - Embedded host enable" ]
    pub fn set_ehen(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 20 - OTG version" ]
    pub fn set_otgver(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsGotgint {
    bits: u32,
}

impl OtgFsGotgint {
    # [ doc = "Bit 2 - Session end detected" ]
    pub fn sedet(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 8 - Session request success status change" ]
    pub fn srsschg(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Host negotiation success status change" ]
    pub fn hnsschg(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 17 - Host negotiation detected" ]
    pub fn hngdet(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bit 18 - A-device timeout change" ]
    pub fn adtochg(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 19 - Debounce done" ]
    pub fn dbcdne(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 20 - ID input pin changed" ]
    pub fn idchng(&self) -> bool {
        self.bits.get_bit(20u8)
    }
}

impl Default for OtgFsGotgint {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsGotgint { bits: 0u32 }
    }
}

impl OtgFsGotgint {
    # [ doc = "Bit 2 - Session end detected" ]
    pub fn set_sedet(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 8 - Session request success status change" ]
    pub fn set_srsschg(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Host negotiation success status change" ]
    pub fn set_hnsschg(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 17 - Host negotiation detected" ]
    pub fn set_hngdet(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bit 18 - A-device timeout change" ]
    pub fn set_adtochg(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 19 - Debounce done" ]
    pub fn set_dbcdne(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 20 - ID input pin changed" ]
    pub fn set_idchng(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsGahbcfg {
    bits: u32,
}

impl OtgFsGahbcfg {
    # [ doc = "Bit 0 - Global interrupt mask" ]
    pub fn gint(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 7 - TxFIFO empty level" ]
    pub fn txfelvl(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Periodic TxFIFO empty level" ]
    pub fn ptxfelvl(&self) -> bool {
        self.bits.get_bit(8u8)
    }
}

impl Default for OtgFsGahbcfg {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsGahbcfg { bits: 0u32 }
    }
}

impl OtgFsGahbcfg {
    # [ doc = "Bit 0 - Global interrupt mask" ]
    pub fn set_gint(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 7 - TxFIFO empty level" ]
    pub fn set_txfelvl(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Periodic TxFIFO empty level" ]
    pub fn set_ptxfelvl(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsGusbcfg {
    bits: u32,
}

impl OtgFsGusbcfg {
    # [ doc = "Bits 0:2 - FS timeout calibration" ]
    pub fn tocal(&self) -> u8 {
        self.bits.get_range(0u8..3u8) as u8
    }
    # [ doc = "Bit 8 - SRP-capable" ]
    pub fn srpcap(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - HNP-capable" ]
    pub fn hnpcap(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bits 10:13 - USB turnaround time" ]
    pub fn trdt(&self) -> u8 {
        self.bits.get_range(10u8..14u8) as u8
    }
    # [ doc = "Bit 29 - Force host mode" ]
    pub fn fhmod(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Force device mode" ]
    pub fn fdmod(&self) -> bool {
        self.bits.get_bit(30u8)
    }
}

impl Default for OtgFsGusbcfg {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsGusbcfg { bits: 2560u32 }
    }
}

impl OtgFsGusbcfg {
    # [ doc = "Bits 0:2 - FS timeout calibration" ]
    pub fn set_tocal(&mut self, value: u8) {
        self.bits.set_range(0u8..3u8, value as u32);
    }
    # [ doc = "Bit 6 - Full Speed serial transceiver select" ]
    pub fn set_physel(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 8 - SRP-capable" ]
    pub fn set_srpcap(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - HNP-capable" ]
    pub fn set_hnpcap(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bits 10:13 - USB turnaround time" ]
    pub fn set_trdt(&mut self, value: u8) {
        self.bits.set_range(10u8..14u8, value as u32);
    }
    # [ doc = "Bit 29 - Force host mode" ]
    pub fn set_fhmod(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Force device mode" ]
    pub fn set_fdmod(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsGrstctl {
    bits: u32,
}

impl OtgFsGrstctl {
    # [ doc = "Bit 0 - Core soft reset" ]
    pub fn csrst(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - HCLK soft reset" ]
    pub fn hsrst(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - Host frame counter reset" ]
    pub fn fcrst(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 4 - RxFIFO flush" ]
    pub fn rxfflsh(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - TxFIFO flush" ]
    pub fn txfflsh(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bits 6:10 - TxFIFO number" ]
    pub fn txfnum(&self) -> u8 {
        self.bits.get_range(6u8..11u8) as u8
    }
    # [ doc = "Bit 31 - AHB master idle" ]
    pub fn ahbidl(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgFsGrstctl {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsGrstctl { bits: 536870912u32 }
    }
}

impl OtgFsGrstctl {
    # [ doc = "Bit 0 - Core soft reset" ]
    pub fn set_csrst(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - HCLK soft reset" ]
    pub fn set_hsrst(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - Host frame counter reset" ]
    pub fn set_fcrst(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 4 - RxFIFO flush" ]
    pub fn set_rxfflsh(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - TxFIFO flush" ]
    pub fn set_txfflsh(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bits 6:10 - TxFIFO number" ]
    pub fn set_txfnum(&mut self, value: u8) {
        self.bits.set_range(6u8..11u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsGintsts {
    bits: u32,
}

impl OtgFsGintsts {
    # [ doc = "Bit 0 - Current mode of operation" ]
    pub fn cmod(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Mode mismatch interrupt" ]
    pub fn mmis(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - OTG interrupt" ]
    pub fn otgint(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - Start of frame" ]
    pub fn sof(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - RxFIFO non-empty" ]
    pub fn rxflvl(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - Non-periodic TxFIFO empty" ]
    pub fn nptxfe(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Global IN non-periodic NAK effective" ]
    pub fn ginakeff(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Global OUT NAK effective" ]
    pub fn goutnakeff(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 10 - Early suspend" ]
    pub fn esusp(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 11 - USB suspend" ]
    pub fn usbsusp(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 12 - USB reset" ]
    pub fn usbrst(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 13 - Enumeration done" ]
    pub fn enumdne(&self) -> bool {
        self.bits.get_bit(13u8)
    }
    # [ doc = "Bit 14 - Isochronous OUT packet dropped interrupt" ]
    pub fn isoodrp(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 15 - End of periodic frame interrupt" ]
    pub fn eopf(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 18 - IN endpoint interrupt" ]
    pub fn iepint(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 19 - OUT endpoint interrupt" ]
    pub fn oepint(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 20 - Incomplete isochronous IN transfer" ]
    pub fn iisoixfr(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 21 - Incomplete periodic transfer(Host mode)/Incomplete isochronous OUT transfer(Device mode)" ]
    pub fn ipxfr_incompisoout(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 24 - Host port interrupt" ]
    pub fn hprtint(&self) -> bool {
        self.bits.get_bit(24u8)
    }
    # [ doc = "Bit 25 - Host channels interrupt" ]
    pub fn hcint(&self) -> bool {
        self.bits.get_bit(25u8)
    }
    # [ doc = "Bit 26 - Periodic TxFIFO empty" ]
    pub fn ptxfe(&self) -> bool {
        self.bits.get_bit(26u8)
    }
    # [ doc = "Bit 28 - Connector ID status change" ]
    pub fn cidschg(&self) -> bool {
        self.bits.get_bit(28u8)
    }
    # [ doc = "Bit 29 - Disconnect detected interrupt" ]
    pub fn discint(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Session request/new session detected interrupt" ]
    pub fn srqint(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Resume/remote wakeup detected interrupt" ]
    pub fn wkupint(&self) -> bool {
        self.bits.get_bit(31u8)
    }
    # [ doc = "Bit 23 - Reset detected interrupt" ]
    pub fn rstdet(&self) -> bool {
        self.bits.get_bit(23u8)
    }
}

impl Default for OtgFsGintsts {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsGintsts { bits: 67108896u32 }
    }
}

impl OtgFsGintsts {
    # [ doc = "Bit 1 - Mode mismatch interrupt" ]
    pub fn set_mmis(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - Start of frame" ]
    pub fn set_sof(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 10 - Early suspend" ]
    pub fn set_esusp(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 11 - USB suspend" ]
    pub fn set_usbsusp(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 12 - USB reset" ]
    pub fn set_usbrst(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 13 - Enumeration done" ]
    pub fn set_enumdne(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
    # [ doc = "Bit 14 - Isochronous OUT packet dropped interrupt" ]
    pub fn set_isoodrp(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 15 - End of periodic frame interrupt" ]
    pub fn set_eopf(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 20 - Incomplete isochronous IN transfer" ]
    pub fn set_iisoixfr(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 21 - Incomplete periodic transfer(Host mode)/Incomplete isochronous OUT transfer(Device mode)" ]
    pub fn set_ipxfr_incompisoout(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 28 - Connector ID status change" ]
    pub fn set_cidschg(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 29 - Disconnect detected interrupt" ]
    pub fn set_discint(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Session request/new session detected interrupt" ]
    pub fn set_srqint(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Resume/remote wakeup detected interrupt" ]
    pub fn set_wkupint(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
    # [ doc = "Bit 23 - Reset detected interrupt" ]
    pub fn set_rstdet(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsGintmsk {
    bits: u32,
}

impl OtgFsGintmsk {
    # [ doc = "Bit 1 - Mode mismatch interrupt mask" ]
    pub fn mmism(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - OTG interrupt mask" ]
    pub fn otgint(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - Start of frame mask" ]
    pub fn sofm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - Receive FIFO non-empty mask" ]
    pub fn rxflvlm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - Non-periodic TxFIFO empty mask" ]
    pub fn nptxfem(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Global non-periodic IN NAK effective mask" ]
    pub fn ginakeffm(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Global OUT NAK effective mask" ]
    pub fn gonakeffm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 10 - Early suspend mask" ]
    pub fn esuspm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 11 - USB suspend mask" ]
    pub fn usbsuspm(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 12 - USB reset mask" ]
    pub fn usbrst(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 13 - Enumeration done mask" ]
    pub fn enumdnem(&self) -> bool {
        self.bits.get_bit(13u8)
    }
    # [ doc = "Bit 14 - Isochronous OUT packet dropped interrupt mask" ]
    pub fn isoodrpm(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 15 - End of periodic frame interrupt mask" ]
    pub fn eopfm(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 18 - IN endpoints interrupt mask" ]
    pub fn iepint(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 19 - OUT endpoints interrupt mask" ]
    pub fn oepint(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 20 - Incomplete isochronous IN transfer mask" ]
    pub fn iisoixfrm(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 21 - Incomplete periodic transfer mask(Host mode)/Incomplete isochronous OUT transfer mask(Device mode)" ]
    pub fn ipxfrm_iisooxfrm(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 24 - Host port interrupt mask" ]
    pub fn prtim(&self) -> bool {
        self.bits.get_bit(24u8)
    }
    # [ doc = "Bit 25 - Host channels interrupt mask" ]
    pub fn hcim(&self) -> bool {
        self.bits.get_bit(25u8)
    }
    # [ doc = "Bit 26 - Periodic TxFIFO empty mask" ]
    pub fn ptxfem(&self) -> bool {
        self.bits.get_bit(26u8)
    }
    # [ doc = "Bit 28 - Connector ID status change mask" ]
    pub fn cidschgm(&self) -> bool {
        self.bits.get_bit(28u8)
    }
    # [ doc = "Bit 29 - Disconnect detected interrupt mask" ]
    pub fn discint(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Session request/new session detected interrupt mask" ]
    pub fn srqim(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Resume/remote wakeup detected interrupt mask" ]
    pub fn wuim(&self) -> bool {
        self.bits.get_bit(31u8)
    }
    # [ doc = "Bit 23 - Reset detected interrupt mask" ]
    pub fn rstdetm(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bit 27 - LPM interrupt mask" ]
    pub fn lpmin(&self) -> bool {
        self.bits.get_bit(27u8)
    }
}

impl Default for OtgFsGintmsk {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsGintmsk { bits: 0u32 }
    }
}

impl OtgFsGintmsk {
    # [ doc = "Bit 1 - Mode mismatch interrupt mask" ]
    pub fn set_mmism(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - OTG interrupt mask" ]
    pub fn set_otgint(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - Start of frame mask" ]
    pub fn set_sofm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - Receive FIFO non-empty mask" ]
    pub fn set_rxflvlm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - Non-periodic TxFIFO empty mask" ]
    pub fn set_nptxfem(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Global non-periodic IN NAK effective mask" ]
    pub fn set_ginakeffm(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Global OUT NAK effective mask" ]
    pub fn set_gonakeffm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 10 - Early suspend mask" ]
    pub fn set_esuspm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 11 - USB suspend mask" ]
    pub fn set_usbsuspm(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 12 - USB reset mask" ]
    pub fn set_usbrst(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 13 - Enumeration done mask" ]
    pub fn set_enumdnem(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
    # [ doc = "Bit 14 - Isochronous OUT packet dropped interrupt mask" ]
    pub fn set_isoodrpm(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 15 - End of periodic frame interrupt mask" ]
    pub fn set_eopfm(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 18 - IN endpoints interrupt mask" ]
    pub fn set_iepint(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 19 - OUT endpoints interrupt mask" ]
    pub fn set_oepint(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 20 - Incomplete isochronous IN transfer mask" ]
    pub fn set_iisoixfrm(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 21 - Incomplete periodic transfer mask(Host mode)/Incomplete isochronous OUT transfer mask(Device mode)" ]
    pub fn set_ipxfrm_iisooxfrm(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 25 - Host channels interrupt mask" ]
    pub fn set_hcim(&mut self, value: bool) {
        self.bits.set_bit(25u8, value);
    }
    # [ doc = "Bit 26 - Periodic TxFIFO empty mask" ]
    pub fn set_ptxfem(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 28 - Connector ID status change mask" ]
    pub fn set_cidschgm(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 29 - Disconnect detected interrupt mask" ]
    pub fn set_discint(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Session request/new session detected interrupt mask" ]
    pub fn set_srqim(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Resume/remote wakeup detected interrupt mask" ]
    pub fn set_wuim(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
    # [ doc = "Bit 23 - Reset detected interrupt mask" ]
    pub fn set_rstdetm(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 27 - LPM interrupt mask" ]
    pub fn set_lpmin(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsGrxstsrDevice {
    bits: u32,
}

impl OtgFsGrxstsrDevice {
    # [ doc = "Bits 0:3 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
    # [ doc = "Bits 4:14 - Byte count" ]
    pub fn bcnt(&self) -> u16 {
        self.bits.get_range(4u8..15u8) as u16
    }
    # [ doc = "Bits 15:16 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(15u8..17u8) as u8
    }
    # [ doc = "Bits 17:20 - Packet status" ]
    pub fn pktsts(&self) -> u8 {
        self.bits.get_range(17u8..21u8) as u8
    }
    # [ doc = "Bits 21:24 - Frame number" ]
    pub fn frmnum(&self) -> u8 {
        self.bits.get_range(21u8..25u8) as u8
    }
}

impl Default for OtgFsGrxstsrDevice {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsGrxstsrDevice { bits: 0u32 }
    }
}

impl OtgFsGrxstsrDevice {
    # [ doc = "Bits 0:3 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
    # [ doc = "Bits 4:14 - Byte count" ]
    pub fn set_bcnt(&mut self, value: u16) {
        self.bits.set_range(4u8..15u8, value as u32);
    }
    # [ doc = "Bits 15:16 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(15u8..17u8, value as u32);
    }
    # [ doc = "Bits 17:20 - Packet status" ]
    pub fn set_pktsts(&mut self, value: u8) {
        self.bits.set_range(17u8..21u8, value as u32);
    }
    # [ doc = "Bits 21:24 - Frame number" ]
    pub fn set_frmnum(&mut self, value: u8) {
        self.bits.set_range(21u8..25u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsGrxstsrHost {
    bits: u32,
}

impl OtgFsGrxstsrHost {
    # [ doc = "Bits 0:3 - Endpoint number" ]
    pub fn chnum(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
    # [ doc = "Bits 4:14 - Byte count" ]
    pub fn bcnt(&self) -> u16 {
        self.bits.get_range(4u8..15u8) as u16
    }
    # [ doc = "Bits 15:16 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(15u8..17u8) as u8
    }
    # [ doc = "Bits 17:20 - Packet status" ]
    pub fn pktsts(&self) -> u8 {
        self.bits.get_range(17u8..21u8) as u8
    }
}

impl Default for OtgFsGrxstsrHost {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsGrxstsrHost { bits: 0u32 }
    }
}

impl OtgFsGrxstsrHost {
    # [ doc = "Bits 0:3 - Endpoint number" ]
    pub fn set_chnum(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
    # [ doc = "Bits 4:14 - Byte count" ]
    pub fn set_bcnt(&mut self, value: u16) {
        self.bits.set_range(4u8..15u8, value as u32);
    }
    # [ doc = "Bits 15:16 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(15u8..17u8, value as u32);
    }
    # [ doc = "Bits 17:20 - Packet status" ]
    pub fn set_pktsts(&mut self, value: u8) {
        self.bits.set_range(17u8..21u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsGrxstspDevice {
    bits: u32,
}

impl OtgFsGrxstspDevice {
    # [ doc = "Bits 0:3 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
    # [ doc = "Bits 4:14 - Byte count" ]
    pub fn bcnt(&self) -> u16 {
        self.bits.get_range(4u8..15u8) as u16
    }
    # [ doc = "Bits 15:16 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(15u8..17u8) as u8
    }
    # [ doc = "Bits 17:20 - Packet status" ]
    pub fn pktsts(&self) -> u8 {
        self.bits.get_range(17u8..21u8) as u8
    }
    # [ doc = "Bits 21:24 - Frame number" ]
    pub fn frmnum(&self) -> u8 {
        self.bits.get_range(21u8..25u8) as u8
    }
}

impl Default for OtgFsGrxstspDevice {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsGrxstspDevice { bits: 33555456u32 }
    }
}

impl OtgFsGrxstspDevice {
    # [ doc = "Bits 0:3 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
    # [ doc = "Bits 4:14 - Byte count" ]
    pub fn set_bcnt(&mut self, value: u16) {
        self.bits.set_range(4u8..15u8, value as u32);
    }
    # [ doc = "Bits 15:16 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(15u8..17u8, value as u32);
    }
    # [ doc = "Bits 17:20 - Packet status" ]
    pub fn set_pktsts(&mut self, value: u8) {
        self.bits.set_range(17u8..21u8, value as u32);
    }
    # [ doc = "Bits 21:24 - Frame number" ]
    pub fn set_frmnum(&mut self, value: u8) {
        self.bits.set_range(21u8..25u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsGrxstspHost {
    bits: u32,
}

impl OtgFsGrxstspHost {
    # [ doc = "Bits 0:3 - Channel number" ]
    pub fn chnum(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
    # [ doc = "Bits 4:14 - Byte count" ]
    pub fn bcnt(&self) -> u16 {
        self.bits.get_range(4u8..15u8) as u16
    }
    # [ doc = "Bits 15:16 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(15u8..17u8) as u8
    }
    # [ doc = "Bits 17:20 - Packet status" ]
    pub fn pktsts(&self) -> u8 {
        self.bits.get_range(17u8..21u8) as u8
    }
}

impl Default for OtgFsGrxstspHost {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsGrxstspHost { bits: 33555456u32 }
    }
}

impl OtgFsGrxstspHost {
    # [ doc = "Bits 0:3 - Channel number" ]
    pub fn set_chnum(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
    # [ doc = "Bits 4:14 - Byte count" ]
    pub fn set_bcnt(&mut self, value: u16) {
        self.bits.set_range(4u8..15u8, value as u32);
    }
    # [ doc = "Bits 15:16 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(15u8..17u8, value as u32);
    }
    # [ doc = "Bits 17:20 - Packet status" ]
    pub fn set_pktsts(&mut self, value: u8) {
        self.bits.set_range(17u8..21u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsGrxfsiz {
    bits: u32,
}

impl OtgFsGrxfsiz {
    # [ doc = "Bits 0:15 - RxFIFO depth" ]
    pub fn rxfd(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for OtgFsGrxfsiz {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsGrxfsiz { bits: 512u32 }
    }
}

impl OtgFsGrxfsiz {
    # [ doc = "Bits 0:15 - RxFIFO depth" ]
    pub fn set_rxfd(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsDieptxf0Device {
    bits: u32,
}

impl OtgFsDieptxf0Device {
    # [ doc = "Bits 0:15 - Endpoint 0 transmit RAM start address" ]
    pub fn tx0fsa(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:31 - Endpoint 0 TxFIFO depth" ]
    pub fn tx0fd(&self) -> u16 {
        self.bits.get_range(16u8..32u8) as u16
    }
}

impl Default for OtgFsDieptxf0Device {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsDieptxf0Device { bits: 512u32 }
    }
}

impl OtgFsDieptxf0Device {
    # [ doc = "Bits 0:15 - Endpoint 0 transmit RAM start address" ]
    pub fn set_tx0fsa(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:31 - Endpoint 0 TxFIFO depth" ]
    pub fn set_tx0fd(&mut self, value: u16) {
        self.bits.set_range(16u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHnptxfsizHost {
    bits: u32,
}

impl OtgFsHnptxfsizHost {
    # [ doc = "Bits 0:15 - Non-periodic transmit RAM start address" ]
    pub fn nptxfsa(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:31 - Non-periodic TxFIFO depth" ]
    pub fn nptxfd(&self) -> u16 {
        self.bits.get_range(16u8..32u8) as u16
    }
}

impl Default for OtgFsHnptxfsizHost {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHnptxfsizHost { bits: 512u32 }
    }
}

impl OtgFsHnptxfsizHost {
    # [ doc = "Bits 0:15 - Non-periodic transmit RAM start address" ]
    pub fn set_nptxfsa(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:31 - Non-periodic TxFIFO depth" ]
    pub fn set_nptxfd(&mut self, value: u16) {
        self.bits.set_range(16u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHnptxsts {
    bits: u32,
}

impl OtgFsHnptxsts {
    # [ doc = "Bits 0:15 - Non-periodic TxFIFO space available" ]
    pub fn nptxfsav(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:23 - Non-periodic transmit request queue space available" ]
    pub fn nptqxsav(&self) -> u8 {
        self.bits.get_range(16u8..24u8) as u8
    }
    # [ doc = "Bits 24:30 - Top of the non-periodic transmit request queue" ]
    pub fn nptxqtop(&self) -> u8 {
        self.bits.get_range(24u8..31u8) as u8
    }
}

impl Default for OtgFsHnptxsts {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHnptxsts { bits: 524800u32 }
    }
}

impl OtgFsHnptxsts {
    # [ doc = "Bits 0:15 - Non-periodic TxFIFO space available" ]
    pub fn set_nptxfsav(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:23 - Non-periodic transmit request queue space available" ]
    pub fn set_nptqxsav(&mut self, value: u8) {
        self.bits.set_range(16u8..24u8, value as u32);
    }
    # [ doc = "Bits 24:30 - Top of the non-periodic transmit request queue" ]
    pub fn set_nptxqtop(&mut self, value: u8) {
        self.bits.set_range(24u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsGi2cctl {
    bits: u32,
}

impl OtgFsGi2cctl {
    # [ doc = "Bits 0:7 - I2C Read/Write Data" ]
    pub fn rwdata(&self) -> u8 {
        self.bits.get_range(0u8..8u8) as u8
    }
    # [ doc = "Bits 8:15 - I2C Register Address" ]
    pub fn regaddr(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bits 16:22 - I2C Address" ]
    pub fn addr(&self) -> u8 {
        self.bits.get_range(16u8..23u8) as u8
    }
    # [ doc = "Bit 23 - I2C Enable" ]
    pub fn i2cen(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bit 24 - I2C ACK" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(24u8)
    }
    # [ doc = "Bits 26:27 - I2C Device Address" ]
    pub fn i2cdevadr(&self) -> u8 {
        self.bits.get_range(26u8..28u8) as u8
    }
    # [ doc = "Bit 28 - I2C DatSe0 USB mode" ]
    pub fn i2cdatse0(&self) -> bool {
        self.bits.get_bit(28u8)
    }
    # [ doc = "Bit 30 - Read/Write Indicator" ]
    pub fn rw(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - I2C Busy/Done" ]
    pub fn bsydne(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgFsGi2cctl {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsGi2cctl { bits: 33555456u32 }
    }
}

impl OtgFsGi2cctl {
    # [ doc = "Bits 0:7 - I2C Read/Write Data" ]
    pub fn set_rwdata(&mut self, value: u8) {
        self.bits.set_range(0u8..8u8, value as u32);
    }
    # [ doc = "Bits 8:15 - I2C Register Address" ]
    pub fn set_regaddr(&mut self, value: u8) {
        self.bits.set_range(8u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:22 - I2C Address" ]
    pub fn set_addr(&mut self, value: u8) {
        self.bits.set_range(16u8..23u8, value as u32);
    }
    # [ doc = "Bit 23 - I2C Enable" ]
    pub fn set_i2cen(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 24 - I2C ACK" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(24u8, value);
    }
    # [ doc = "Bits 26:27 - I2C Device Address" ]
    pub fn set_i2cdevadr(&mut self, value: u8) {
        self.bits.set_range(26u8..28u8, value as u32);
    }
    # [ doc = "Bit 28 - I2C DatSe0 USB mode" ]
    pub fn set_i2cdatse0(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 30 - Read/Write Indicator" ]
    pub fn set_rw(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - I2C Busy/Done" ]
    pub fn set_bsydne(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsGccfg {
    bits: u32,
}

impl OtgFsGccfg {
    # [ doc = "Bit 16 - Power down" ]
    pub fn pwrdwn(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - Battery charging detector (BCD) enable" ]
    pub fn bcden(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bit 18 - Data contact detection (DCD) mode enable" ]
    pub fn dcden(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 19 - Primary detection (PD) mode enable" ]
    pub fn pden(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 20 - Secondary detection (SD) mode enable" ]
    pub fn sden(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 21 - USB VBUS detection enable" ]
    pub fn vbden(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 0 - Data contact detection (DCD) status" ]
    pub fn dcdet(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Primary detection (PD) status" ]
    pub fn pdet(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - Secondary detection (SD) status" ]
    pub fn sdet(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - DM pull-up detection status" ]
    pub fn ps2det(&self) -> bool {
        self.bits.get_bit(3u8)
    }
}

impl Default for OtgFsGccfg {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsGccfg { bits: 0u32 }
    }
}

impl OtgFsGccfg {
    # [ doc = "Bit 16 - Power down" ]
    pub fn set_pwrdwn(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 17 - Battery charging detector (BCD) enable" ]
    pub fn set_bcden(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bit 18 - Data contact detection (DCD) mode enable" ]
    pub fn set_dcden(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 19 - Primary detection (PD) mode enable" ]
    pub fn set_pden(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 20 - Secondary detection (SD) mode enable" ]
    pub fn set_sden(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 21 - USB VBUS detection enable" ]
    pub fn set_vbden(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 0 - Data contact detection (DCD) status" ]
    pub fn set_dcdet(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Primary detection (PD) status" ]
    pub fn set_pdet(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - Secondary detection (SD) status" ]
    pub fn set_sdet(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - DM pull-up detection status" ]
    pub fn set_ps2det(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsCid {
    bits: u32,
}

impl OtgFsCid {
    # [ doc = "Bits 0:31 - Product ID field" ]
    pub fn product_id(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for OtgFsCid {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsCid { bits: 4096u32 }
    }
}

impl OtgFsCid {
    # [ doc = "Bits 0:31 - Product ID field" ]
    pub fn set_product_id(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsGlpmcfg {
    bits: u32,
}

impl OtgFsGlpmcfg {
    # [ doc = "Bit 0 - LPM support enable" ]
    pub fn lpmen(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - LPM token acknowledge enable" ]
    pub fn lpmack(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bits 2:5 - Best effort service latency" ]
    pub fn besl(&self) -> u8 {
        self.bits.get_range(2u8..6u8) as u8
    }
    # [ doc = "Bit 6 - bRemoteWake value" ]
    pub fn remwake(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - L1 Shallow Sleep enable" ]
    pub fn l1ssen(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bits 8:11 - BESL threshold" ]
    pub fn beslthrs(&self) -> u8 {
        self.bits.get_range(8u8..12u8) as u8
    }
    # [ doc = "Bit 12 - L1 deep sleep enable" ]
    pub fn l1dsen(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bits 13:14 - LPM response" ]
    pub fn lpmrst(&self) -> u8 {
        self.bits.get_range(13u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Port sleep status" ]
    pub fn slpsts(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 16 - Sleep State Resume OK" ]
    pub fn l1rsmok(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bits 17:20 - LPM Channel Index" ]
    pub fn lpmchidx(&self) -> u8 {
        self.bits.get_range(17u8..21u8) as u8
    }
    # [ doc = "Bits 21:23 - LPM retry count" ]
    pub fn lpmrcnt(&self) -> u8 {
        self.bits.get_range(21u8..24u8) as u8
    }
    # [ doc = "Bit 24 - Send LPM transaction" ]
    pub fn sndlpm(&self) -> bool {
        self.bits.get_bit(24u8)
    }
    # [ doc = "Bits 25:27 - LPM retry count status" ]
    pub fn lpmrcntsts(&self) -> u8 {
        self.bits.get_range(25u8..28u8) as u8
    }
    # [ doc = "Bit 28 - Enable best effort service latency" ]
    pub fn enbesl(&self) -> bool {
        self.bits.get_bit(28u8)
    }
}

impl Default for OtgFsGlpmcfg {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsGlpmcfg { bits: 33555456u32 }
    }
}

impl OtgFsGlpmcfg {
    # [ doc = "Bit 0 - LPM support enable" ]
    pub fn set_lpmen(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - LPM token acknowledge enable" ]
    pub fn set_lpmack(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bits 2:5 - Best effort service latency" ]
    pub fn set_besl(&mut self, value: u8) {
        self.bits.set_range(2u8..6u8, value as u32);
    }
    # [ doc = "Bit 6 - bRemoteWake value" ]
    pub fn set_remwake(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - L1 Shallow Sleep enable" ]
    pub fn set_l1ssen(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bits 8:11 - BESL threshold" ]
    pub fn set_beslthrs(&mut self, value: u8) {
        self.bits.set_range(8u8..12u8, value as u32);
    }
    # [ doc = "Bit 12 - L1 deep sleep enable" ]
    pub fn set_l1dsen(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bits 17:20 - LPM Channel Index" ]
    pub fn set_lpmchidx(&mut self, value: u8) {
        self.bits.set_range(17u8..21u8, value as u32);
    }
    # [ doc = "Bits 21:23 - LPM retry count" ]
    pub fn set_lpmrcnt(&mut self, value: u8) {
        self.bits.set_range(21u8..24u8, value as u32);
    }
    # [ doc = "Bit 24 - Send LPM transaction" ]
    pub fn set_sndlpm(&mut self, value: bool) {
        self.bits.set_bit(24u8, value);
    }
    # [ doc = "Bit 28 - Enable best effort service latency" ]
    pub fn set_enbesl(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsGpwrdn {
    bits: u32,
}

impl OtgFsGpwrdn {
    # [ doc = "Bit 0 - ADP module enable" ]
    pub fn adpmen(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 23 - ADP interrupt flag" ]
    pub fn adpif(&self) -> bool {
        self.bits.get_bit(23u8)
    }
}

impl Default for OtgFsGpwrdn {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsGpwrdn { bits: 33555456u32 }
    }
}

impl OtgFsGpwrdn {
    # [ doc = "Bit 0 - ADP module enable" ]
    pub fn set_adpmen(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 23 - ADP interrupt flag" ]
    pub fn set_adpif(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsGadpctl {
    bits: u32,
}

impl OtgFsGadpctl {
    # [ doc = "Bits 0:1 - Probe discharge" ]
    pub fn prbdschg(&self) -> u8 {
        self.bits.get_range(0u8..2u8) as u8
    }
    # [ doc = "Bits 2:3 - Probe delta" ]
    pub fn prbdelta(&self) -> u8 {
        self.bits.get_range(2u8..4u8) as u8
    }
    # [ doc = "Bits 4:5 - Probe period" ]
    pub fn prbper(&self) -> u8 {
        self.bits.get_range(4u8..6u8) as u8
    }
    # [ doc = "Bits 6:16 - Ramp time" ]
    pub fn rtim(&self) -> u16 {
        self.bits.get_range(6u8..17u8) as u16
    }
    # [ doc = "Bit 17 - Enable probe" ]
    pub fn enaprb(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bit 18 - Enable sense" ]
    pub fn enasns(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 19 - ADP reset" ]
    pub fn adprst(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 20 - ADP enable" ]
    pub fn adpen(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 21 - ADP probe interrupt flag" ]
    pub fn adpprbif(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 22 - ADP sense interrupt flag" ]
    pub fn adpsnsif(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bit 23 - ADP timeout interrupt flag" ]
    pub fn adptoif(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bit 24 - ADP probe interrupt mask" ]
    pub fn adpprbim(&self) -> bool {
        self.bits.get_bit(24u8)
    }
    # [ doc = "Bit 25 - ADP sense interrupt mask" ]
    pub fn adpsnsim(&self) -> bool {
        self.bits.get_bit(25u8)
    }
    # [ doc = "Bit 26 - ADP timeout interrupt mask" ]
    pub fn adptoim(&self) -> bool {
        self.bits.get_bit(26u8)
    }
    # [ doc = "Bits 27:28 - Access request" ]
    pub fn ar(&self) -> u8 {
        self.bits.get_range(27u8..29u8) as u8
    }
}

impl Default for OtgFsGadpctl {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsGadpctl { bits: 33555456u32 }
    }
}

impl OtgFsGadpctl {
    # [ doc = "Bits 0:1 - Probe discharge" ]
    pub fn set_prbdschg(&mut self, value: u8) {
        self.bits.set_range(0u8..2u8, value as u32);
    }
    # [ doc = "Bits 2:3 - Probe delta" ]
    pub fn set_prbdelta(&mut self, value: u8) {
        self.bits.set_range(2u8..4u8, value as u32);
    }
    # [ doc = "Bits 4:5 - Probe period" ]
    pub fn set_prbper(&mut self, value: u8) {
        self.bits.set_range(4u8..6u8, value as u32);
    }
    # [ doc = "Bit 17 - Enable probe" ]
    pub fn set_enaprb(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bit 18 - Enable sense" ]
    pub fn set_enasns(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 20 - ADP enable" ]
    pub fn set_adpen(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 21 - ADP probe interrupt flag" ]
    pub fn set_adpprbif(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 22 - ADP sense interrupt flag" ]
    pub fn set_adpsnsif(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 23 - ADP timeout interrupt flag" ]
    pub fn set_adptoif(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 24 - ADP probe interrupt mask" ]
    pub fn set_adpprbim(&mut self, value: bool) {
        self.bits.set_bit(24u8, value);
    }
    # [ doc = "Bit 25 - ADP sense interrupt mask" ]
    pub fn set_adpsnsim(&mut self, value: bool) {
        self.bits.set_bit(25u8, value);
    }
    # [ doc = "Bit 26 - ADP timeout interrupt mask" ]
    pub fn set_adptoim(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bits 27:28 - Access request" ]
    pub fn set_ar(&mut self, value: u8) {
        self.bits.set_range(27u8..29u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHptxfsiz {
    bits: u32,
}

impl OtgFsHptxfsiz {
    # [ doc = "Bits 0:15 - Host periodic TxFIFO start address" ]
    pub fn ptxsa(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:31 - Host periodic TxFIFO depth" ]
    pub fn ptxfsiz(&self) -> u16 {
        self.bits.get_range(16u8..32u8) as u16
    }
}

impl Default for OtgFsHptxfsiz {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHptxfsiz { bits: 33555968u32 }
    }
}

impl OtgFsHptxfsiz {
    # [ doc = "Bits 0:15 - Host periodic TxFIFO start address" ]
    pub fn set_ptxsa(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:31 - Host periodic TxFIFO depth" ]
    pub fn set_ptxfsiz(&mut self, value: u16) {
        self.bits.set_range(16u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsDieptxf1 {
    bits: u32,
}

impl OtgFsDieptxf1 {
    # [ doc = "Bits 0:15 - IN endpoint FIFO2 transmit RAM start address" ]
    pub fn ineptxsa(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:31 - IN endpoint TxFIFO depth" ]
    pub fn ineptxfd(&self) -> u16 {
        self.bits.get_range(16u8..32u8) as u16
    }
}

impl Default for OtgFsDieptxf1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsDieptxf1 { bits: 33555456u32 }
    }
}

impl OtgFsDieptxf1 {
    # [ doc = "Bits 0:15 - IN endpoint FIFO2 transmit RAM start address" ]
    pub fn set_ineptxsa(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:31 - IN endpoint TxFIFO depth" ]
    pub fn set_ineptxfd(&mut self, value: u16) {
        self.bits.set_range(16u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsDieptxf2 {
    bits: u32,
}

impl OtgFsDieptxf2 {
    # [ doc = "Bits 0:15 - IN endpoint FIFO3 transmit RAM start address" ]
    pub fn ineptxsa(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:31 - IN endpoint TxFIFO depth" ]
    pub fn ineptxfd(&self) -> u16 {
        self.bits.get_range(16u8..32u8) as u16
    }
}

impl Default for OtgFsDieptxf2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsDieptxf2 { bits: 33555456u32 }
    }
}

impl OtgFsDieptxf2 {
    # [ doc = "Bits 0:15 - IN endpoint FIFO3 transmit RAM start address" ]
    pub fn set_ineptxsa(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:31 - IN endpoint TxFIFO depth" ]
    pub fn set_ineptxfd(&mut self, value: u16) {
        self.bits.set_range(16u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsDieptxf3 {
    bits: u32,
}

impl OtgFsDieptxf3 {
    # [ doc = "Bits 0:15 - IN endpoint FIFO4 transmit RAM start address" ]
    pub fn ineptxsa(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:31 - IN endpoint TxFIFO depth" ]
    pub fn ineptxfd(&self) -> u16 {
        self.bits.get_range(16u8..32u8) as u16
    }
}

impl Default for OtgFsDieptxf3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsDieptxf3 { bits: 33555456u32 }
    }
}

impl OtgFsDieptxf3 {
    # [ doc = "Bits 0:15 - IN endpoint FIFO4 transmit RAM start address" ]
    pub fn set_ineptxsa(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:31 - IN endpoint TxFIFO depth" ]
    pub fn set_ineptxfd(&mut self, value: u16) {
        self.bits.set_range(16u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsDieptxf4 {
    bits: u32,
}

impl OtgFsDieptxf4 {
    # [ doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address" ]
    pub fn ineptxsa(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:31 - IN endpoint Tx FIFO depth" ]
    pub fn ineptxfd(&self) -> u16 {
        self.bits.get_range(16u8..32u8) as u16
    }
}

impl Default for OtgFsDieptxf4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsDieptxf4 { bits: 33555456u32 }
    }
}

impl OtgFsDieptxf4 {
    # [ doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address" ]
    pub fn set_ineptxsa(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:31 - IN endpoint Tx FIFO depth" ]
    pub fn set_ineptxfd(&mut self, value: u16) {
        self.bits.set_range(16u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsDieptxf5 {
    bits: u32,
}

impl OtgFsDieptxf5 {
    # [ doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address" ]
    pub fn ineptxsa(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:31 - IN endpoint Tx FIFO depth" ]
    pub fn ineptxfd(&self) -> u16 {
        self.bits.get_range(16u8..32u8) as u16
    }
}

impl Default for OtgFsDieptxf5 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsDieptxf5 { bits: 33555456u32 }
    }
}

impl OtgFsDieptxf5 {
    # [ doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address" ]
    pub fn set_ineptxsa(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:31 - IN endpoint Tx FIFO depth" ]
    pub fn set_ineptxfd(&mut self, value: u16) {
        self.bits.set_range(16u8..32u8, value as u32);
    }
}
