// autogenerated

use volatile;
use bit_field::BitField;

# [ doc = "Ethernet: Precision time protocol" ]
# [ repr ( C ) ]
pub struct EthernetPtp {
    # [ doc = "0x00 - Ethernet PTP time stamp control register" ]
    pub ptptscr: volatile::ReadWrite<Ptptscr>,
    # [ doc = "0x04 - Ethernet PTP subsecond increment register" ]
    pub ptpssir: volatile::ReadWrite<Ptpssir>,
    # [ doc = "0x08 - Ethernet PTP time stamp high register" ]
    pub ptptshr: volatile::ReadOnly<Ptptshr>,
    # [ doc = "0x0c - Ethernet PTP time stamp low register" ]
    pub ptptslr: volatile::ReadOnly<Ptptslr>,
    # [ doc = "0x10 - Ethernet PTP time stamp high update register" ]
    pub ptptshur: volatile::ReadWrite<Ptptshur>,
    # [ doc = "0x14 - Ethernet PTP time stamp low update register" ]
    pub ptptslur: volatile::ReadWrite<Ptptslur>,
    # [ doc = "0x18 - Ethernet PTP time stamp addend register" ]
    pub ptptsar: volatile::ReadWrite<Ptptsar>,
    # [ doc = "0x1c - Ethernet PTP target time high register" ]
    pub ptptthr: volatile::ReadWrite<Ptptthr>,
    # [ doc = "0x20 - Ethernet PTP target time low register" ]
    pub ptpttlr: volatile::ReadWrite<Ptpttlr>,
    _reserved0: [u8; 4usize],
    # [ doc = "0x28 - Ethernet PTP time stamp status register" ]
    pub ptptssr: volatile::ReadOnly<Ptptssr>,
    # [ doc = "0x2c - Ethernet PTP PPS control register" ]
    pub ptpppscr: volatile::ReadOnly<Ptpppscr>,
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ptptscr {
    bits: u32,
}

impl Ptptscr {
    # [ doc = "Bit 0 - no description available" ]
    pub fn tse(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - no description available" ]
    pub fn tsfcu(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 10 - no description available" ]
    pub fn tsptppsv2e(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 11 - no description available" ]
    pub fn tssptpoefe(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 12 - no description available" ]
    pub fn tssipv6fe(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 13 - no description available" ]
    pub fn tssipv4fe(&self) -> bool {
        self.bits.get_bit(13u8)
    }
    # [ doc = "Bit 14 - no description available" ]
    pub fn tsseme(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 15 - no description available" ]
    pub fn tssmrme(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bits 16:17 - no description available" ]
    pub fn tscnt(&self) -> u8 {
        self.bits.get_range(16u8..18u8) as u8
    }
    # [ doc = "Bit 18 - no description available" ]
    pub fn tspffmae(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 2 - no description available" ]
    pub fn tssti(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - no description available" ]
    pub fn tsstu(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - no description available" ]
    pub fn tsite(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - no description available" ]
    pub fn ttsaru(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 8 - no description available" ]
    pub fn tssarfe(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - no description available" ]
    pub fn tsssr(&self) -> bool {
        self.bits.get_bit(9u8)
    }
}

impl Default for Ptptscr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ptptscr { bits: 8192u32 }
    }
}

impl Ptptscr {
    # [ doc = "Bit 0 - no description available" ]
    pub fn set_tse(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - no description available" ]
    pub fn set_tsfcu(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 10 - no description available" ]
    pub fn set_tsptppsv2e(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 11 - no description available" ]
    pub fn set_tssptpoefe(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 12 - no description available" ]
    pub fn set_tssipv6fe(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 13 - no description available" ]
    pub fn set_tssipv4fe(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
    # [ doc = "Bit 14 - no description available" ]
    pub fn set_tsseme(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 15 - no description available" ]
    pub fn set_tssmrme(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 16:17 - no description available" ]
    pub fn set_tscnt(&mut self, value: u8) {
        self.bits.set_range(16u8..18u8, value as u32);
    }
    # [ doc = "Bit 18 - no description available" ]
    pub fn set_tspffmae(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 2 - no description available" ]
    pub fn set_tssti(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - no description available" ]
    pub fn set_tsstu(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - no description available" ]
    pub fn set_tsite(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - no description available" ]
    pub fn set_ttsaru(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 8 - no description available" ]
    pub fn set_tssarfe(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - no description available" ]
    pub fn set_tsssr(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ptpssir {
    bits: u32,
}

impl Ptpssir {
    # [ doc = "Bits 0:7 - no description available" ]
    pub fn stssi(&self) -> u8 {
        self.bits.get_range(0u8..8u8) as u8
    }
}

impl Default for Ptpssir {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ptpssir { bits: 0u32 }
    }
}

impl Ptpssir {
    # [ doc = "Bits 0:7 - no description available" ]
    pub fn set_stssi(&mut self, value: u8) {
        self.bits.set_range(0u8..8u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ptptshr {
    bits: u32,
}

impl Ptptshr {
    # [ doc = "Bits 0:31 - no description available" ]
    pub fn sts(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Ptptshr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ptptshr { bits: 0u32 }
    }
}

impl Ptptshr {
    # [ doc = "Bits 0:31 - no description available" ]
    pub fn set_sts(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ptptslr {
    bits: u32,
}

impl Ptptslr {
    # [ doc = "Bits 0:30 - no description available" ]
    pub fn stss(&self) -> u32 {
        self.bits.get_range(0u8..31u8) as u32
    }
    # [ doc = "Bit 31 - no description available" ]
    pub fn stpns(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for Ptptslr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ptptslr { bits: 0u32 }
    }
}

impl Ptptslr {
    # [ doc = "Bits 0:30 - no description available" ]
    pub fn set_stss(&mut self, value: u32) {
        self.bits.set_range(0u8..31u8, value as u32);
    }
    # [ doc = "Bit 31 - no description available" ]
    pub fn set_stpns(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ptptshur {
    bits: u32,
}

impl Ptptshur {
    # [ doc = "Bits 0:31 - no description available" ]
    pub fn tsus(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Ptptshur {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ptptshur { bits: 0u32 }
    }
}

impl Ptptshur {
    # [ doc = "Bits 0:31 - no description available" ]
    pub fn set_tsus(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ptptslur {
    bits: u32,
}

impl Ptptslur {
    # [ doc = "Bits 0:30 - no description available" ]
    pub fn tsuss(&self) -> u32 {
        self.bits.get_range(0u8..31u8) as u32
    }
    # [ doc = "Bit 31 - no description available" ]
    pub fn tsupns(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for Ptptslur {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ptptslur { bits: 0u32 }
    }
}

impl Ptptslur {
    # [ doc = "Bits 0:30 - no description available" ]
    pub fn set_tsuss(&mut self, value: u32) {
        self.bits.set_range(0u8..31u8, value as u32);
    }
    # [ doc = "Bit 31 - no description available" ]
    pub fn set_tsupns(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ptptsar {
    bits: u32,
}

impl Ptptsar {
    # [ doc = "Bits 0:31 - no description available" ]
    pub fn tsa(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Ptptsar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ptptsar { bits: 0u32 }
    }
}

impl Ptptsar {
    # [ doc = "Bits 0:31 - no description available" ]
    pub fn set_tsa(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ptptthr {
    bits: u32,
}

impl Ptptthr {
    # [ doc = "Bits 0:31 - 0" ]
    pub fn ttsh(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Ptptthr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ptptthr { bits: 0u32 }
    }
}

impl Ptptthr {
    # [ doc = "Bits 0:31 - 0" ]
    pub fn set_ttsh(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ptpttlr {
    bits: u32,
}

impl Ptpttlr {
    # [ doc = "Bits 0:31 - no description available" ]
    pub fn ttsl(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Ptpttlr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ptpttlr { bits: 0u32 }
    }
}

impl Ptpttlr {
    # [ doc = "Bits 0:31 - no description available" ]
    pub fn set_ttsl(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ptptssr {
    bits: u32,
}

impl Ptptssr {
    # [ doc = "Bit 0 - no description available" ]
    pub fn tsso(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - no description available" ]
    pub fn tsttr(&self) -> bool {
        self.bits.get_bit(1u8)
    }
}

impl Default for Ptptssr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ptptssr { bits: 0u32 }
    }
}

impl Ptptssr {
    # [ doc = "Bit 0 - no description available" ]
    pub fn set_tsso(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - no description available" ]
    pub fn set_tsttr(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ptpppscr {
    bits: u32,
}

impl Ptpppscr {
    # [ doc = "Bit 0 - TSSO" ]
    pub fn tsso(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - TSTTR" ]
    pub fn tsttr(&self) -> bool {
        self.bits.get_bit(1u8)
    }
}

impl Default for Ptpppscr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ptpppscr { bits: 0u32 }
    }
}

impl Ptpppscr {
    # [ doc = "Bit 0 - TSSO" ]
    pub fn set_tsso(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - TSTTR" ]
    pub fn set_tsttr(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
}
