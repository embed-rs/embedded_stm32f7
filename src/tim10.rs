// autogenerated

use volatile;
use bit_field::BitField;

# [ doc = "General-purpose-timers" ]
# [ repr ( C ) ]
pub struct Tim10 {
    # [ doc = "0x00 - control register 1" ]
    pub cr1: volatile::ReadWrite<Cr1>,
    _reserved0: [u8; 4usize],
    # [ doc = "0x08 - slave mode control register" ]
    pub smcr: volatile::ReadWrite<Smcr>,
    # [ doc = "0x0c - DMA/Interrupt enable register" ]
    pub dier: volatile::ReadWrite<Dier>,
    # [ doc = "0x10 - status register" ]
    pub sr: volatile::ReadWrite<Sr>,
    # [ doc = "0x14 - event generation register" ]
    pub egr: volatile::WriteOnly<Egr>,
    # [ doc = "0x18 - capture/compare mode register 1 (output mode)" ]
    pub ccmr1_output: volatile::ReadWrite<Ccmr1Output>,
    _reserved1: [u8; 4usize],
    # [ doc = "0x20 - capture/compare enable register" ]
    pub ccer: volatile::ReadWrite<Ccer>,
    # [ doc = "0x24 - counter" ]
    pub cnt: volatile::ReadWrite<Cnt>,
    # [ doc = "0x28 - prescaler" ]
    pub psc: volatile::ReadWrite<Psc>,
    # [ doc = "0x2c - auto-reload register" ]
    pub arr: volatile::ReadWrite<Arr>,
    _reserved2: [u8; 4usize],
    # [ doc = "0x34 - capture/compare register 1" ]
    pub ccr1: volatile::ReadWrite<Ccr1>,
    _reserved3: [u8; 24usize],
    # [ doc = "0x50 - option register" ]
    pub or: volatile::ReadWrite<Or>,
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Cr1 {
    bits: u32,
}

impl Cr1 {
    # [ doc = "Bits 8:9 - Clock division" ]
    pub fn ckd(&self) -> u8 {
        self.bits.get_range(8u8..10u8) as u8
    }
    # [ doc = "Bit 7 - Auto-reload preload enable" ]
    pub fn arpe(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 2 - Update request source" ]
    pub fn urs(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Update disable" ]
    pub fn udis(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Counter enable" ]
    pub fn cen(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Cr1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Cr1 { bits: 0u32 }
    }
}

impl Cr1 {
    # [ doc = "Bits 8:9 - Clock division" ]
    pub fn set_ckd(&mut self, value: u8) {
        self.bits.set_range(8u8..10u8, value as u32);
    }
    # [ doc = "Bit 7 - Auto-reload preload enable" ]
    pub fn set_arpe(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 2 - Update request source" ]
    pub fn set_urs(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Update disable" ]
    pub fn set_udis(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Counter enable" ]
    pub fn set_cen(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Smcr {
    bits: u32,
}

impl Smcr {
    # [ doc = "Bit 16 - Slave mode selection" ]
    pub fn sms_3(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 15 - External trigger polarity" ]
    pub fn etp(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 14 - External clock enable" ]
    pub fn ece(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bits 12:13 - External trigger prescaler" ]
    pub fn etps(&self) -> u8 {
        self.bits.get_range(12u8..14u8) as u8
    }
    # [ doc = "Bits 8:11 - External trigger filter" ]
    pub fn etf(&self) -> u8 {
        self.bits.get_range(8u8..12u8) as u8
    }
    # [ doc = "Bit 7 - Master/slave mode" ]
    pub fn msm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bits 4:6 - Trigger selection" ]
    pub fn ts(&self) -> u8 {
        self.bits.get_range(4u8..7u8) as u8
    }
    # [ doc = "Bits 0:2 - Slave mode selection" ]
    pub fn sms(&self) -> u8 {
        self.bits.get_range(0u8..3u8) as u8
    }
}

impl Default for Smcr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Smcr { bits: 0u32 }
    }
}

impl Smcr {
    # [ doc = "Bit 16 - Slave mode selection" ]
    pub fn set_sms_3(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 15 - External trigger polarity" ]
    pub fn set_etp(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 14 - External clock enable" ]
    pub fn set_ece(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bits 12:13 - External trigger prescaler" ]
    pub fn set_etps(&mut self, value: u8) {
        self.bits.set_range(12u8..14u8, value as u32);
    }
    # [ doc = "Bits 8:11 - External trigger filter" ]
    pub fn set_etf(&mut self, value: u8) {
        self.bits.set_range(8u8..12u8, value as u32);
    }
    # [ doc = "Bit 7 - Master/slave mode" ]
    pub fn set_msm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bits 4:6 - Trigger selection" ]
    pub fn set_ts(&mut self, value: u8) {
        self.bits.set_range(4u8..7u8, value as u32);
    }
    # [ doc = "Bits 0:2 - Slave mode selection" ]
    pub fn set_sms(&mut self, value: u8) {
        self.bits.set_range(0u8..3u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Dier {
    bits: u32,
}

impl Dier {
    # [ doc = "Bit 1 - Capture/Compare 1 interrupt enable" ]
    pub fn cc1ie(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Update interrupt enable" ]
    pub fn uie(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Dier {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Dier { bits: 0u32 }
    }
}

impl Dier {
    # [ doc = "Bit 1 - Capture/Compare 1 interrupt enable" ]
    pub fn set_cc1ie(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Update interrupt enable" ]
    pub fn set_uie(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Sr {
    bits: u32,
}

impl Sr {
    # [ doc = "Bit 9 - Capture/Compare 1 overcapture flag" ]
    pub fn cc1of(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 1 - Capture/compare 1 interrupt flag" ]
    pub fn cc1if(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Update interrupt flag" ]
    pub fn uif(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Sr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Sr { bits: 0u32 }
    }
}

impl Sr {
    # [ doc = "Bit 9 - Capture/Compare 1 overcapture flag" ]
    pub fn set_cc1of(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 1 - Capture/compare 1 interrupt flag" ]
    pub fn set_cc1if(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Update interrupt flag" ]
    pub fn set_uif(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Egr {
    bits: u32,
}

impl Egr {
    # [ doc = "Bit 1 - Capture/compare 1 generation" ]
    pub fn cc1g(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Update generation" ]
    pub fn ug(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Egr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Egr { bits: 0u32 }
    }
}

impl Egr {
    # [ doc = "Bit 1 - Capture/compare 1 generation" ]
    pub fn set_cc1g(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Update generation" ]
    pub fn set_ug(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ccmr1Output {
    bits: u32,
}

impl Ccmr1Output {
    # [ doc = "Bits 4:6 - Output Compare 1 mode" ]
    pub fn oc1m(&self) -> u8 {
        self.bits.get_range(4u8..7u8) as u8
    }
    # [ doc = "Bit 3 - Output Compare 1 preload enable" ]
    pub fn oc1pe(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Output Compare 1 fast enable" ]
    pub fn oc1fe(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
    pub fn cc1s(&self) -> u8 {
        self.bits.get_range(0u8..2u8) as u8
    }
}

impl Default for Ccmr1Output {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ccmr1Output { bits: 0u32 }
    }
}

impl Ccmr1Output {
    # [ doc = "Bits 4:6 - Output Compare 1 mode" ]
    pub fn set_oc1m(&mut self, value: u8) {
        self.bits.set_range(4u8..7u8, value as u32);
    }
    # [ doc = "Bit 3 - Output Compare 1 preload enable" ]
    pub fn set_oc1pe(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Output Compare 1 fast enable" ]
    pub fn set_oc1fe(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
    pub fn set_cc1s(&mut self, value: u8) {
        self.bits.set_range(0u8..2u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ccmr1Input {
    bits: u32,
}

impl Ccmr1Input {
    # [ doc = "Bits 4:7 - Input capture 1 filter" ]
    pub fn ic1f(&self) -> u8 {
        self.bits.get_range(4u8..8u8) as u8
    }
    # [ doc = "Bits 2:3 - Input capture 1 prescaler" ]
    pub fn icpcs(&self) -> u8 {
        self.bits.get_range(2u8..4u8) as u8
    }
    # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
    pub fn cc1s(&self) -> u8 {
        self.bits.get_range(0u8..2u8) as u8
    }
}

impl Default for Ccmr1Input {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ccmr1Input { bits: 0u32 }
    }
}

impl Ccmr1Input {
    # [ doc = "Bits 4:7 - Input capture 1 filter" ]
    pub fn set_ic1f(&mut self, value: u8) {
        self.bits.set_range(4u8..8u8, value as u32);
    }
    # [ doc = "Bits 2:3 - Input capture 1 prescaler" ]
    pub fn set_icpcs(&mut self, value: u8) {
        self.bits.set_range(2u8..4u8, value as u32);
    }
    # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
    pub fn set_cc1s(&mut self, value: u8) {
        self.bits.set_range(0u8..2u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ccer {
    bits: u32,
}

impl Ccer {
    # [ doc = "Bit 3 - Capture/Compare 1 output Polarity" ]
    pub fn cc1np(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 1 - Capture/Compare 1 output Polarity" ]
    pub fn cc1p(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Capture/Compare 1 output enable" ]
    pub fn cc1e(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Ccer {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ccer { bits: 0u32 }
    }
}

impl Ccer {
    # [ doc = "Bit 3 - Capture/Compare 1 output Polarity" ]
    pub fn set_cc1np(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 1 - Capture/Compare 1 output Polarity" ]
    pub fn set_cc1p(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Capture/Compare 1 output enable" ]
    pub fn set_cc1e(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Cnt {
    bits: u32,
}

impl Cnt {
    # [ doc = "Bits 0:15 - counter value" ]
    pub fn cnt(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for Cnt {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Cnt { bits: 0u32 }
    }
}

impl Cnt {
    # [ doc = "Bits 0:15 - counter value" ]
    pub fn set_cnt(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Psc {
    bits: u32,
}

impl Psc {
    # [ doc = "Bits 0:15 - Prescaler value" ]
    pub fn psc(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for Psc {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Psc { bits: 0u32 }
    }
}

impl Psc {
    # [ doc = "Bits 0:15 - Prescaler value" ]
    pub fn set_psc(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Arr {
    bits: u32,
}

impl Arr {
    # [ doc = "Bits 0:15 - Auto-reload value" ]
    pub fn arr(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for Arr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Arr { bits: 0u32 }
    }
}

impl Arr {
    # [ doc = "Bits 0:15 - Auto-reload value" ]
    pub fn set_arr(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ccr1 {
    bits: u32,
}

impl Ccr1 {
    # [ doc = "Bits 0:15 - Capture/Compare 1 value" ]
    pub fn ccr1(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for Ccr1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ccr1 { bits: 0u32 }
    }
}

impl Ccr1 {
    # [ doc = "Bits 0:15 - Capture/Compare 1 value" ]
    pub fn set_ccr1(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Or {
    bits: u32,
}

impl Or {
    # [ doc = "Bits 0:1 - TIM11 Input 1 remapping capability" ]
    pub fn ti1_rmp(&self) -> u8 {
        self.bits.get_range(0u8..2u8) as u8
    }
}

impl Default for Or {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Or { bits: 0u32 }
    }
}

impl Or {
    # [ doc = "Bits 0:1 - TIM11 Input 1 remapping capability" ]
    pub fn set_ti1_rmp(&mut self, value: u8) {
        self.bits.set_range(0u8..2u8, value as u32);
    }
}
