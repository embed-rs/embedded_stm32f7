// autogenerated

use volatile;
use bit_field::BitField;

# [ doc = "Real-time clock" ]
# [ repr ( C ) ]
pub struct Rtc {
    # [ doc = "0x00 - time register" ]
    pub tr: volatile::ReadWrite<Tr>,
    # [ doc = "0x04 - date register" ]
    pub dr: volatile::ReadWrite<Dr>,
    # [ doc = "0x08 - control register" ]
    pub cr: volatile::ReadWrite<Cr>,
    # [ doc = "0x0c - initialization and status register" ]
    pub isr: volatile::ReadWrite<Isr>,
    # [ doc = "0x10 - prescaler register" ]
    pub prer: volatile::ReadWrite<Prer>,
    # [ doc = "0x14 - wakeup timer register" ]
    pub wutr: volatile::ReadWrite<Wutr>,
    _reserved0: [u8; 4usize],
    # [ doc = "0x1c - alarm A register" ]
    pub alrmar: volatile::ReadWrite<Alrmar>,
    # [ doc = "0x20 - alarm B register" ]
    pub alrmbr: volatile::ReadWrite<Alrmbr>,
    # [ doc = "0x24 - write protection register" ]
    pub wpr: volatile::WriteOnly<Wpr>,
    # [ doc = "0x28 - sub second register" ]
    pub ssr: volatile::ReadOnly<Ssr>,
    # [ doc = "0x2c - shift control register" ]
    pub shiftr: volatile::WriteOnly<Shiftr>,
    # [ doc = "0x30 - time stamp time register" ]
    pub tstr: volatile::ReadOnly<Tstr>,
    # [ doc = "0x34 - time stamp date register" ]
    pub tsdr: volatile::ReadOnly<Tsdr>,
    # [ doc = "0x38 - timestamp sub second register" ]
    pub tsssr: volatile::ReadOnly<Tsssr>,
    # [ doc = "0x3c - calibration register" ]
    pub calr: volatile::ReadWrite<Calr>,
    # [ doc = "0x40 - tamper configuration register" ]
    pub tampcr: volatile::ReadWrite<Tampcr>,
    # [ doc = "0x44 - alarm A sub second register" ]
    pub alrmassr: volatile::ReadWrite<Alrmassr>,
    # [ doc = "0x48 - alarm B sub second register" ]
    pub alrmbssr: volatile::ReadWrite<Alrmbssr>,
    # [ doc = "0x4c - option register" ]
    pub or: volatile::ReadWrite<Or>,
    # [ doc = "0x50 - backup register" ]
    pub bkp0r: volatile::ReadWrite<Bkp0r>,
    # [ doc = "0x54 - backup register" ]
    pub bkp1r: volatile::ReadWrite<Bkp1r>,
    # [ doc = "0x58 - backup register" ]
    pub bkp2r: volatile::ReadWrite<Bkp2r>,
    # [ doc = "0x5c - backup register" ]
    pub bkp3r: volatile::ReadWrite<Bkp3r>,
    # [ doc = "0x60 - backup register" ]
    pub bkp4r: volatile::ReadWrite<Bkp4r>,
    # [ doc = "0x64 - backup register" ]
    pub bkp5r: volatile::ReadWrite<Bkp5r>,
    # [ doc = "0x68 - backup register" ]
    pub bkp6r: volatile::ReadWrite<Bkp6r>,
    # [ doc = "0x6c - backup register" ]
    pub bkp7r: volatile::ReadWrite<Bkp7r>,
    # [ doc = "0x70 - backup register" ]
    pub bkp8r: volatile::ReadWrite<Bkp8r>,
    # [ doc = "0x74 - backup register" ]
    pub bkp9r: volatile::ReadWrite<Bkp9r>,
    # [ doc = "0x78 - backup register" ]
    pub bkp10r: volatile::ReadWrite<Bkp10r>,
    # [ doc = "0x7c - backup register" ]
    pub bkp11r: volatile::ReadWrite<Bkp11r>,
    # [ doc = "0x80 - backup register" ]
    pub bkp12r: volatile::ReadWrite<Bkp12r>,
    # [ doc = "0x84 - backup register" ]
    pub bkp13r: volatile::ReadWrite<Bkp13r>,
    # [ doc = "0x88 - backup register" ]
    pub bkp14r: volatile::ReadWrite<Bkp14r>,
    # [ doc = "0x8c - backup register" ]
    pub bkp15r: volatile::ReadWrite<Bkp15r>,
    # [ doc = "0x90 - backup register" ]
    pub bkp16r: volatile::ReadWrite<Bkp16r>,
    # [ doc = "0x94 - backup register" ]
    pub bkp17r: volatile::ReadWrite<Bkp17r>,
    # [ doc = "0x98 - backup register" ]
    pub bkp18r: volatile::ReadWrite<Bkp18r>,
    # [ doc = "0x9c - backup register" ]
    pub bkp19r: volatile::ReadWrite<Bkp19r>,
    # [ doc = "0xa0 - backup register" ]
    pub bkp20r: volatile::ReadWrite<Bkp20r>,
    # [ doc = "0xa4 - backup register" ]
    pub bkp21r: volatile::ReadWrite<Bkp21r>,
    # [ doc = "0xa8 - backup register" ]
    pub bkp22r: volatile::ReadWrite<Bkp22r>,
    # [ doc = "0xac - backup register" ]
    pub bkp23r: volatile::ReadWrite<Bkp23r>,
    # [ doc = "0xb0 - backup register" ]
    pub bkp24r: volatile::ReadWrite<Bkp24r>,
    # [ doc = "0xb4 - backup register" ]
    pub bkp25r: volatile::ReadWrite<Bkp25r>,
    # [ doc = "0xb8 - backup register" ]
    pub bkp26r: volatile::ReadWrite<Bkp26r>,
    # [ doc = "0xbc - backup register" ]
    pub bkp27r: volatile::ReadWrite<Bkp27r>,
    # [ doc = "0xc0 - backup register" ]
    pub bkp28r: volatile::ReadWrite<Bkp28r>,
    # [ doc = "0xc4 - backup register" ]
    pub bkp29r: volatile::ReadWrite<Bkp29r>,
    # [ doc = "0xc8 - backup register" ]
    pub bkp30r: volatile::ReadWrite<Bkp30r>,
    # [ doc = "0xcc - backup register" ]
    pub bkp31r: volatile::ReadWrite<Bkp31r>,
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Tr {
    bits: u32,
}

impl Tr {
    # [ doc = "Bit 22 - AM/PM notation" ]
    pub fn pm(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bits 20:21 - Hour tens in BCD format" ]
    pub fn ht(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 16:19 - Hour units in BCD format" ]
    pub fn hu(&self) -> u8 {
        self.bits.get_range(16u8..20u8) as u8
    }
    # [ doc = "Bits 12:14 - Minute tens in BCD format" ]
    pub fn mnt(&self) -> u8 {
        self.bits.get_range(12u8..15u8) as u8
    }
    # [ doc = "Bits 8:11 - Minute units in BCD format" ]
    pub fn mnu(&self) -> u8 {
        self.bits.get_range(8u8..12u8) as u8
    }
    # [ doc = "Bits 4:6 - Second tens in BCD format" ]
    pub fn st(&self) -> u8 {
        self.bits.get_range(4u8..7u8) as u8
    }
    # [ doc = "Bits 0:3 - Second units in BCD format" ]
    pub fn su(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
}

impl Default for Tr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Tr { bits: 0u32 }
    }
}

impl Tr {
    # [ doc = "Bit 22 - AM/PM notation" ]
    pub fn set_pm(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bits 20:21 - Hour tens in BCD format" ]
    pub fn set_ht(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 16:19 - Hour units in BCD format" ]
    pub fn set_hu(&mut self, value: u8) {
        self.bits.set_range(16u8..20u8, value as u32);
    }
    # [ doc = "Bits 12:14 - Minute tens in BCD format" ]
    pub fn set_mnt(&mut self, value: u8) {
        self.bits.set_range(12u8..15u8, value as u32);
    }
    # [ doc = "Bits 8:11 - Minute units in BCD format" ]
    pub fn set_mnu(&mut self, value: u8) {
        self.bits.set_range(8u8..12u8, value as u32);
    }
    # [ doc = "Bits 4:6 - Second tens in BCD format" ]
    pub fn set_st(&mut self, value: u8) {
        self.bits.set_range(4u8..7u8, value as u32);
    }
    # [ doc = "Bits 0:3 - Second units in BCD format" ]
    pub fn set_su(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Dr {
    bits: u32,
}

impl Dr {
    # [ doc = "Bits 20:23 - Year tens in BCD format" ]
    pub fn yt(&self) -> u8 {
        self.bits.get_range(20u8..24u8) as u8
    }
    # [ doc = "Bits 16:19 - Year units in BCD format" ]
    pub fn yu(&self) -> u8 {
        self.bits.get_range(16u8..20u8) as u8
    }
    # [ doc = "Bits 13:15 - Week day units" ]
    pub fn wdu(&self) -> u8 {
        self.bits.get_range(13u8..16u8) as u8
    }
    # [ doc = "Bit 12 - Month tens in BCD format" ]
    pub fn mt(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bits 8:11 - Month units in BCD format" ]
    pub fn mu(&self) -> u8 {
        self.bits.get_range(8u8..12u8) as u8
    }
    # [ doc = "Bits 4:5 - Date tens in BCD format" ]
    pub fn dt(&self) -> u8 {
        self.bits.get_range(4u8..6u8) as u8
    }
    # [ doc = "Bits 0:3 - Date units in BCD format" ]
    pub fn du(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
}

impl Default for Dr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Dr { bits: 8449u32 }
    }
}

impl Dr {
    # [ doc = "Bits 20:23 - Year tens in BCD format" ]
    pub fn set_yt(&mut self, value: u8) {
        self.bits.set_range(20u8..24u8, value as u32);
    }
    # [ doc = "Bits 16:19 - Year units in BCD format" ]
    pub fn set_yu(&mut self, value: u8) {
        self.bits.set_range(16u8..20u8, value as u32);
    }
    # [ doc = "Bits 13:15 - Week day units" ]
    pub fn set_wdu(&mut self, value: u8) {
        self.bits.set_range(13u8..16u8, value as u32);
    }
    # [ doc = "Bit 12 - Month tens in BCD format" ]
    pub fn set_mt(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bits 8:11 - Month units in BCD format" ]
    pub fn set_mu(&mut self, value: u8) {
        self.bits.set_range(8u8..12u8, value as u32);
    }
    # [ doc = "Bits 4:5 - Date tens in BCD format" ]
    pub fn set_dt(&mut self, value: u8) {
        self.bits.set_range(4u8..6u8, value as u32);
    }
    # [ doc = "Bits 0:3 - Date units in BCD format" ]
    pub fn set_du(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Cr {
    bits: u32,
}

impl Cr {
    # [ doc = "Bits 0:2 - Wakeup clock selection" ]
    pub fn wcksel(&self) -> u8 {
        self.bits.get_range(0u8..3u8) as u8
    }
    # [ doc = "Bit 3 - Time-stamp event active edge" ]
    pub fn tsedge(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - Reference clock detection enable (50 or 60 Hz)" ]
    pub fn refckon(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - Bypass the shadow registers" ]
    pub fn bypshad(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Hour format" ]
    pub fn fmt(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 8 - Alarm A enable" ]
    pub fn alrae(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Alarm B enable" ]
    pub fn alrbe(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Wakeup timer enable" ]
    pub fn wute(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 11 - Time stamp enable" ]
    pub fn tse(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 12 - Alarm A interrupt enable" ]
    pub fn alraie(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 13 - Alarm B interrupt enable" ]
    pub fn alrbie(&self) -> bool {
        self.bits.get_bit(13u8)
    }
    # [ doc = "Bit 14 - Wakeup timer interrupt enable" ]
    pub fn wutie(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 15 - Time-stamp interrupt enable" ]
    pub fn tsie(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 16 - Add 1 hour (summer time change)" ]
    pub fn add1h(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - Subtract 1 hour (winter time change)" ]
    pub fn sub1h(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bit 18 - Backup" ]
    pub fn bkp(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 19 - Calibration output selection" ]
    pub fn cosel(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 20 - Output polarity" ]
    pub fn pol(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bits 21:22 - Output selection" ]
    pub fn osel(&self) -> u8 {
        self.bits.get_range(21u8..23u8) as u8
    }
    # [ doc = "Bit 23 - Calibration output enable" ]
    pub fn coe(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bit 24 - timestamp on internal event enable" ]
    pub fn itse(&self) -> bool {
        self.bits.get_bit(24u8)
    }
}

impl Default for Cr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Cr { bits: 0u32 }
    }
}

impl Cr {
    # [ doc = "Bits 0:2 - Wakeup clock selection" ]
    pub fn set_wcksel(&mut self, value: u8) {
        self.bits.set_range(0u8..3u8, value as u32);
    }
    # [ doc = "Bit 3 - Time-stamp event active edge" ]
    pub fn set_tsedge(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - Reference clock detection enable (50 or 60 Hz)" ]
    pub fn set_refckon(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - Bypass the shadow registers" ]
    pub fn set_bypshad(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Hour format" ]
    pub fn set_fmt(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 8 - Alarm A enable" ]
    pub fn set_alrae(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Alarm B enable" ]
    pub fn set_alrbe(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Wakeup timer enable" ]
    pub fn set_wute(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 11 - Time stamp enable" ]
    pub fn set_tse(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 12 - Alarm A interrupt enable" ]
    pub fn set_alraie(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 13 - Alarm B interrupt enable" ]
    pub fn set_alrbie(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
    # [ doc = "Bit 14 - Wakeup timer interrupt enable" ]
    pub fn set_wutie(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 15 - Time-stamp interrupt enable" ]
    pub fn set_tsie(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 16 - Add 1 hour (summer time change)" ]
    pub fn set_add1h(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 17 - Subtract 1 hour (winter time change)" ]
    pub fn set_sub1h(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bit 18 - Backup" ]
    pub fn set_bkp(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 19 - Calibration output selection" ]
    pub fn set_cosel(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 20 - Output polarity" ]
    pub fn set_pol(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bits 21:22 - Output selection" ]
    pub fn set_osel(&mut self, value: u8) {
        self.bits.set_range(21u8..23u8, value as u32);
    }
    # [ doc = "Bit 23 - Calibration output enable" ]
    pub fn set_coe(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 24 - timestamp on internal event enable" ]
    pub fn set_itse(&mut self, value: bool) {
        self.bits.set_bit(24u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Isr {
    bits: u32,
}

impl Isr {
    # [ doc = "Bit 0 - Alarm A write flag" ]
    pub fn alrawf(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Alarm B write flag" ]
    pub fn alrbwf(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - Wakeup timer write flag" ]
    pub fn wutwf(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - Shift operation pending" ]
    pub fn shpf(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - Initialization status flag" ]
    pub fn inits(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - Registers synchronization flag" ]
    pub fn rsf(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Initialization flag" ]
    pub fn initf(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Initialization mode" ]
    pub fn init(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Alarm A flag" ]
    pub fn alraf(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Alarm B flag" ]
    pub fn alrbf(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Wakeup timer flag" ]
    pub fn wutf(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 11 - Time-stamp flag" ]
    pub fn tsf(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 12 - Time-stamp overflow flag" ]
    pub fn tsovf(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 13 - Tamper detection flag" ]
    pub fn tamp1f(&self) -> bool {
        self.bits.get_bit(13u8)
    }
    # [ doc = "Bit 14 - RTC_TAMP2 detection flag" ]
    pub fn tamp2f(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 15 - RTC_TAMP3 detection flag" ]
    pub fn tamp3f(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 16 - Recalibration pending Flag" ]
    pub fn recalpf(&self) -> bool {
        self.bits.get_bit(16u8)
    }
}

impl Default for Isr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Isr { bits: 7u32 }
    }
}

impl Isr {
    # [ doc = "Bit 3 - Shift operation pending" ]
    pub fn set_shpf(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 5 - Registers synchronization flag" ]
    pub fn set_rsf(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 7 - Initialization mode" ]
    pub fn set_init(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Alarm A flag" ]
    pub fn set_alraf(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Alarm B flag" ]
    pub fn set_alrbf(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Wakeup timer flag" ]
    pub fn set_wutf(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 11 - Time-stamp flag" ]
    pub fn set_tsf(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 12 - Time-stamp overflow flag" ]
    pub fn set_tsovf(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 13 - Tamper detection flag" ]
    pub fn set_tamp1f(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
    # [ doc = "Bit 14 - RTC_TAMP2 detection flag" ]
    pub fn set_tamp2f(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 15 - RTC_TAMP3 detection flag" ]
    pub fn set_tamp3f(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Prer {
    bits: u32,
}

impl Prer {
    # [ doc = "Bits 16:22 - Asynchronous prescaler factor" ]
    pub fn prediv_a(&self) -> u8 {
        self.bits.get_range(16u8..23u8) as u8
    }
    # [ doc = "Bits 0:14 - Synchronous prescaler factor" ]
    pub fn prediv_s(&self) -> u16 {
        self.bits.get_range(0u8..15u8) as u16
    }
}

impl Default for Prer {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Prer { bits: 8323327u32 }
    }
}

impl Prer {
    # [ doc = "Bits 16:22 - Asynchronous prescaler factor" ]
    pub fn set_prediv_a(&mut self, value: u8) {
        self.bits.set_range(16u8..23u8, value as u32);
    }
    # [ doc = "Bits 0:14 - Synchronous prescaler factor" ]
    pub fn set_prediv_s(&mut self, value: u16) {
        self.bits.set_range(0u8..15u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Wutr {
    bits: u32,
}

impl Wutr {
    # [ doc = "Bits 0:15 - Wakeup auto-reload value bits" ]
    pub fn wut(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for Wutr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Wutr { bits: 65535u32 }
    }
}

impl Wutr {
    # [ doc = "Bits 0:15 - Wakeup auto-reload value bits" ]
    pub fn set_wut(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Alrmar {
    bits: u32,
}

impl Alrmar {
    # [ doc = "Bit 31 - Alarm A date mask" ]
    pub fn msk4(&self) -> bool {
        self.bits.get_bit(31u8)
    }
    # [ doc = "Bit 30 - Week day selection" ]
    pub fn wdsel(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bits 28:29 - Date tens in BCD format" ]
    pub fn dt(&self) -> u8 {
        self.bits.get_range(28u8..30u8) as u8
    }
    # [ doc = "Bits 24:27 - Date units or day in BCD format" ]
    pub fn du(&self) -> u8 {
        self.bits.get_range(24u8..28u8) as u8
    }
    # [ doc = "Bit 23 - Alarm A hours mask" ]
    pub fn msk3(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bit 22 - AM/PM notation" ]
    pub fn pm(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bits 20:21 - Hour tens in BCD format" ]
    pub fn ht(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 16:19 - Hour units in BCD format" ]
    pub fn hu(&self) -> u8 {
        self.bits.get_range(16u8..20u8) as u8
    }
    # [ doc = "Bit 15 - Alarm A minutes mask" ]
    pub fn msk2(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bits 12:14 - Minute tens in BCD format" ]
    pub fn mnt(&self) -> u8 {
        self.bits.get_range(12u8..15u8) as u8
    }
    # [ doc = "Bits 8:11 - Minute units in BCD format" ]
    pub fn mnu(&self) -> u8 {
        self.bits.get_range(8u8..12u8) as u8
    }
    # [ doc = "Bit 7 - Alarm A seconds mask" ]
    pub fn msk1(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bits 4:6 - Second tens in BCD format" ]
    pub fn st(&self) -> u8 {
        self.bits.get_range(4u8..7u8) as u8
    }
    # [ doc = "Bits 0:3 - Second units in BCD format" ]
    pub fn su(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
}

impl Default for Alrmar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Alrmar { bits: 0u32 }
    }
}

impl Alrmar {
    # [ doc = "Bit 31 - Alarm A date mask" ]
    pub fn set_msk4(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
    # [ doc = "Bit 30 - Week day selection" ]
    pub fn set_wdsel(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bits 28:29 - Date tens in BCD format" ]
    pub fn set_dt(&mut self, value: u8) {
        self.bits.set_range(28u8..30u8, value as u32);
    }
    # [ doc = "Bits 24:27 - Date units or day in BCD format" ]
    pub fn set_du(&mut self, value: u8) {
        self.bits.set_range(24u8..28u8, value as u32);
    }
    # [ doc = "Bit 23 - Alarm A hours mask" ]
    pub fn set_msk3(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 22 - AM/PM notation" ]
    pub fn set_pm(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bits 20:21 - Hour tens in BCD format" ]
    pub fn set_ht(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 16:19 - Hour units in BCD format" ]
    pub fn set_hu(&mut self, value: u8) {
        self.bits.set_range(16u8..20u8, value as u32);
    }
    # [ doc = "Bit 15 - Alarm A minutes mask" ]
    pub fn set_msk2(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 12:14 - Minute tens in BCD format" ]
    pub fn set_mnt(&mut self, value: u8) {
        self.bits.set_range(12u8..15u8, value as u32);
    }
    # [ doc = "Bits 8:11 - Minute units in BCD format" ]
    pub fn set_mnu(&mut self, value: u8) {
        self.bits.set_range(8u8..12u8, value as u32);
    }
    # [ doc = "Bit 7 - Alarm A seconds mask" ]
    pub fn set_msk1(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bits 4:6 - Second tens in BCD format" ]
    pub fn set_st(&mut self, value: u8) {
        self.bits.set_range(4u8..7u8, value as u32);
    }
    # [ doc = "Bits 0:3 - Second units in BCD format" ]
    pub fn set_su(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Alrmbr {
    bits: u32,
}

impl Alrmbr {
    # [ doc = "Bit 31 - Alarm B date mask" ]
    pub fn msk4(&self) -> bool {
        self.bits.get_bit(31u8)
    }
    # [ doc = "Bit 30 - Week day selection" ]
    pub fn wdsel(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bits 28:29 - Date tens in BCD format" ]
    pub fn dt(&self) -> u8 {
        self.bits.get_range(28u8..30u8) as u8
    }
    # [ doc = "Bits 24:27 - Date units or day in BCD format" ]
    pub fn du(&self) -> u8 {
        self.bits.get_range(24u8..28u8) as u8
    }
    # [ doc = "Bit 23 - Alarm B hours mask" ]
    pub fn msk3(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bit 22 - AM/PM notation" ]
    pub fn pm(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bits 20:21 - Hour tens in BCD format" ]
    pub fn ht(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 16:19 - Hour units in BCD format" ]
    pub fn hu(&self) -> u8 {
        self.bits.get_range(16u8..20u8) as u8
    }
    # [ doc = "Bit 15 - Alarm B minutes mask" ]
    pub fn msk2(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bits 12:14 - Minute tens in BCD format" ]
    pub fn mnt(&self) -> u8 {
        self.bits.get_range(12u8..15u8) as u8
    }
    # [ doc = "Bits 8:11 - Minute units in BCD format" ]
    pub fn mnu(&self) -> u8 {
        self.bits.get_range(8u8..12u8) as u8
    }
    # [ doc = "Bit 7 - Alarm B seconds mask" ]
    pub fn msk1(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bits 4:6 - Second tens in BCD format" ]
    pub fn st(&self) -> u8 {
        self.bits.get_range(4u8..7u8) as u8
    }
    # [ doc = "Bits 0:3 - Second units in BCD format" ]
    pub fn su(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
}

impl Default for Alrmbr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Alrmbr { bits: 0u32 }
    }
}

impl Alrmbr {
    # [ doc = "Bit 31 - Alarm B date mask" ]
    pub fn set_msk4(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
    # [ doc = "Bit 30 - Week day selection" ]
    pub fn set_wdsel(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bits 28:29 - Date tens in BCD format" ]
    pub fn set_dt(&mut self, value: u8) {
        self.bits.set_range(28u8..30u8, value as u32);
    }
    # [ doc = "Bits 24:27 - Date units or day in BCD format" ]
    pub fn set_du(&mut self, value: u8) {
        self.bits.set_range(24u8..28u8, value as u32);
    }
    # [ doc = "Bit 23 - Alarm B hours mask" ]
    pub fn set_msk3(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 22 - AM/PM notation" ]
    pub fn set_pm(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bits 20:21 - Hour tens in BCD format" ]
    pub fn set_ht(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 16:19 - Hour units in BCD format" ]
    pub fn set_hu(&mut self, value: u8) {
        self.bits.set_range(16u8..20u8, value as u32);
    }
    # [ doc = "Bit 15 - Alarm B minutes mask" ]
    pub fn set_msk2(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 12:14 - Minute tens in BCD format" ]
    pub fn set_mnt(&mut self, value: u8) {
        self.bits.set_range(12u8..15u8, value as u32);
    }
    # [ doc = "Bits 8:11 - Minute units in BCD format" ]
    pub fn set_mnu(&mut self, value: u8) {
        self.bits.set_range(8u8..12u8, value as u32);
    }
    # [ doc = "Bit 7 - Alarm B seconds mask" ]
    pub fn set_msk1(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bits 4:6 - Second tens in BCD format" ]
    pub fn set_st(&mut self, value: u8) {
        self.bits.set_range(4u8..7u8, value as u32);
    }
    # [ doc = "Bits 0:3 - Second units in BCD format" ]
    pub fn set_su(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Wpr {
    bits: u32,
}

impl Wpr {
    # [ doc = "Bits 0:7 - Write protection key" ]
    pub fn key(&self) -> u8 {
        self.bits.get_range(0u8..8u8) as u8
    }
}

impl Default for Wpr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Wpr { bits: 0u32 }
    }
}

impl Wpr {
    # [ doc = "Bits 0:7 - Write protection key" ]
    pub fn set_key(&mut self, value: u8) {
        self.bits.set_range(0u8..8u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ssr {
    bits: u32,
}

impl Ssr {
    # [ doc = "Bits 0:15 - Sub second value" ]
    pub fn ss(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for Ssr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ssr { bits: 0u32 }
    }
}

impl Ssr {
    # [ doc = "Bits 0:15 - Sub second value" ]
    pub fn set_ss(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Shiftr {
    bits: u32,
}

impl Shiftr {
    # [ doc = "Bit 31 - Add one second" ]
    pub fn add1s(&self) -> bool {
        self.bits.get_bit(31u8)
    }
    # [ doc = "Bits 0:14 - Subtract a fraction of a second" ]
    pub fn subfs(&self) -> u16 {
        self.bits.get_range(0u8..15u8) as u16
    }
}

impl Default for Shiftr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Shiftr { bits: 0u32 }
    }
}

impl Shiftr {
    # [ doc = "Bit 31 - Add one second" ]
    pub fn set_add1s(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
    # [ doc = "Bits 0:14 - Subtract a fraction of a second" ]
    pub fn set_subfs(&mut self, value: u16) {
        self.bits.set_range(0u8..15u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Tstr {
    bits: u32,
}

impl Tstr {
    # [ doc = "Bits 0:3 - Second units in BCD format" ]
    pub fn su(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
    # [ doc = "Bits 4:6 - Second tens in BCD format" ]
    pub fn st(&self) -> u8 {
        self.bits.get_range(4u8..7u8) as u8
    }
    # [ doc = "Bits 8:11 - Minute units in BCD format" ]
    pub fn mnu(&self) -> u8 {
        self.bits.get_range(8u8..12u8) as u8
    }
    # [ doc = "Bits 12:14 - Minute tens in BCD format" ]
    pub fn mnt(&self) -> u8 {
        self.bits.get_range(12u8..15u8) as u8
    }
    # [ doc = "Bits 16:19 - Hour units in BCD format" ]
    pub fn hu(&self) -> u8 {
        self.bits.get_range(16u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Hour tens in BCD format" ]
    pub fn ht(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bit 22 - AM/PM notation" ]
    pub fn pm(&self) -> bool {
        self.bits.get_bit(22u8)
    }
}

impl Default for Tstr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Tstr { bits: 0u32 }
    }
}

impl Tstr {
    # [ doc = "Bits 0:3 - Second units in BCD format" ]
    pub fn set_su(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
    # [ doc = "Bits 4:6 - Second tens in BCD format" ]
    pub fn set_st(&mut self, value: u8) {
        self.bits.set_range(4u8..7u8, value as u32);
    }
    # [ doc = "Bits 8:11 - Minute units in BCD format" ]
    pub fn set_mnu(&mut self, value: u8) {
        self.bits.set_range(8u8..12u8, value as u32);
    }
    # [ doc = "Bits 12:14 - Minute tens in BCD format" ]
    pub fn set_mnt(&mut self, value: u8) {
        self.bits.set_range(12u8..15u8, value as u32);
    }
    # [ doc = "Bits 16:19 - Hour units in BCD format" ]
    pub fn set_hu(&mut self, value: u8) {
        self.bits.set_range(16u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Hour tens in BCD format" ]
    pub fn set_ht(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bit 22 - AM/PM notation" ]
    pub fn set_pm(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Tsdr {
    bits: u32,
}

impl Tsdr {
    # [ doc = "Bits 13:15 - Week day units" ]
    pub fn wdu(&self) -> u8 {
        self.bits.get_range(13u8..16u8) as u8
    }
    # [ doc = "Bit 12 - Month tens in BCD format" ]
    pub fn mt(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bits 8:11 - Month units in BCD format" ]
    pub fn mu(&self) -> u8 {
        self.bits.get_range(8u8..12u8) as u8
    }
    # [ doc = "Bits 4:5 - Date tens in BCD format" ]
    pub fn dt(&self) -> u8 {
        self.bits.get_range(4u8..6u8) as u8
    }
    # [ doc = "Bits 0:3 - Date units in BCD format" ]
    pub fn du(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
}

impl Default for Tsdr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Tsdr { bits: 0u32 }
    }
}

impl Tsdr {
    # [ doc = "Bits 13:15 - Week day units" ]
    pub fn set_wdu(&mut self, value: u8) {
        self.bits.set_range(13u8..16u8, value as u32);
    }
    # [ doc = "Bit 12 - Month tens in BCD format" ]
    pub fn set_mt(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bits 8:11 - Month units in BCD format" ]
    pub fn set_mu(&mut self, value: u8) {
        self.bits.set_range(8u8..12u8, value as u32);
    }
    # [ doc = "Bits 4:5 - Date tens in BCD format" ]
    pub fn set_dt(&mut self, value: u8) {
        self.bits.set_range(4u8..6u8, value as u32);
    }
    # [ doc = "Bits 0:3 - Date units in BCD format" ]
    pub fn set_du(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Tsssr {
    bits: u32,
}

impl Tsssr {
    # [ doc = "Bits 0:15 - Sub second value" ]
    pub fn ss(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for Tsssr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Tsssr { bits: 0u32 }
    }
}

impl Tsssr {
    # [ doc = "Bits 0:15 - Sub second value" ]
    pub fn set_ss(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Calr {
    bits: u32,
}

impl Calr {
    # [ doc = "Bit 15 - Increase frequency of RTC by 488.5 ppm" ]
    pub fn calp(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 14 - Use an 8-second calibration cycle period" ]
    pub fn calw8(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 13 - Use a 16-second calibration cycle period" ]
    pub fn calw16(&self) -> bool {
        self.bits.get_bit(13u8)
    }
    # [ doc = "Bits 0:8 - Calibration minus" ]
    pub fn calm(&self) -> u16 {
        self.bits.get_range(0u8..9u8) as u16
    }
}

impl Default for Calr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Calr { bits: 0u32 }
    }
}

impl Calr {
    # [ doc = "Bit 15 - Increase frequency of RTC by 488.5 ppm" ]
    pub fn set_calp(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 14 - Use an 8-second calibration cycle period" ]
    pub fn set_calw8(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 13 - Use a 16-second calibration cycle period" ]
    pub fn set_calw16(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
    # [ doc = "Bits 0:8 - Calibration minus" ]
    pub fn set_calm(&mut self, value: u16) {
        self.bits.set_range(0u8..9u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Tampcr {
    bits: u32,
}

impl Tampcr {
    # [ doc = "Bit 0 - Tamper 1 detection enable" ]
    pub fn tamp1e(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Active level for tamper 1" ]
    pub fn tamp1trg(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - Tamper interrupt enable" ]
    pub fn tampie(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - Tamper 2 detection enable" ]
    pub fn tamp2e(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - Active level for tamper 2" ]
    pub fn tamp2trg(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - Tamper 3 detection enable" ]
    pub fn tamp3e(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Active level for tamper 3" ]
    pub fn tamp3trg(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Activate timestamp on tamper detection event" ]
    pub fn tampts(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bits 8:10 - Tamper sampling frequency" ]
    pub fn tampfreq(&self) -> u8 {
        self.bits.get_range(8u8..11u8) as u8
    }
    # [ doc = "Bits 11:12 - Tamper filter count" ]
    pub fn tampflt(&self) -> u8 {
        self.bits.get_range(11u8..13u8) as u8
    }
    # [ doc = "Bits 13:14 - Tamper precharge duration" ]
    pub fn tampprch(&self) -> u8 {
        self.bits.get_range(13u8..15u8) as u8
    }
    # [ doc = "Bit 15 - TAMPER pull-up disable" ]
    pub fn tamppudis(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 16 - Tamper 1 interrupt enable" ]
    pub fn tamp1ie(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - Tamper 1 no erase" ]
    pub fn tamp1noerase(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bit 18 - Tamper 1 mask flag" ]
    pub fn tamp1mf(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 19 - Tamper 2 interrupt enable" ]
    pub fn tamp2ie(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 20 - Tamper 2 no erase" ]
    pub fn tamp2noerase(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 21 - Tamper 2 mask flag" ]
    pub fn tamp2mf(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 22 - Tamper 3 interrupt enable" ]
    pub fn tamp3ie(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bit 23 - Tamper 3 no erase" ]
    pub fn tamp3noerase(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bit 24 - Tamper 3 mask flag" ]
    pub fn tamp3mf(&self) -> bool {
        self.bits.get_bit(24u8)
    }
}

impl Default for Tampcr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Tampcr { bits: 0u32 }
    }
}

impl Tampcr {
    # [ doc = "Bit 0 - Tamper 1 detection enable" ]
    pub fn set_tamp1e(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Active level for tamper 1" ]
    pub fn set_tamp1trg(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - Tamper interrupt enable" ]
    pub fn set_tampie(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - Tamper 2 detection enable" ]
    pub fn set_tamp2e(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - Active level for tamper 2" ]
    pub fn set_tamp2trg(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - Tamper 3 detection enable" ]
    pub fn set_tamp3e(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Active level for tamper 3" ]
    pub fn set_tamp3trg(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Activate timestamp on tamper detection event" ]
    pub fn set_tampts(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bits 8:10 - Tamper sampling frequency" ]
    pub fn set_tampfreq(&mut self, value: u8) {
        self.bits.set_range(8u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:12 - Tamper filter count" ]
    pub fn set_tampflt(&mut self, value: u8) {
        self.bits.set_range(11u8..13u8, value as u32);
    }
    # [ doc = "Bits 13:14 - Tamper precharge duration" ]
    pub fn set_tampprch(&mut self, value: u8) {
        self.bits.set_range(13u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - TAMPER pull-up disable" ]
    pub fn set_tamppudis(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 16 - Tamper 1 interrupt enable" ]
    pub fn set_tamp1ie(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 17 - Tamper 1 no erase" ]
    pub fn set_tamp1noerase(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bit 18 - Tamper 1 mask flag" ]
    pub fn set_tamp1mf(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 19 - Tamper 2 interrupt enable" ]
    pub fn set_tamp2ie(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 20 - Tamper 2 no erase" ]
    pub fn set_tamp2noerase(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 21 - Tamper 2 mask flag" ]
    pub fn set_tamp2mf(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 22 - Tamper 3 interrupt enable" ]
    pub fn set_tamp3ie(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 23 - Tamper 3 no erase" ]
    pub fn set_tamp3noerase(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 24 - Tamper 3 mask flag" ]
    pub fn set_tamp3mf(&mut self, value: bool) {
        self.bits.set_bit(24u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Alrmassr {
    bits: u32,
}

impl Alrmassr {
    # [ doc = "Bits 24:27 - Mask the most-significant bits starting at this bit" ]
    pub fn maskss(&self) -> u8 {
        self.bits.get_range(24u8..28u8) as u8
    }
    # [ doc = "Bits 0:14 - Sub seconds value" ]
    pub fn ss(&self) -> u16 {
        self.bits.get_range(0u8..15u8) as u16
    }
}

impl Default for Alrmassr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Alrmassr { bits: 0u32 }
    }
}

impl Alrmassr {
    # [ doc = "Bits 24:27 - Mask the most-significant bits starting at this bit" ]
    pub fn set_maskss(&mut self, value: u8) {
        self.bits.set_range(24u8..28u8, value as u32);
    }
    # [ doc = "Bits 0:14 - Sub seconds value" ]
    pub fn set_ss(&mut self, value: u16) {
        self.bits.set_range(0u8..15u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Alrmbssr {
    bits: u32,
}

impl Alrmbssr {
    # [ doc = "Bits 24:27 - Mask the most-significant bits starting at this bit" ]
    pub fn maskss(&self) -> u8 {
        self.bits.get_range(24u8..28u8) as u8
    }
    # [ doc = "Bits 0:14 - Sub seconds value" ]
    pub fn ss(&self) -> u16 {
        self.bits.get_range(0u8..15u8) as u16
    }
}

impl Default for Alrmbssr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Alrmbssr { bits: 0u32 }
    }
}

impl Alrmbssr {
    # [ doc = "Bits 24:27 - Mask the most-significant bits starting at this bit" ]
    pub fn set_maskss(&mut self, value: u8) {
        self.bits.set_range(24u8..28u8, value as u32);
    }
    # [ doc = "Bits 0:14 - Sub seconds value" ]
    pub fn set_ss(&mut self, value: u16) {
        self.bits.set_range(0u8..15u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Or {
    bits: u32,
}

impl Or {
    # [ doc = "Bit 0 - RTC_ALARM on PC13 output type" ]
    pub fn rtc_alarm_type(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - RTC_OUT remap" ]
    pub fn rtc_out_rmp(&self) -> bool {
        self.bits.get_bit(1u8)
    }
}

impl Default for Or {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Or { bits: 0u32 }
    }
}

impl Or {
    # [ doc = "Bit 0 - RTC_ALARM on PC13 output type" ]
    pub fn set_rtc_alarm_type(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - RTC_OUT remap" ]
    pub fn set_rtc_out_rmp(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp0r {
    bits: u32,
}

impl Bkp0r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp0r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp0r { bits: 0u32 }
    }
}

impl Bkp0r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp1r {
    bits: u32,
}

impl Bkp1r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp1r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp1r { bits: 0u32 }
    }
}

impl Bkp1r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp2r {
    bits: u32,
}

impl Bkp2r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp2r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp2r { bits: 0u32 }
    }
}

impl Bkp2r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp3r {
    bits: u32,
}

impl Bkp3r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp3r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp3r { bits: 0u32 }
    }
}

impl Bkp3r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp4r {
    bits: u32,
}

impl Bkp4r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp4r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp4r { bits: 0u32 }
    }
}

impl Bkp4r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp5r {
    bits: u32,
}

impl Bkp5r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp5r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp5r { bits: 0u32 }
    }
}

impl Bkp5r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp6r {
    bits: u32,
}

impl Bkp6r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp6r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp6r { bits: 0u32 }
    }
}

impl Bkp6r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp7r {
    bits: u32,
}

impl Bkp7r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp7r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp7r { bits: 0u32 }
    }
}

impl Bkp7r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp8r {
    bits: u32,
}

impl Bkp8r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp8r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp8r { bits: 0u32 }
    }
}

impl Bkp8r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp9r {
    bits: u32,
}

impl Bkp9r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp9r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp9r { bits: 0u32 }
    }
}

impl Bkp9r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp10r {
    bits: u32,
}

impl Bkp10r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp10r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp10r { bits: 0u32 }
    }
}

impl Bkp10r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp11r {
    bits: u32,
}

impl Bkp11r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp11r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp11r { bits: 0u32 }
    }
}

impl Bkp11r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp12r {
    bits: u32,
}

impl Bkp12r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp12r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp12r { bits: 0u32 }
    }
}

impl Bkp12r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp13r {
    bits: u32,
}

impl Bkp13r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp13r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp13r { bits: 0u32 }
    }
}

impl Bkp13r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp14r {
    bits: u32,
}

impl Bkp14r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp14r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp14r { bits: 0u32 }
    }
}

impl Bkp14r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp15r {
    bits: u32,
}

impl Bkp15r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp15r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp15r { bits: 0u32 }
    }
}

impl Bkp15r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp16r {
    bits: u32,
}

impl Bkp16r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp16r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp16r { bits: 0u32 }
    }
}

impl Bkp16r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp17r {
    bits: u32,
}

impl Bkp17r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp17r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp17r { bits: 0u32 }
    }
}

impl Bkp17r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp18r {
    bits: u32,
}

impl Bkp18r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp18r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp18r { bits: 0u32 }
    }
}

impl Bkp18r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp19r {
    bits: u32,
}

impl Bkp19r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp19r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp19r { bits: 0u32 }
    }
}

impl Bkp19r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp20r {
    bits: u32,
}

impl Bkp20r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp20r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp20r { bits: 0u32 }
    }
}

impl Bkp20r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp21r {
    bits: u32,
}

impl Bkp21r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp21r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp21r { bits: 0u32 }
    }
}

impl Bkp21r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp22r {
    bits: u32,
}

impl Bkp22r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp22r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp22r { bits: 0u32 }
    }
}

impl Bkp22r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp23r {
    bits: u32,
}

impl Bkp23r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp23r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp23r { bits: 0u32 }
    }
}

impl Bkp23r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp24r {
    bits: u32,
}

impl Bkp24r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp24r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp24r { bits: 0u32 }
    }
}

impl Bkp24r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp25r {
    bits: u32,
}

impl Bkp25r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp25r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp25r { bits: 0u32 }
    }
}

impl Bkp25r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp26r {
    bits: u32,
}

impl Bkp26r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp26r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp26r { bits: 0u32 }
    }
}

impl Bkp26r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp27r {
    bits: u32,
}

impl Bkp27r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp27r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp27r { bits: 0u32 }
    }
}

impl Bkp27r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp28r {
    bits: u32,
}

impl Bkp28r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp28r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp28r { bits: 0u32 }
    }
}

impl Bkp28r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp29r {
    bits: u32,
}

impl Bkp29r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp29r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp29r { bits: 0u32 }
    }
}

impl Bkp29r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp30r {
    bits: u32,
}

impl Bkp30r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp30r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp30r { bits: 0u32 }
    }
}

impl Bkp30r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bkp31r {
    bits: u32,
}

impl Bkp31r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn bkp(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bkp31r {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bkp31r { bits: 0u32 }
    }
}

impl Bkp31r {
    # [ doc = "Bits 0:31 - BKP" ]
    pub fn set_bkp(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}
