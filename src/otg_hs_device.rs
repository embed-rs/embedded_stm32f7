// autogenerated

use volatile;
use bit_field::BitField;

# [ doc = "USB on the go high speed" ]
# [ repr ( C ) ]
pub struct OtgHsDevice {
    # [ doc = "0x00 - OTG_HS device configuration register" ]
    pub otg_hs_dcfg: volatile::ReadWrite<OtgHsDcfg>,
    # [ doc = "0x04 - OTG_HS device control register" ]
    pub otg_hs_dctl: volatile::ReadWrite<OtgHsDctl>,
    # [ doc = "0x08 - OTG_HS device status register" ]
    pub otg_hs_dsts: volatile::ReadOnly<OtgHsDsts>,
    _reserved0: [u8; 4usize],
    # [ doc = "0x10 - OTG_HS device IN endpoint common interrupt mask register" ]
    pub otg_hs_diepmsk: volatile::ReadWrite<OtgHsDiepmsk>,
    # [ doc = "0x14 - OTG_HS device OUT endpoint common interrupt mask register" ]
    pub otg_hs_doepmsk: volatile::ReadWrite<OtgHsDoepmsk>,
    # [ doc = "0x18 - OTG_HS device all endpoints interrupt register" ]
    pub otg_hs_daint: volatile::ReadOnly<OtgHsDaint>,
    # [ doc = "0x1c - OTG_HS all endpoints interrupt mask register" ]
    pub otg_hs_daintmsk: volatile::ReadWrite<OtgHsDaintmsk>,
    _reserved1: [u8; 8usize],
    # [ doc = "0x28 - OTG_HS device VBUS discharge time register" ]
    pub otg_hs_dvbusdis: volatile::ReadWrite<OtgHsDvbusdis>,
    # [ doc = "0x2c - OTG_HS device VBUS pulsing time register" ]
    pub otg_hs_dvbuspulse: volatile::ReadWrite<OtgHsDvbuspulse>,
    # [ doc = "0x30 - OTG_HS Device threshold control register" ]
    pub otg_hs_dthrctl: volatile::ReadWrite<OtgHsDthrctl>,
    # [ doc = "0x34 - OTG_HS device IN endpoint FIFO empty interrupt mask register" ]
    pub otg_hs_diepempmsk: volatile::ReadWrite<OtgHsDiepempmsk>,
    # [ doc = "0x38 - OTG_HS device each endpoint interrupt register" ]
    pub otg_hs_deachint: volatile::ReadWrite<OtgHsDeachint>,
    # [ doc = "0x3c - OTG_HS device each endpoint interrupt register mask" ]
    pub otg_hs_deachintmsk: volatile::ReadWrite<OtgHsDeachintmsk>,
    _reserved2: [u8; 192usize],
    # [ doc = "0x100 - OTG device endpoint-0 control register" ]
    pub otg_hs_diepctl0: volatile::ReadWrite<OtgHsDiepctl0>,
    _reserved3: [u8; 4usize],
    # [ doc = "0x108 - OTG device endpoint-0 interrupt register" ]
    pub otg_hs_diepint0: volatile::ReadWrite<OtgHsDiepint0>,
    _reserved4: [u8; 4usize],
    # [ doc = "0x110 - OTG_HS device IN endpoint 0 transfer size register" ]
    pub otg_hs_dieptsiz0: volatile::ReadWrite<OtgHsDieptsiz0>,
    # [ doc = "0x114 - OTG_HS device endpoint-1 DMA address register" ]
    pub otg_hs_diepdma1: volatile::ReadWrite<OtgHsDiepdma1>,
    # [ doc = "0x118 - OTG_HS device IN endpoint transmit FIFO status register" ]
    pub otg_hs_dtxfsts0: volatile::ReadOnly<OtgHsDtxfsts0>,
    _reserved5: [u8; 4usize],
    # [ doc = "0x120 - OTG device endpoint-1 control register" ]
    pub otg_hs_diepctl1: volatile::ReadWrite<OtgHsDiepctl1>,
    _reserved6: [u8; 4usize],
    # [ doc = "0x128 - OTG device endpoint-1 interrupt register" ]
    pub otg_hs_diepint1: volatile::ReadWrite<OtgHsDiepint1>,
    _reserved7: [u8; 4usize],
    # [ doc = "0x130 - OTG_HS device endpoint transfer size register" ]
    pub otg_hs_dieptsiz1: volatile::ReadWrite<OtgHsDieptsiz1>,
    # [ doc = "0x134 - OTG_HS device endpoint-2 DMA address register" ]
    pub otg_hs_diepdma2: volatile::ReadWrite<OtgHsDiepdma2>,
    # [ doc = "0x138 - OTG_HS device IN endpoint transmit FIFO status register" ]
    pub otg_hs_dtxfsts1: volatile::ReadOnly<OtgHsDtxfsts1>,
    _reserved8: [u8; 4usize],
    # [ doc = "0x140 - OTG device endpoint-2 control register" ]
    pub otg_hs_diepctl2: volatile::ReadWrite<OtgHsDiepctl2>,
    _reserved9: [u8; 4usize],
    # [ doc = "0x148 - OTG device endpoint-2 interrupt register" ]
    pub otg_hs_diepint2: volatile::ReadWrite<OtgHsDiepint2>,
    _reserved10: [u8; 4usize],
    # [ doc = "0x150 - OTG_HS device endpoint transfer size register" ]
    pub otg_hs_dieptsiz2: volatile::ReadWrite<OtgHsDieptsiz2>,
    # [ doc = "0x154 - OTG_HS device endpoint-3 DMA address register" ]
    pub otg_hs_diepdma3: volatile::ReadWrite<OtgHsDiepdma3>,
    # [ doc = "0x158 - OTG_HS device IN endpoint transmit FIFO status register" ]
    pub otg_hs_dtxfsts2: volatile::ReadOnly<OtgHsDtxfsts2>,
    _reserved11: [u8; 4usize],
    # [ doc = "0x160 - OTG device endpoint-3 control register" ]
    pub otg_hs_diepctl3: volatile::ReadWrite<OtgHsDiepctl3>,
    _reserved12: [u8; 4usize],
    # [ doc = "0x168 - OTG device endpoint-3 interrupt register" ]
    pub otg_hs_diepint3: volatile::ReadWrite<OtgHsDiepint3>,
    _reserved13: [u8; 4usize],
    # [ doc = "0x170 - OTG_HS device endpoint transfer size register" ]
    pub otg_hs_dieptsiz3: volatile::ReadWrite<OtgHsDieptsiz3>,
    # [ doc = "0x174 - OTG_HS device endpoint-4 DMA address register" ]
    pub otg_hs_diepdma4: volatile::ReadWrite<OtgHsDiepdma4>,
    # [ doc = "0x178 - OTG_HS device IN endpoint transmit FIFO status register" ]
    pub otg_hs_dtxfsts3: volatile::ReadOnly<OtgHsDtxfsts3>,
    _reserved14: [u8; 4usize],
    # [ doc = "0x180 - OTG device endpoint-4 control register" ]
    pub otg_hs_diepctl4: volatile::ReadWrite<OtgHsDiepctl4>,
    _reserved15: [u8; 4usize],
    # [ doc = "0x188 - OTG device endpoint-4 interrupt register" ]
    pub otg_hs_diepint4: volatile::ReadWrite<OtgHsDiepint4>,
    _reserved16: [u8; 4usize],
    # [ doc = "0x190 - OTG_HS device endpoint transfer size register" ]
    pub otg_hs_dieptsiz4: volatile::ReadWrite<OtgHsDieptsiz4>,
    # [ doc = "0x194 - OTG_HS device endpoint-5 DMA address register" ]
    pub otg_hs_diepdma5: volatile::ReadWrite<OtgHsDiepdma5>,
    # [ doc = "0x198 - OTG_HS device IN endpoint transmit FIFO status register" ]
    pub otg_hs_dtxfsts4: volatile::ReadOnly<OtgHsDtxfsts4>,
    _reserved17: [u8; 4usize],
    # [ doc = "0x1a0 - OTG device endpoint-5 control register" ]
    pub otg_hs_diepctl5: volatile::ReadWrite<OtgHsDiepctl5>,
    _reserved18: [u8; 4usize],
    # [ doc = "0x1a8 - OTG device endpoint-5 interrupt register" ]
    pub otg_hs_diepint5: volatile::ReadWrite<OtgHsDiepint5>,
    _reserved19: [u8; 4usize],
    # [ doc = "0x1b0 - OTG_HS device endpoint transfer size register" ]
    pub otg_hs_dieptsiz5: volatile::ReadWrite<OtgHsDieptsiz5>,
    _reserved20: [u8; 4usize],
    # [ doc = "0x1b8 - OTG_HS device IN endpoint transmit FIFO status register" ]
    pub otg_hs_dtxfsts5: volatile::ReadOnly<OtgHsDtxfsts5>,
    _reserved21: [u8; 4usize],
    # [ doc = "0x1c0 - OTG device endpoint-6 control register" ]
    pub otg_hs_diepctl6: volatile::ReadWrite<OtgHsDiepctl6>,
    _reserved22: [u8; 4usize],
    # [ doc = "0x1c8 - OTG device endpoint-6 interrupt register" ]
    pub otg_hs_diepint6: volatile::ReadWrite<OtgHsDiepint6>,
    _reserved23: [u8; 4usize],
    # [ doc = "0x1d0 - OTG_HS device endpoint transfer size register" ]
    pub otg_hs_dieptsiz6: volatile::ReadWrite<OtgHsDieptsiz6>,
    _reserved24: [u8; 4usize],
    # [ doc = "0x1d8 - OTG_HS device IN endpoint transmit FIFO status register" ]
    pub otg_hs_dtxfsts6: volatile::ReadWrite<OtgHsDtxfsts6>,
    _reserved25: [u8; 4usize],
    # [ doc = "0x1e0 - OTG device endpoint-7 control register" ]
    pub otg_hs_diepctl7: volatile::ReadWrite<OtgHsDiepctl7>,
    _reserved26: [u8; 4usize],
    # [ doc = "0x1e8 - OTG device endpoint-7 interrupt register" ]
    pub otg_hs_diepint7: volatile::ReadWrite<OtgHsDiepint7>,
    _reserved27: [u8; 4usize],
    # [ doc = "0x1f0 - OTG_HS device endpoint transfer size register" ]
    pub otg_hs_dieptsiz7: volatile::ReadWrite<OtgHsDieptsiz7>,
    _reserved28: [u8; 4usize],
    # [ doc = "0x1f8 - OTG_HS device IN endpoint transmit FIFO status register" ]
    pub otg_hs_dtxfsts7: volatile::ReadWrite<OtgHsDtxfsts7>,
    _reserved29: [u8; 260usize],
    # [ doc = "0x300 - OTG_HS device control OUT endpoint 0 control register" ]
    pub otg_hs_doepctl0: volatile::ReadWrite<OtgHsDoepctl0>,
    _reserved30: [u8; 4usize],
    # [ doc = "0x308 - OTG_HS device endpoint-0 interrupt register" ]
    pub otg_hs_doepint0: volatile::ReadWrite<OtgHsDoepint0>,
    _reserved31: [u8; 4usize],
    # [ doc = "0x310 - OTG_HS device endpoint-0 transfer size register" ]
    pub otg_hs_doeptsiz0: volatile::ReadWrite<OtgHsDoeptsiz0>,
    _reserved32: [u8; 12usize],
    # [ doc = "0x320 - OTG device endpoint-1 control register" ]
    pub otg_hs_doepctl1: volatile::ReadWrite<OtgHsDoepctl1>,
    _reserved33: [u8; 4usize],
    # [ doc = "0x328 - OTG_HS device endpoint-1 interrupt register" ]
    pub otg_hs_doepint1: volatile::ReadWrite<OtgHsDoepint1>,
    _reserved34: [u8; 4usize],
    # [ doc = "0x330 - OTG_HS device endpoint-1 transfer size register" ]
    pub otg_hs_doeptsiz1: volatile::ReadWrite<OtgHsDoeptsiz1>,
    _reserved35: [u8; 12usize],
    # [ doc = "0x340 - OTG device endpoint-2 control register" ]
    pub otg_hs_doepctl2: volatile::ReadWrite<OtgHsDoepctl2>,
    _reserved36: [u8; 4usize],
    # [ doc = "0x348 - OTG_HS device endpoint-2 interrupt register" ]
    pub otg_hs_doepint2: volatile::ReadWrite<OtgHsDoepint2>,
    _reserved37: [u8; 4usize],
    # [ doc = "0x350 - OTG_HS device endpoint-2 transfer size register" ]
    pub otg_hs_doeptsiz2: volatile::ReadWrite<OtgHsDoeptsiz2>,
    _reserved38: [u8; 12usize],
    # [ doc = "0x360 - OTG device endpoint-3 control register" ]
    pub otg_hs_doepctl3: volatile::ReadWrite<OtgHsDoepctl3>,
    _reserved39: [u8; 4usize],
    # [ doc = "0x368 - OTG_HS device endpoint-3 interrupt register" ]
    pub otg_hs_doepint3: volatile::ReadWrite<OtgHsDoepint3>,
    _reserved40: [u8; 4usize],
    # [ doc = "0x370 - OTG_HS device endpoint-3 transfer size register" ]
    pub otg_hs_doeptsiz3: volatile::ReadWrite<OtgHsDoeptsiz3>,
    _reserved41: [u8; 12usize],
    # [ doc = "0x380 - OTG device endpoint-4 control register" ]
    pub otg_hs_doepctl4: volatile::ReadWrite<OtgHsDoepctl4>,
    _reserved42: [u8; 4usize],
    # [ doc = "0x388 - OTG_HS device endpoint-4 interrupt register" ]
    pub otg_hs_doepint4: volatile::ReadWrite<OtgHsDoepint4>,
    _reserved43: [u8; 4usize],
    # [ doc = "0x390 - OTG_HS device endpoint-4 transfer size register" ]
    pub otg_hs_doeptsiz4: volatile::ReadWrite<OtgHsDoeptsiz4>,
    _reserved44: [u8; 12usize],
    # [ doc = "0x3a0 - OTG device endpoint-5 control register" ]
    pub otg_hs_doepctl5: volatile::ReadWrite<OtgHsDoepctl5>,
    _reserved45: [u8; 4usize],
    # [ doc = "0x3a8 - OTG_HS device endpoint-5 interrupt register" ]
    pub otg_hs_doepint5: volatile::ReadWrite<OtgHsDoepint5>,
    _reserved46: [u8; 4usize],
    # [ doc = "0x3b0 - OTG_HS device endpoint-5 transfer size register" ]
    pub otg_hs_doeptsiz5: volatile::ReadWrite<OtgHsDoeptsiz5>,
    _reserved47: [u8; 12usize],
    # [ doc = "0x3c0 - OTG device endpoint-6 control register" ]
    pub otg_hs_doepctl6: volatile::ReadWrite<OtgHsDoepctl6>,
    _reserved48: [u8; 4usize],
    # [ doc = "0x3c8 - OTG_HS device endpoint-6 interrupt register" ]
    pub otg_hs_doepint6: volatile::ReadWrite<OtgHsDoepint6>,
    _reserved49: [u8; 4usize],
    # [ doc = "0x3d0 - OTG_HS device endpoint-6 transfer size register" ]
    pub otg_hs_doeptsiz6: volatile::ReadWrite<OtgHsDoeptsiz6>,
    _reserved50: [u8; 12usize],
    # [ doc = "0x3e0 - OTG device endpoint-7 control register" ]
    pub otg_hs_doepctl7: volatile::ReadWrite<OtgHsDoepctl7>,
    _reserved51: [u8; 4usize],
    # [ doc = "0x3e8 - OTG_HS device endpoint-7 interrupt register" ]
    pub otg_hs_doepint7: volatile::ReadWrite<OtgHsDoepint7>,
    _reserved52: [u8; 4usize],
    # [ doc = "0x3f0 - OTG_HS device endpoint-7 transfer size register" ]
    pub otg_hs_doeptsiz7: volatile::ReadWrite<OtgHsDoeptsiz7>,
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDcfg {
    bits: u32,
}

impl OtgHsDcfg {
    # [ doc = "Bits 0:1 - Device speed" ]
    pub fn dspd(&self) -> u8 {
        self.bits.get_range(0u8..2u8) as u8
    }
    # [ doc = "Bit 2 - Nonzero-length status OUT handshake" ]
    pub fn nzlsohsk(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bits 4:10 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(4u8..11u8) as u8
    }
    # [ doc = "Bits 11:12 - Periodic (micro)frame interval" ]
    pub fn pfivl(&self) -> u8 {
        self.bits.get_range(11u8..13u8) as u8
    }
    # [ doc = "Bits 24:25 - Periodic scheduling interval" ]
    pub fn perschivl(&self) -> u8 {
        self.bits.get_range(24u8..26u8) as u8
    }
}

impl Default for OtgHsDcfg {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDcfg { bits: 35651584u32 }
    }
}

impl OtgHsDcfg {
    # [ doc = "Bits 0:1 - Device speed" ]
    pub fn set_dspd(&mut self, value: u8) {
        self.bits.set_range(0u8..2u8, value as u32);
    }
    # [ doc = "Bit 2 - Nonzero-length status OUT handshake" ]
    pub fn set_nzlsohsk(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bits 4:10 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(4u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:12 - Periodic (micro)frame interval" ]
    pub fn set_pfivl(&mut self, value: u8) {
        self.bits.set_range(11u8..13u8, value as u32);
    }
    # [ doc = "Bits 24:25 - Periodic scheduling interval" ]
    pub fn set_perschivl(&mut self, value: u8) {
        self.bits.set_range(24u8..26u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDctl {
    bits: u32,
}

impl OtgHsDctl {
    # [ doc = "Bit 0 - Remote wakeup signaling" ]
    pub fn rwusig(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Soft disconnect" ]
    pub fn sdis(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - Global IN NAK status" ]
    pub fn ginsts(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - Global OUT NAK status" ]
    pub fn gonsts(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bits 4:6 - Test control" ]
    pub fn tctl(&self) -> u8 {
        self.bits.get_range(4u8..7u8) as u8
    }
    # [ doc = "Bit 11 - Power-on programming done" ]
    pub fn poprgdne(&self) -> bool {
        self.bits.get_bit(11u8)
    }
}

impl Default for OtgHsDctl {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDctl { bits: 0u32 }
    }
}

impl OtgHsDctl {
    # [ doc = "Bit 0 - Remote wakeup signaling" ]
    pub fn set_rwusig(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Soft disconnect" ]
    pub fn set_sdis(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bits 4:6 - Test control" ]
    pub fn set_tctl(&mut self, value: u8) {
        self.bits.set_range(4u8..7u8, value as u32);
    }
    # [ doc = "Bit 7 - Set global IN NAK" ]
    pub fn set_sginak(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Clear global IN NAK" ]
    pub fn set_cginak(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Set global OUT NAK" ]
    pub fn set_sgonak(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Clear global OUT NAK" ]
    pub fn set_cgonak(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 11 - Power-on programming done" ]
    pub fn set_poprgdne(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDsts {
    bits: u32,
}

impl OtgHsDsts {
    # [ doc = "Bit 0 - Suspend status" ]
    pub fn suspsts(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bits 1:2 - Enumerated speed" ]
    pub fn enumspd(&self) -> u8 {
        self.bits.get_range(1u8..3u8) as u8
    }
    # [ doc = "Bit 3 - Erratic error" ]
    pub fn eerr(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bits 8:21 - Frame number of the received SOF" ]
    pub fn fnsof(&self) -> u16 {
        self.bits.get_range(8u8..22u8) as u16
    }
}

impl Default for OtgHsDsts {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDsts { bits: 16u32 }
    }
}

impl OtgHsDsts {
    # [ doc = "Bit 0 - Suspend status" ]
    pub fn set_suspsts(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bits 1:2 - Enumerated speed" ]
    pub fn set_enumspd(&mut self, value: u8) {
        self.bits.set_range(1u8..3u8, value as u32);
    }
    # [ doc = "Bit 3 - Erratic error" ]
    pub fn set_eerr(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bits 8:21 - Frame number of the received SOF" ]
    pub fn set_fnsof(&mut self, value: u16) {
        self.bits.set_range(8u8..22u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDiepmsk {
    bits: u32,
}

impl OtgHsDiepmsk {
    # [ doc = "Bit 0 - Transfer completed interrupt mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt mask" ]
    pub fn epdm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - Timeout condition mask (nonisochronous endpoints)" ]
    pub fn tom(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - IN token received when TxFIFO empty mask" ]
    pub fn ittxfemsk(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - IN token received with EP mismatch mask" ]
    pub fn inepnmm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - IN endpoint NAK effective mask" ]
    pub fn inepnem(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 8 - FIFO underrun mask" ]
    pub fn txfurm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - BNA interrupt mask" ]
    pub fn bim(&self) -> bool {
        self.bits.get_bit(9u8)
    }
}

impl Default for OtgHsDiepmsk {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDiepmsk { bits: 0u32 }
    }
}

impl OtgHsDiepmsk {
    # [ doc = "Bit 0 - Transfer completed interrupt mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt mask" ]
    pub fn set_epdm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - Timeout condition mask (nonisochronous endpoints)" ]
    pub fn set_tom(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - IN token received when TxFIFO empty mask" ]
    pub fn set_ittxfemsk(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - IN token received with EP mismatch mask" ]
    pub fn set_inepnmm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - IN endpoint NAK effective mask" ]
    pub fn set_inepnem(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 8 - FIFO underrun mask" ]
    pub fn set_txfurm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - BNA interrupt mask" ]
    pub fn set_bim(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoepmsk {
    bits: u32,
}

impl OtgHsDoepmsk {
    # [ doc = "Bit 0 - Transfer completed interrupt mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt mask" ]
    pub fn epdm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - SETUP phase done mask" ]
    pub fn stupm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - OUT token received when endpoint disabled mask" ]
    pub fn otepdm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 6 - Back-to-back SETUP packets received mask" ]
    pub fn b2bstup(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 8 - OUT packet error mask" ]
    pub fn opem(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - BNA interrupt mask" ]
    pub fn boim(&self) -> bool {
        self.bits.get_bit(9u8)
    }
}

impl Default for OtgHsDoepmsk {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoepmsk { bits: 0u32 }
    }
}

impl OtgHsDoepmsk {
    # [ doc = "Bit 0 - Transfer completed interrupt mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt mask" ]
    pub fn set_epdm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - SETUP phase done mask" ]
    pub fn set_stupm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - OUT token received when endpoint disabled mask" ]
    pub fn set_otepdm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 6 - Back-to-back SETUP packets received mask" ]
    pub fn set_b2bstup(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 8 - OUT packet error mask" ]
    pub fn set_opem(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - BNA interrupt mask" ]
    pub fn set_boim(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDaint {
    bits: u32,
}

impl OtgHsDaint {
    # [ doc = "Bits 0:15 - IN endpoint interrupt bits" ]
    pub fn iepint(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:31 - OUT endpoint interrupt bits" ]
    pub fn oepint(&self) -> u16 {
        self.bits.get_range(16u8..32u8) as u16
    }
}

impl Default for OtgHsDaint {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDaint { bits: 0u32 }
    }
}

impl OtgHsDaint {
    # [ doc = "Bits 0:15 - IN endpoint interrupt bits" ]
    pub fn set_iepint(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:31 - OUT endpoint interrupt bits" ]
    pub fn set_oepint(&mut self, value: u16) {
        self.bits.set_range(16u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDaintmsk {
    bits: u32,
}

impl OtgHsDaintmsk {
    # [ doc = "Bits 0:15 - IN EP interrupt mask bits" ]
    pub fn iepm(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:31 - OUT EP interrupt mask bits" ]
    pub fn oepm(&self) -> u16 {
        self.bits.get_range(16u8..32u8) as u16
    }
}

impl Default for OtgHsDaintmsk {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDaintmsk { bits: 0u32 }
    }
}

impl OtgHsDaintmsk {
    # [ doc = "Bits 0:15 - IN EP interrupt mask bits" ]
    pub fn set_iepm(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:31 - OUT EP interrupt mask bits" ]
    pub fn set_oepm(&mut self, value: u16) {
        self.bits.set_range(16u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDvbusdis {
    bits: u32,
}

impl OtgHsDvbusdis {
    # [ doc = "Bits 0:15 - Device VBUS discharge time" ]
    pub fn vbusdt(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for OtgHsDvbusdis {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDvbusdis { bits: 6103u32 }
    }
}

impl OtgHsDvbusdis {
    # [ doc = "Bits 0:15 - Device VBUS discharge time" ]
    pub fn set_vbusdt(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDvbuspulse {
    bits: u32,
}

impl OtgHsDvbuspulse {
    # [ doc = "Bits 0:11 - Device VBUS pulsing time" ]
    pub fn dvbusp(&self) -> u16 {
        self.bits.get_range(0u8..12u8) as u16
    }
}

impl Default for OtgHsDvbuspulse {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDvbuspulse { bits: 1464u32 }
    }
}

impl OtgHsDvbuspulse {
    # [ doc = "Bits 0:11 - Device VBUS pulsing time" ]
    pub fn set_dvbusp(&mut self, value: u16) {
        self.bits.set_range(0u8..12u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDthrctl {
    bits: u32,
}

impl OtgHsDthrctl {
    # [ doc = "Bit 0 - Nonisochronous IN endpoints threshold enable" ]
    pub fn nonisothren(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - ISO IN endpoint threshold enable" ]
    pub fn isothren(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bits 2:10 - Transmit threshold length" ]
    pub fn txthrlen(&self) -> u16 {
        self.bits.get_range(2u8..11u8) as u16
    }
    # [ doc = "Bit 16 - Receive threshold enable" ]
    pub fn rxthren(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bits 17:25 - Receive threshold length" ]
    pub fn rxthrlen(&self) -> u16 {
        self.bits.get_range(17u8..26u8) as u16
    }
    # [ doc = "Bit 27 - Arbiter parking enable" ]
    pub fn arpen(&self) -> bool {
        self.bits.get_bit(27u8)
    }
}

impl Default for OtgHsDthrctl {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDthrctl { bits: 0u32 }
    }
}

impl OtgHsDthrctl {
    # [ doc = "Bit 0 - Nonisochronous IN endpoints threshold enable" ]
    pub fn set_nonisothren(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - ISO IN endpoint threshold enable" ]
    pub fn set_isothren(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bits 2:10 - Transmit threshold length" ]
    pub fn set_txthrlen(&mut self, value: u16) {
        self.bits.set_range(2u8..11u8, value as u32);
    }
    # [ doc = "Bit 16 - Receive threshold enable" ]
    pub fn set_rxthren(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bits 17:25 - Receive threshold length" ]
    pub fn set_rxthrlen(&mut self, value: u16) {
        self.bits.set_range(17u8..26u8, value as u32);
    }
    # [ doc = "Bit 27 - Arbiter parking enable" ]
    pub fn set_arpen(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDiepempmsk {
    bits: u32,
}

impl OtgHsDiepempmsk {
    # [ doc = "Bits 0:15 - IN EP Tx FIFO empty interrupt mask bits" ]
    pub fn ineptxfem(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for OtgHsDiepempmsk {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDiepempmsk { bits: 0u32 }
    }
}

impl OtgHsDiepempmsk {
    # [ doc = "Bits 0:15 - IN EP Tx FIFO empty interrupt mask bits" ]
    pub fn set_ineptxfem(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDeachint {
    bits: u32,
}

impl OtgHsDeachint {
    # [ doc = "Bit 1 - IN endpoint 1interrupt bit" ]
    pub fn iep1int(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 17 - OUT endpoint 1 interrupt bit" ]
    pub fn oep1int(&self) -> bool {
        self.bits.get_bit(17u8)
    }
}

impl Default for OtgHsDeachint {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDeachint { bits: 0u32 }
    }
}

impl OtgHsDeachint {
    # [ doc = "Bit 1 - IN endpoint 1interrupt bit" ]
    pub fn set_iep1int(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 17 - OUT endpoint 1 interrupt bit" ]
    pub fn set_oep1int(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDeachintmsk {
    bits: u32,
}

impl OtgHsDeachintmsk {
    # [ doc = "Bit 1 - IN Endpoint 1 interrupt mask bit" ]
    pub fn iep1intm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 17 - OUT Endpoint 1 interrupt mask bit" ]
    pub fn oep1intm(&self) -> bool {
        self.bits.get_bit(17u8)
    }
}

impl Default for OtgHsDeachintmsk {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDeachintmsk { bits: 0u32 }
    }
}

impl OtgHsDeachintmsk {
    # [ doc = "Bit 1 - IN Endpoint 1 interrupt mask bit" ]
    pub fn set_iep1intm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 17 - OUT Endpoint 1 interrupt mask bit" ]
    pub fn set_oep1intm(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDiepctl0 {
    bits: u32,
}

impl OtgHsDiepctl0 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn usbaep(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 16 - Even/odd frame" ]
    pub fn eonum_dpid(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - NAK status" ]
    pub fn naksts(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bits 22:25 - TxFIFO number" ]
    pub fn txfnum(&self) -> u8 {
        self.bits.get_range(22u8..26u8) as u8
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn epdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn epena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsDiepctl0 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDiepctl0 { bits: 0u32 }
    }
}

impl OtgHsDiepctl0 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn set_usbaep(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bits 22:25 - TxFIFO number" ]
    pub fn set_txfnum(&mut self, value: u8) {
        self.bits.set_range(22u8..26u8, value as u32);
    }
    # [ doc = "Bit 26 - Clear NAK" ]
    pub fn set_cnak(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 27 - Set NAK" ]
    pub fn set_snak(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 28 - Set DATA0 PID" ]
    pub fn set_sd0pid_sevnfrm(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 29 - Set odd frame" ]
    pub fn set_soddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn set_epdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn set_epena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDiepint0 {
    bits: u32,
}

impl OtgHsDiepint0 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn epdisd(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - Timeout condition" ]
    pub fn toc(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - IN token received when TxFIFO is empty" ]
    pub fn ittxfe(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 6 - IN endpoint NAK effective" ]
    pub fn inepne(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transmit FIFO empty" ]
    pub fn txfe(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Transmit Fifo Underrun" ]
    pub fn txfifoudrn(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Buffer not available interrupt" ]
    pub fn bna(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 11 - Packet dropped status" ]
    pub fn pktdrpsts(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 12 - Babble error interrupt" ]
    pub fn berr(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 13 - NAK interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(13u8)
    }
}

impl Default for OtgHsDiepint0 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDiepint0 { bits: 128u32 }
    }
}

impl OtgHsDiepint0 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn set_epdisd(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - Timeout condition" ]
    pub fn set_toc(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - IN token received when TxFIFO is empty" ]
    pub fn set_ittxfe(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 6 - IN endpoint NAK effective" ]
    pub fn set_inepne(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 8 - Transmit Fifo Underrun" ]
    pub fn set_txfifoudrn(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Buffer not available interrupt" ]
    pub fn set_bna(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 11 - Packet dropped status" ]
    pub fn set_pktdrpsts(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 12 - Babble error interrupt" ]
    pub fn set_berr(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 13 - NAK interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDieptsiz0 {
    bits: u32,
}

impl OtgHsDieptsiz0 {
    # [ doc = "Bits 0:6 - Transfer size" ]
    pub fn xfrsiz(&self) -> u8 {
        self.bits.get_range(0u8..7u8) as u8
    }
    # [ doc = "Bits 19:20 - Packet count" ]
    pub fn pktcnt(&self) -> u8 {
        self.bits.get_range(19u8..21u8) as u8
    }
}

impl Default for OtgHsDieptsiz0 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDieptsiz0 { bits: 0u32 }
    }
}

impl OtgHsDieptsiz0 {
    # [ doc = "Bits 0:6 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u8) {
        self.bits.set_range(0u8..7u8, value as u32);
    }
    # [ doc = "Bits 19:20 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u8) {
        self.bits.set_range(19u8..21u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDiepdma1 {
    bits: u32,
}

impl OtgHsDiepdma1 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn dmaaddr(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for OtgHsDiepdma1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDiepdma1 { bits: 0u32 }
    }
}

impl OtgHsDiepdma1 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn set_dmaaddr(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDtxfsts0 {
    bits: u32,
}

impl OtgHsDtxfsts0 {
    # [ doc = "Bits 0:15 - IN endpoint TxFIFO space avail" ]
    pub fn ineptfsav(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for OtgHsDtxfsts0 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDtxfsts0 { bits: 0u32 }
    }
}

impl OtgHsDtxfsts0 {
    # [ doc = "Bits 0:15 - IN endpoint TxFIFO space avail" ]
    pub fn set_ineptfsav(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDiepctl1 {
    bits: u32,
}

impl OtgHsDiepctl1 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn usbaep(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 16 - Even/odd frame" ]
    pub fn eonum_dpid(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - NAK status" ]
    pub fn naksts(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bits 22:25 - TxFIFO number" ]
    pub fn txfnum(&self) -> u8 {
        self.bits.get_range(22u8..26u8) as u8
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn epdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn epena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsDiepctl1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDiepctl1 { bits: 0u32 }
    }
}

impl OtgHsDiepctl1 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn set_usbaep(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bits 22:25 - TxFIFO number" ]
    pub fn set_txfnum(&mut self, value: u8) {
        self.bits.set_range(22u8..26u8, value as u32);
    }
    # [ doc = "Bit 26 - Clear NAK" ]
    pub fn set_cnak(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 27 - Set NAK" ]
    pub fn set_snak(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 28 - Set DATA0 PID" ]
    pub fn set_sd0pid_sevnfrm(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 29 - Set odd frame" ]
    pub fn set_soddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn set_epdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn set_epena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDiepint1 {
    bits: u32,
}

impl OtgHsDiepint1 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn epdisd(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - Timeout condition" ]
    pub fn toc(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - IN token received when TxFIFO is empty" ]
    pub fn ittxfe(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 6 - IN endpoint NAK effective" ]
    pub fn inepne(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transmit FIFO empty" ]
    pub fn txfe(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Transmit Fifo Underrun" ]
    pub fn txfifoudrn(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Buffer not available interrupt" ]
    pub fn bna(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 11 - Packet dropped status" ]
    pub fn pktdrpsts(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 12 - Babble error interrupt" ]
    pub fn berr(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 13 - NAK interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(13u8)
    }
}

impl Default for OtgHsDiepint1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDiepint1 { bits: 0u32 }
    }
}

impl OtgHsDiepint1 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn set_epdisd(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - Timeout condition" ]
    pub fn set_toc(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - IN token received when TxFIFO is empty" ]
    pub fn set_ittxfe(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 6 - IN endpoint NAK effective" ]
    pub fn set_inepne(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 8 - Transmit Fifo Underrun" ]
    pub fn set_txfifoudrn(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Buffer not available interrupt" ]
    pub fn set_bna(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 11 - Packet dropped status" ]
    pub fn set_pktdrpsts(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 12 - Babble error interrupt" ]
    pub fn set_berr(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 13 - NAK interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDieptsiz1 {
    bits: u32,
}

impl OtgHsDieptsiz1 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Multi count" ]
    pub fn mcnt(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsDieptsiz1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDieptsiz1 { bits: 0u32 }
    }
}

impl OtgHsDieptsiz1 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Multi count" ]
    pub fn set_mcnt(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDiepdma2 {
    bits: u32,
}

impl OtgHsDiepdma2 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn dmaaddr(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for OtgHsDiepdma2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDiepdma2 { bits: 0u32 }
    }
}

impl OtgHsDiepdma2 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn set_dmaaddr(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDtxfsts1 {
    bits: u32,
}

impl OtgHsDtxfsts1 {
    # [ doc = "Bits 0:15 - IN endpoint TxFIFO space avail" ]
    pub fn ineptfsav(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for OtgHsDtxfsts1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDtxfsts1 { bits: 0u32 }
    }
}

impl OtgHsDtxfsts1 {
    # [ doc = "Bits 0:15 - IN endpoint TxFIFO space avail" ]
    pub fn set_ineptfsav(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDiepctl2 {
    bits: u32,
}

impl OtgHsDiepctl2 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn usbaep(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 16 - Even/odd frame" ]
    pub fn eonum_dpid(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - NAK status" ]
    pub fn naksts(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bits 22:25 - TxFIFO number" ]
    pub fn txfnum(&self) -> u8 {
        self.bits.get_range(22u8..26u8) as u8
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn epdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn epena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsDiepctl2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDiepctl2 { bits: 0u32 }
    }
}

impl OtgHsDiepctl2 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn set_usbaep(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bits 22:25 - TxFIFO number" ]
    pub fn set_txfnum(&mut self, value: u8) {
        self.bits.set_range(22u8..26u8, value as u32);
    }
    # [ doc = "Bit 26 - Clear NAK" ]
    pub fn set_cnak(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 27 - Set NAK" ]
    pub fn set_snak(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 28 - Set DATA0 PID" ]
    pub fn set_sd0pid_sevnfrm(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 29 - Set odd frame" ]
    pub fn set_soddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn set_epdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn set_epena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDiepint2 {
    bits: u32,
}

impl OtgHsDiepint2 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn epdisd(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - Timeout condition" ]
    pub fn toc(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - IN token received when TxFIFO is empty" ]
    pub fn ittxfe(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 6 - IN endpoint NAK effective" ]
    pub fn inepne(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transmit FIFO empty" ]
    pub fn txfe(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Transmit Fifo Underrun" ]
    pub fn txfifoudrn(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Buffer not available interrupt" ]
    pub fn bna(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 11 - Packet dropped status" ]
    pub fn pktdrpsts(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 12 - Babble error interrupt" ]
    pub fn berr(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 13 - NAK interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(13u8)
    }
}

impl Default for OtgHsDiepint2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDiepint2 { bits: 0u32 }
    }
}

impl OtgHsDiepint2 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn set_epdisd(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - Timeout condition" ]
    pub fn set_toc(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - IN token received when TxFIFO is empty" ]
    pub fn set_ittxfe(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 6 - IN endpoint NAK effective" ]
    pub fn set_inepne(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 8 - Transmit Fifo Underrun" ]
    pub fn set_txfifoudrn(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Buffer not available interrupt" ]
    pub fn set_bna(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 11 - Packet dropped status" ]
    pub fn set_pktdrpsts(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 12 - Babble error interrupt" ]
    pub fn set_berr(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 13 - NAK interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDieptsiz2 {
    bits: u32,
}

impl OtgHsDieptsiz2 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Multi count" ]
    pub fn mcnt(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsDieptsiz2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDieptsiz2 { bits: 0u32 }
    }
}

impl OtgHsDieptsiz2 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Multi count" ]
    pub fn set_mcnt(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDiepdma3 {
    bits: u32,
}

impl OtgHsDiepdma3 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn dmaaddr(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for OtgHsDiepdma3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDiepdma3 { bits: 0u32 }
    }
}

impl OtgHsDiepdma3 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn set_dmaaddr(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDtxfsts2 {
    bits: u32,
}

impl OtgHsDtxfsts2 {
    # [ doc = "Bits 0:15 - IN endpoint TxFIFO space avail" ]
    pub fn ineptfsav(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for OtgHsDtxfsts2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDtxfsts2 { bits: 0u32 }
    }
}

impl OtgHsDtxfsts2 {
    # [ doc = "Bits 0:15 - IN endpoint TxFIFO space avail" ]
    pub fn set_ineptfsav(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDiepctl3 {
    bits: u32,
}

impl OtgHsDiepctl3 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn usbaep(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 16 - Even/odd frame" ]
    pub fn eonum_dpid(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - NAK status" ]
    pub fn naksts(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bits 22:25 - TxFIFO number" ]
    pub fn txfnum(&self) -> u8 {
        self.bits.get_range(22u8..26u8) as u8
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn epdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn epena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsDiepctl3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDiepctl3 { bits: 0u32 }
    }
}

impl OtgHsDiepctl3 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn set_usbaep(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bits 22:25 - TxFIFO number" ]
    pub fn set_txfnum(&mut self, value: u8) {
        self.bits.set_range(22u8..26u8, value as u32);
    }
    # [ doc = "Bit 26 - Clear NAK" ]
    pub fn set_cnak(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 27 - Set NAK" ]
    pub fn set_snak(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 28 - Set DATA0 PID" ]
    pub fn set_sd0pid_sevnfrm(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 29 - Set odd frame" ]
    pub fn set_soddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn set_epdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn set_epena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDiepint3 {
    bits: u32,
}

impl OtgHsDiepint3 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn epdisd(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - Timeout condition" ]
    pub fn toc(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - IN token received when TxFIFO is empty" ]
    pub fn ittxfe(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 6 - IN endpoint NAK effective" ]
    pub fn inepne(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transmit FIFO empty" ]
    pub fn txfe(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Transmit Fifo Underrun" ]
    pub fn txfifoudrn(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Buffer not available interrupt" ]
    pub fn bna(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 11 - Packet dropped status" ]
    pub fn pktdrpsts(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 12 - Babble error interrupt" ]
    pub fn berr(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 13 - NAK interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(13u8)
    }
}

impl Default for OtgHsDiepint3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDiepint3 { bits: 0u32 }
    }
}

impl OtgHsDiepint3 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn set_epdisd(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - Timeout condition" ]
    pub fn set_toc(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - IN token received when TxFIFO is empty" ]
    pub fn set_ittxfe(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 6 - IN endpoint NAK effective" ]
    pub fn set_inepne(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 8 - Transmit Fifo Underrun" ]
    pub fn set_txfifoudrn(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Buffer not available interrupt" ]
    pub fn set_bna(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 11 - Packet dropped status" ]
    pub fn set_pktdrpsts(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 12 - Babble error interrupt" ]
    pub fn set_berr(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 13 - NAK interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDieptsiz3 {
    bits: u32,
}

impl OtgHsDieptsiz3 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Multi count" ]
    pub fn mcnt(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsDieptsiz3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDieptsiz3 { bits: 0u32 }
    }
}

impl OtgHsDieptsiz3 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Multi count" ]
    pub fn set_mcnt(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDiepdma4 {
    bits: u32,
}

impl OtgHsDiepdma4 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn dmaaddr(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for OtgHsDiepdma4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDiepdma4 { bits: 0u32 }
    }
}

impl OtgHsDiepdma4 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn set_dmaaddr(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDtxfsts3 {
    bits: u32,
}

impl OtgHsDtxfsts3 {
    # [ doc = "Bits 0:15 - IN endpoint TxFIFO space avail" ]
    pub fn ineptfsav(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for OtgHsDtxfsts3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDtxfsts3 { bits: 0u32 }
    }
}

impl OtgHsDtxfsts3 {
    # [ doc = "Bits 0:15 - IN endpoint TxFIFO space avail" ]
    pub fn set_ineptfsav(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDiepctl4 {
    bits: u32,
}

impl OtgHsDiepctl4 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn usbaep(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 16 - Even/odd frame" ]
    pub fn eonum_dpid(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - NAK status" ]
    pub fn naksts(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bits 22:25 - TxFIFO number" ]
    pub fn txfnum(&self) -> u8 {
        self.bits.get_range(22u8..26u8) as u8
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn epdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn epena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsDiepctl4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDiepctl4 { bits: 0u32 }
    }
}

impl OtgHsDiepctl4 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn set_usbaep(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bits 22:25 - TxFIFO number" ]
    pub fn set_txfnum(&mut self, value: u8) {
        self.bits.set_range(22u8..26u8, value as u32);
    }
    # [ doc = "Bit 26 - Clear NAK" ]
    pub fn set_cnak(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 27 - Set NAK" ]
    pub fn set_snak(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 28 - Set DATA0 PID" ]
    pub fn set_sd0pid_sevnfrm(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 29 - Set odd frame" ]
    pub fn set_soddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn set_epdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn set_epena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDiepint4 {
    bits: u32,
}

impl OtgHsDiepint4 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn epdisd(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - Timeout condition" ]
    pub fn toc(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - IN token received when TxFIFO is empty" ]
    pub fn ittxfe(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 6 - IN endpoint NAK effective" ]
    pub fn inepne(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transmit FIFO empty" ]
    pub fn txfe(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Transmit Fifo Underrun" ]
    pub fn txfifoudrn(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Buffer not available interrupt" ]
    pub fn bna(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 11 - Packet dropped status" ]
    pub fn pktdrpsts(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 12 - Babble error interrupt" ]
    pub fn berr(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 13 - NAK interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(13u8)
    }
}

impl Default for OtgHsDiepint4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDiepint4 { bits: 0u32 }
    }
}

impl OtgHsDiepint4 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn set_epdisd(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - Timeout condition" ]
    pub fn set_toc(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - IN token received when TxFIFO is empty" ]
    pub fn set_ittxfe(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 6 - IN endpoint NAK effective" ]
    pub fn set_inepne(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 8 - Transmit Fifo Underrun" ]
    pub fn set_txfifoudrn(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Buffer not available interrupt" ]
    pub fn set_bna(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 11 - Packet dropped status" ]
    pub fn set_pktdrpsts(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 12 - Babble error interrupt" ]
    pub fn set_berr(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 13 - NAK interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDieptsiz4 {
    bits: u32,
}

impl OtgHsDieptsiz4 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Multi count" ]
    pub fn mcnt(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsDieptsiz4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDieptsiz4 { bits: 0u32 }
    }
}

impl OtgHsDieptsiz4 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Multi count" ]
    pub fn set_mcnt(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDiepdma5 {
    bits: u32,
}

impl OtgHsDiepdma5 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn dmaaddr(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for OtgHsDiepdma5 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDiepdma5 { bits: 0u32 }
    }
}

impl OtgHsDiepdma5 {
    # [ doc = "Bits 0:31 - DMA address" ]
    pub fn set_dmaaddr(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDtxfsts4 {
    bits: u32,
}

impl OtgHsDtxfsts4 {
    # [ doc = "Bits 0:15 - IN endpoint TxFIFO space avail" ]
    pub fn ineptfsav(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for OtgHsDtxfsts4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDtxfsts4 { bits: 0u32 }
    }
}

impl OtgHsDtxfsts4 {
    # [ doc = "Bits 0:15 - IN endpoint TxFIFO space avail" ]
    pub fn set_ineptfsav(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDiepctl5 {
    bits: u32,
}

impl OtgHsDiepctl5 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn usbaep(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 16 - Even/odd frame" ]
    pub fn eonum_dpid(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - NAK status" ]
    pub fn naksts(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bits 22:25 - TxFIFO number" ]
    pub fn txfnum(&self) -> u8 {
        self.bits.get_range(22u8..26u8) as u8
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn epdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn epena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsDiepctl5 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDiepctl5 { bits: 0u32 }
    }
}

impl OtgHsDiepctl5 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn set_usbaep(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bits 22:25 - TxFIFO number" ]
    pub fn set_txfnum(&mut self, value: u8) {
        self.bits.set_range(22u8..26u8, value as u32);
    }
    # [ doc = "Bit 26 - Clear NAK" ]
    pub fn set_cnak(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 27 - Set NAK" ]
    pub fn set_snak(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 28 - Set DATA0 PID" ]
    pub fn set_sd0pid_sevnfrm(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 29 - Set odd frame" ]
    pub fn set_soddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn set_epdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn set_epena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDiepint5 {
    bits: u32,
}

impl OtgHsDiepint5 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn epdisd(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - Timeout condition" ]
    pub fn toc(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - IN token received when TxFIFO is empty" ]
    pub fn ittxfe(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 6 - IN endpoint NAK effective" ]
    pub fn inepne(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transmit FIFO empty" ]
    pub fn txfe(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Transmit Fifo Underrun" ]
    pub fn txfifoudrn(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Buffer not available interrupt" ]
    pub fn bna(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 11 - Packet dropped status" ]
    pub fn pktdrpsts(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 12 - Babble error interrupt" ]
    pub fn berr(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 13 - NAK interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(13u8)
    }
}

impl Default for OtgHsDiepint5 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDiepint5 { bits: 0u32 }
    }
}

impl OtgHsDiepint5 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn set_epdisd(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - Timeout condition" ]
    pub fn set_toc(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - IN token received when TxFIFO is empty" ]
    pub fn set_ittxfe(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 6 - IN endpoint NAK effective" ]
    pub fn set_inepne(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 8 - Transmit Fifo Underrun" ]
    pub fn set_txfifoudrn(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Buffer not available interrupt" ]
    pub fn set_bna(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 11 - Packet dropped status" ]
    pub fn set_pktdrpsts(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 12 - Babble error interrupt" ]
    pub fn set_berr(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 13 - NAK interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDieptsiz5 {
    bits: u32,
}

impl OtgHsDieptsiz5 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Multi count" ]
    pub fn mcnt(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsDieptsiz5 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDieptsiz5 { bits: 0u32 }
    }
}

impl OtgHsDieptsiz5 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Multi count" ]
    pub fn set_mcnt(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDtxfsts5 {
    bits: u32,
}

impl OtgHsDtxfsts5 {
    # [ doc = "Bits 0:15 - IN endpoint TxFIFO space avail" ]
    pub fn ineptfsav(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for OtgHsDtxfsts5 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDtxfsts5 { bits: 0u32 }
    }
}

impl OtgHsDtxfsts5 {
    # [ doc = "Bits 0:15 - IN endpoint TxFIFO space avail" ]
    pub fn set_ineptfsav(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDiepctl6 {
    bits: u32,
}

impl OtgHsDiepctl6 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn usbaep(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 16 - Even/odd frame" ]
    pub fn eonum_dpid(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - NAK status" ]
    pub fn naksts(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bits 22:25 - TxFIFO number" ]
    pub fn txfnum(&self) -> u8 {
        self.bits.get_range(22u8..26u8) as u8
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn epdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn epena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsDiepctl6 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDiepctl6 { bits: 0u32 }
    }
}

impl OtgHsDiepctl6 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn set_usbaep(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bits 22:25 - TxFIFO number" ]
    pub fn set_txfnum(&mut self, value: u8) {
        self.bits.set_range(22u8..26u8, value as u32);
    }
    # [ doc = "Bit 26 - Clear NAK" ]
    pub fn set_cnak(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 27 - Set NAK" ]
    pub fn set_snak(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 28 - Set DATA0 PID" ]
    pub fn set_sd0pid_sevnfrm(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 29 - Set odd frame" ]
    pub fn set_soddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn set_epdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn set_epena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDiepint6 {
    bits: u32,
}

impl OtgHsDiepint6 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn epdisd(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - Timeout condition" ]
    pub fn toc(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - IN token received when TxFIFO is empty" ]
    pub fn ittxfe(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 6 - IN endpoint NAK effective" ]
    pub fn inepne(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transmit FIFO empty" ]
    pub fn txfe(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Transmit Fifo Underrun" ]
    pub fn txfifoudrn(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Buffer not available interrupt" ]
    pub fn bna(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 11 - Packet dropped status" ]
    pub fn pktdrpsts(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 12 - Babble error interrupt" ]
    pub fn berr(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 13 - NAK interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(13u8)
    }
}

impl Default for OtgHsDiepint6 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDiepint6 { bits: 0u32 }
    }
}

impl OtgHsDiepint6 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn set_epdisd(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - Timeout condition" ]
    pub fn set_toc(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - IN token received when TxFIFO is empty" ]
    pub fn set_ittxfe(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 6 - IN endpoint NAK effective" ]
    pub fn set_inepne(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 8 - Transmit Fifo Underrun" ]
    pub fn set_txfifoudrn(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Buffer not available interrupt" ]
    pub fn set_bna(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 11 - Packet dropped status" ]
    pub fn set_pktdrpsts(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 12 - Babble error interrupt" ]
    pub fn set_berr(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 13 - NAK interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDieptsiz6 {
    bits: u32,
}

impl OtgHsDieptsiz6 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Multi count" ]
    pub fn mcnt(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsDieptsiz6 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDieptsiz6 { bits: 0u32 }
    }
}

impl OtgHsDieptsiz6 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Multi count" ]
    pub fn set_mcnt(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDtxfsts6 {
    bits: u32,
}

impl OtgHsDtxfsts6 {
    # [ doc = "Bits 0:15 - IN endpoint TxFIFO space avail" ]
    pub fn ineptfsav(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for OtgHsDtxfsts6 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDtxfsts6 { bits: 0u32 }
    }
}

impl OtgHsDtxfsts6 {
    # [ doc = "Bits 0:15 - IN endpoint TxFIFO space avail" ]
    pub fn set_ineptfsav(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDiepctl7 {
    bits: u32,
}

impl OtgHsDiepctl7 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn usbaep(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 16 - Even/odd frame" ]
    pub fn eonum_dpid(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - NAK status" ]
    pub fn naksts(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bits 22:25 - TxFIFO number" ]
    pub fn txfnum(&self) -> u8 {
        self.bits.get_range(22u8..26u8) as u8
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn epdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn epena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsDiepctl7 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDiepctl7 { bits: 0u32 }
    }
}

impl OtgHsDiepctl7 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn set_usbaep(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bits 22:25 - TxFIFO number" ]
    pub fn set_txfnum(&mut self, value: u8) {
        self.bits.set_range(22u8..26u8, value as u32);
    }
    # [ doc = "Bit 26 - Clear NAK" ]
    pub fn set_cnak(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 27 - Set NAK" ]
    pub fn set_snak(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 28 - Set DATA0 PID" ]
    pub fn set_sd0pid_sevnfrm(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 29 - Set odd frame" ]
    pub fn set_soddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn set_epdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn set_epena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDiepint7 {
    bits: u32,
}

impl OtgHsDiepint7 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn epdisd(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - Timeout condition" ]
    pub fn toc(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - IN token received when TxFIFO is empty" ]
    pub fn ittxfe(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 6 - IN endpoint NAK effective" ]
    pub fn inepne(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transmit FIFO empty" ]
    pub fn txfe(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Transmit Fifo Underrun" ]
    pub fn txfifoudrn(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Buffer not available interrupt" ]
    pub fn bna(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 11 - Packet dropped status" ]
    pub fn pktdrpsts(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 12 - Babble error interrupt" ]
    pub fn berr(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 13 - NAK interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(13u8)
    }
}

impl Default for OtgHsDiepint7 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDiepint7 { bits: 0u32 }
    }
}

impl OtgHsDiepint7 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn set_epdisd(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - Timeout condition" ]
    pub fn set_toc(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - IN token received when TxFIFO is empty" ]
    pub fn set_ittxfe(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 6 - IN endpoint NAK effective" ]
    pub fn set_inepne(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 8 - Transmit Fifo Underrun" ]
    pub fn set_txfifoudrn(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Buffer not available interrupt" ]
    pub fn set_bna(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 11 - Packet dropped status" ]
    pub fn set_pktdrpsts(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 12 - Babble error interrupt" ]
    pub fn set_berr(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 13 - NAK interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDieptsiz7 {
    bits: u32,
}

impl OtgHsDieptsiz7 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Multi count" ]
    pub fn mcnt(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsDieptsiz7 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDieptsiz7 { bits: 0u32 }
    }
}

impl OtgHsDieptsiz7 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Multi count" ]
    pub fn set_mcnt(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDtxfsts7 {
    bits: u32,
}

impl OtgHsDtxfsts7 {
    # [ doc = "Bits 0:15 - IN endpoint TxFIFO space avail" ]
    pub fn ineptfsav(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for OtgHsDtxfsts7 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDtxfsts7 { bits: 0u32 }
    }
}

impl OtgHsDtxfsts7 {
    # [ doc = "Bits 0:15 - IN endpoint TxFIFO space avail" ]
    pub fn set_ineptfsav(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoepctl0 {
    bits: u32,
}

impl OtgHsDoepctl0 {
    # [ doc = "Bits 0:1 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u8 {
        self.bits.get_range(0u8..2u8) as u8
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn usbaep(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - NAK status" ]
    pub fn naksts(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bit 20 - Snoop mode" ]
    pub fn snpm(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn epdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
}

impl Default for OtgHsDoepctl0 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoepctl0 { bits: 32768u32 }
    }
}

impl OtgHsDoepctl0 {
    # [ doc = "Bit 20 - Snoop mode" ]
    pub fn set_snpm(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 26 - Clear NAK" ]
    pub fn set_cnak(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 27 - Set NAK" ]
    pub fn set_snak(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn set_epena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoepint0 {
    bits: u32,
}

impl OtgHsDoepint0 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn epdisd(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - SETUP phase done" ]
    pub fn stup(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - OUT token received when endpoint disabled" ]
    pub fn otepdis(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 6 - Back-to-back SETUP packets received" ]
    pub fn b2bstup(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 14 - NYET interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(14u8)
    }
}

impl Default for OtgHsDoepint0 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoepint0 { bits: 128u32 }
    }
}

impl OtgHsDoepint0 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn set_epdisd(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - SETUP phase done" ]
    pub fn set_stup(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - OUT token received when endpoint disabled" ]
    pub fn set_otepdis(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 6 - Back-to-back SETUP packets received" ]
    pub fn set_b2bstup(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 14 - NYET interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoeptsiz0 {
    bits: u32,
}

impl OtgHsDoeptsiz0 {
    # [ doc = "Bits 0:6 - Transfer size" ]
    pub fn xfrsiz(&self) -> u8 {
        self.bits.get_range(0u8..7u8) as u8
    }
    # [ doc = "Bit 19 - Packet count" ]
    pub fn pktcnt(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bits 29:30 - SETUP packet count" ]
    pub fn stupcnt(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsDoeptsiz0 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoeptsiz0 { bits: 0u32 }
    }
}

impl OtgHsDoeptsiz0 {
    # [ doc = "Bits 0:6 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u8) {
        self.bits.set_range(0u8..7u8, value as u32);
    }
    # [ doc = "Bit 19 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bits 29:30 - SETUP packet count" ]
    pub fn set_stupcnt(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoepctl1 {
    bits: u32,
}

impl OtgHsDoepctl1 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn usbaep(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 16 - Even odd frame/Endpoint data PID" ]
    pub fn eonum_dpid(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - NAK status" ]
    pub fn naksts(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bit 20 - Snoop mode" ]
    pub fn snpm(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn epdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn epena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsDoepctl1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoepctl1 { bits: 0u32 }
    }
}

impl OtgHsDoepctl1 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn set_usbaep(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bit 20 - Snoop mode" ]
    pub fn set_snpm(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 26 - Clear NAK" ]
    pub fn set_cnak(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 27 - Set NAK" ]
    pub fn set_snak(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 28 - Set DATA0 PID/Set even frame" ]
    pub fn set_sd0pid_sevnfrm(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 29 - Set odd frame" ]
    pub fn set_soddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn set_epdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn set_epena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoepint1 {
    bits: u32,
}

impl OtgHsDoepint1 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn epdisd(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - SETUP phase done" ]
    pub fn stup(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - OUT token received when endpoint disabled" ]
    pub fn otepdis(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 6 - Back-to-back SETUP packets received" ]
    pub fn b2bstup(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 14 - NYET interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(14u8)
    }
}

impl Default for OtgHsDoepint1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoepint1 { bits: 0u32 }
    }
}

impl OtgHsDoepint1 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn set_epdisd(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - SETUP phase done" ]
    pub fn set_stup(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - OUT token received when endpoint disabled" ]
    pub fn set_otepdis(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 6 - Back-to-back SETUP packets received" ]
    pub fn set_b2bstup(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 14 - NYET interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoeptsiz1 {
    bits: u32,
}

impl OtgHsDoeptsiz1 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Received data PID/SETUP packet count" ]
    pub fn rxdpid_stupcnt(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsDoeptsiz1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoeptsiz1 { bits: 0u32 }
    }
}

impl OtgHsDoeptsiz1 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Received data PID/SETUP packet count" ]
    pub fn set_rxdpid_stupcnt(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoepctl2 {
    bits: u32,
}

impl OtgHsDoepctl2 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn usbaep(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 16 - Even odd frame/Endpoint data PID" ]
    pub fn eonum_dpid(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - NAK status" ]
    pub fn naksts(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bit 20 - Snoop mode" ]
    pub fn snpm(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn epdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn epena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsDoepctl2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoepctl2 { bits: 0u32 }
    }
}

impl OtgHsDoepctl2 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn set_usbaep(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bit 20 - Snoop mode" ]
    pub fn set_snpm(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 26 - Clear NAK" ]
    pub fn set_cnak(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 27 - Set NAK" ]
    pub fn set_snak(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 28 - Set DATA0 PID/Set even frame" ]
    pub fn set_sd0pid_sevnfrm(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 29 - Set odd frame" ]
    pub fn set_soddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn set_epdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn set_epena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoepint2 {
    bits: u32,
}

impl OtgHsDoepint2 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn epdisd(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - SETUP phase done" ]
    pub fn stup(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - OUT token received when endpoint disabled" ]
    pub fn otepdis(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 6 - Back-to-back SETUP packets received" ]
    pub fn b2bstup(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 14 - NYET interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(14u8)
    }
}

impl Default for OtgHsDoepint2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoepint2 { bits: 0u32 }
    }
}

impl OtgHsDoepint2 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn set_epdisd(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - SETUP phase done" ]
    pub fn set_stup(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - OUT token received when endpoint disabled" ]
    pub fn set_otepdis(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 6 - Back-to-back SETUP packets received" ]
    pub fn set_b2bstup(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 14 - NYET interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoeptsiz2 {
    bits: u32,
}

impl OtgHsDoeptsiz2 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Received data PID/SETUP packet count" ]
    pub fn rxdpid_stupcnt(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsDoeptsiz2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoeptsiz2 { bits: 0u32 }
    }
}

impl OtgHsDoeptsiz2 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Received data PID/SETUP packet count" ]
    pub fn set_rxdpid_stupcnt(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoepctl3 {
    bits: u32,
}

impl OtgHsDoepctl3 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn usbaep(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 16 - Even odd frame/Endpoint data PID" ]
    pub fn eonum_dpid(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - NAK status" ]
    pub fn naksts(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bit 20 - Snoop mode" ]
    pub fn snpm(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn epdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn epena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsDoepctl3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoepctl3 { bits: 0u32 }
    }
}

impl OtgHsDoepctl3 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn set_usbaep(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bit 20 - Snoop mode" ]
    pub fn set_snpm(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 26 - Clear NAK" ]
    pub fn set_cnak(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 27 - Set NAK" ]
    pub fn set_snak(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 28 - Set DATA0 PID/Set even frame" ]
    pub fn set_sd0pid_sevnfrm(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 29 - Set odd frame" ]
    pub fn set_soddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn set_epdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn set_epena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoepint3 {
    bits: u32,
}

impl OtgHsDoepint3 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn epdisd(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - SETUP phase done" ]
    pub fn stup(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - OUT token received when endpoint disabled" ]
    pub fn otepdis(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 6 - Back-to-back SETUP packets received" ]
    pub fn b2bstup(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 14 - NYET interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(14u8)
    }
}

impl Default for OtgHsDoepint3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoepint3 { bits: 0u32 }
    }
}

impl OtgHsDoepint3 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn set_epdisd(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - SETUP phase done" ]
    pub fn set_stup(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - OUT token received when endpoint disabled" ]
    pub fn set_otepdis(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 6 - Back-to-back SETUP packets received" ]
    pub fn set_b2bstup(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 14 - NYET interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoeptsiz3 {
    bits: u32,
}

impl OtgHsDoeptsiz3 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Received data PID/SETUP packet count" ]
    pub fn rxdpid_stupcnt(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsDoeptsiz3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoeptsiz3 { bits: 0u32 }
    }
}

impl OtgHsDoeptsiz3 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Received data PID/SETUP packet count" ]
    pub fn set_rxdpid_stupcnt(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoepctl4 {
    bits: u32,
}

impl OtgHsDoepctl4 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn usbaep(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 16 - Even odd frame/Endpoint data PID" ]
    pub fn eonum_dpid(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - NAK status" ]
    pub fn naksts(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bit 20 - Snoop mode" ]
    pub fn snpm(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn epdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn epena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsDoepctl4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoepctl4 { bits: 0u32 }
    }
}

impl OtgHsDoepctl4 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn set_usbaep(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bit 20 - Snoop mode" ]
    pub fn set_snpm(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 26 - Clear NAK" ]
    pub fn set_cnak(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 27 - Set NAK" ]
    pub fn set_snak(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 28 - Set DATA0 PID/Set even frame" ]
    pub fn set_sd0pid_sevnfrm(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 29 - Set odd frame" ]
    pub fn set_soddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn set_epdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn set_epena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoepint4 {
    bits: u32,
}

impl OtgHsDoepint4 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn epdisd(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - SETUP phase done" ]
    pub fn stup(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - OUT token received when endpoint disabled" ]
    pub fn otepdis(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 6 - Back-to-back SETUP packets received" ]
    pub fn b2bstup(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 14 - NYET interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(14u8)
    }
}

impl Default for OtgHsDoepint4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoepint4 { bits: 0u32 }
    }
}

impl OtgHsDoepint4 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn set_epdisd(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - SETUP phase done" ]
    pub fn set_stup(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - OUT token received when endpoint disabled" ]
    pub fn set_otepdis(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 6 - Back-to-back SETUP packets received" ]
    pub fn set_b2bstup(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 14 - NYET interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoeptsiz4 {
    bits: u32,
}

impl OtgHsDoeptsiz4 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Received data PID/SETUP packet count" ]
    pub fn rxdpid_stupcnt(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsDoeptsiz4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoeptsiz4 { bits: 0u32 }
    }
}

impl OtgHsDoeptsiz4 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Received data PID/SETUP packet count" ]
    pub fn set_rxdpid_stupcnt(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoepctl5 {
    bits: u32,
}

impl OtgHsDoepctl5 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn usbaep(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 16 - Even odd frame/Endpoint data PID" ]
    pub fn eonum_dpid(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - NAK status" ]
    pub fn naksts(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bit 20 - Snoop mode" ]
    pub fn snpm(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn epdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn epena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsDoepctl5 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoepctl5 { bits: 0u32 }
    }
}

impl OtgHsDoepctl5 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn set_usbaep(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bit 20 - Snoop mode" ]
    pub fn set_snpm(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 26 - Clear NAK" ]
    pub fn set_cnak(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 27 - Set NAK" ]
    pub fn set_snak(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 28 - Set DATA0 PID/Set even frame" ]
    pub fn set_sd0pid_sevnfrm(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 29 - Set odd frame" ]
    pub fn set_soddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn set_epdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn set_epena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoepint5 {
    bits: u32,
}

impl OtgHsDoepint5 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn epdisd(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - SETUP phase done" ]
    pub fn stup(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - OUT token received when endpoint disabled" ]
    pub fn otepdis(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 6 - Back-to-back SETUP packets received" ]
    pub fn b2bstup(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 14 - NYET interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(14u8)
    }
}

impl Default for OtgHsDoepint5 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoepint5 { bits: 0u32 }
    }
}

impl OtgHsDoepint5 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn set_epdisd(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - SETUP phase done" ]
    pub fn set_stup(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - OUT token received when endpoint disabled" ]
    pub fn set_otepdis(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 6 - Back-to-back SETUP packets received" ]
    pub fn set_b2bstup(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 14 - NYET interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoeptsiz5 {
    bits: u32,
}

impl OtgHsDoeptsiz5 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Received data PID/SETUP packet count" ]
    pub fn rxdpid_stupcnt(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsDoeptsiz5 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoeptsiz5 { bits: 0u32 }
    }
}

impl OtgHsDoeptsiz5 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Received data PID/SETUP packet count" ]
    pub fn set_rxdpid_stupcnt(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoepctl6 {
    bits: u32,
}

impl OtgHsDoepctl6 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn usbaep(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 16 - Even odd frame/Endpoint data PID" ]
    pub fn eonum_dpid(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - NAK status" ]
    pub fn naksts(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bit 20 - Snoop mode" ]
    pub fn snpm(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn epdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn epena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsDoepctl6 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoepctl6 { bits: 0u32 }
    }
}

impl OtgHsDoepctl6 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn set_usbaep(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bit 20 - Snoop mode" ]
    pub fn set_snpm(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 26 - Clear NAK" ]
    pub fn set_cnak(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 27 - Set NAK" ]
    pub fn set_snak(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 28 - Set DATA0 PID/Set even frame" ]
    pub fn set_sd0pid_sevnfrm(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 29 - Set odd frame" ]
    pub fn set_soddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn set_epdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn set_epena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoepint6 {
    bits: u32,
}

impl OtgHsDoepint6 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn epdisd(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - SETUP phase done" ]
    pub fn stup(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - OUT token received when endpoint disabled" ]
    pub fn otepdis(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 6 - Back-to-back SETUP packets received" ]
    pub fn b2bstup(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 14 - NYET interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(14u8)
    }
}

impl Default for OtgHsDoepint6 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoepint6 { bits: 0u32 }
    }
}

impl OtgHsDoepint6 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn set_epdisd(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - SETUP phase done" ]
    pub fn set_stup(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - OUT token received when endpoint disabled" ]
    pub fn set_otepdis(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 6 - Back-to-back SETUP packets received" ]
    pub fn set_b2bstup(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 14 - NYET interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoeptsiz6 {
    bits: u32,
}

impl OtgHsDoeptsiz6 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Received data PID/SETUP packet count" ]
    pub fn rxdpid_stupcnt(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsDoeptsiz6 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoeptsiz6 { bits: 0u32 }
    }
}

impl OtgHsDoeptsiz6 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Received data PID/SETUP packet count" ]
    pub fn set_rxdpid_stupcnt(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoepctl7 {
    bits: u32,
}

impl OtgHsDoepctl7 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn usbaep(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 16 - Even odd frame/Endpoint data PID" ]
    pub fn eonum_dpid(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - NAK status" ]
    pub fn naksts(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bit 20 - Snoop mode" ]
    pub fn snpm(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn epdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn epena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsDoepctl7 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoepctl7 { bits: 0u32 }
    }
}

impl OtgHsDoepctl7 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bit 15 - USB active endpoint" ]
    pub fn set_usbaep(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bit 20 - Snoop mode" ]
    pub fn set_snpm(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 21 - STALL handshake" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 26 - Clear NAK" ]
    pub fn set_cnak(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 27 - Set NAK" ]
    pub fn set_snak(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 28 - Set DATA0 PID/Set even frame" ]
    pub fn set_sd0pid_sevnfrm(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 29 - Set odd frame" ]
    pub fn set_soddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Endpoint disable" ]
    pub fn set_epdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Endpoint enable" ]
    pub fn set_epena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoepint7 {
    bits: u32,
}

impl OtgHsDoepint7 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn epdisd(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - SETUP phase done" ]
    pub fn stup(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - OUT token received when endpoint disabled" ]
    pub fn otepdis(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 6 - Back-to-back SETUP packets received" ]
    pub fn b2bstup(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 14 - NYET interrupt" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(14u8)
    }
}

impl Default for OtgHsDoepint7 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoepint7 { bits: 0u32 }
    }
}

impl OtgHsDoepint7 {
    # [ doc = "Bit 0 - Transfer completed interrupt" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Endpoint disabled interrupt" ]
    pub fn set_epdisd(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - SETUP phase done" ]
    pub fn set_stup(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - OUT token received when endpoint disabled" ]
    pub fn set_otepdis(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 6 - Back-to-back SETUP packets received" ]
    pub fn set_b2bstup(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 14 - NYET interrupt" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct OtgHsDoeptsiz7 {
    bits: u32,
}

impl OtgHsDoeptsiz7 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Received data PID/SETUP packet count" ]
    pub fn rxdpid_stupcnt(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgHsDoeptsiz7 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDoeptsiz7 { bits: 0u32 }
    }
}

impl OtgHsDoeptsiz7 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Received data PID/SETUP packet count" ]
    pub fn set_rxdpid_stupcnt(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}
