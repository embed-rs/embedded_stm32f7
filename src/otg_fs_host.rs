// autogenerated

use volatile;
use bit_field::BitField;

# [ doc = "USB on the go full speed" ]
# [ repr ( C ) ]
pub struct OtgFsHost {
    # [ doc = "0x00 - OTG_FS host configuration register (OTG_FS_HCFG)" ]
    pub otg_fs_hcfg: volatile::ReadWrite<OtgFsHcfg>,
    # [ doc = "0x04 - OTG_FS Host frame interval register" ]
    pub otg_fs_hfir: volatile::ReadWrite<OtgFsHfir>,
    # [ doc = "0x08 - OTG_FS host frame number/frame time remaining register (OTG_FS_HFNUM)" ]
    pub otg_fs_hfnum: volatile::ReadOnly<OtgFsHfnum>,
    _reserved0: [u8; 4usize],
    # [ doc = "0x10 - OTG_FS_Host periodic transmit FIFO/queue status register (OTG_FS_HPTXSTS)" ]
    pub otg_fs_hptxsts: volatile::ReadWrite<OtgFsHptxsts>,
    # [ doc = "0x14 - OTG_FS Host all channels interrupt register" ]
    pub otg_fs_haint: volatile::ReadOnly<OtgFsHaint>,
    # [ doc = "0x18 - OTG_FS host all channels interrupt mask register" ]
    pub otg_fs_haintmsk: volatile::ReadWrite<OtgFsHaintmsk>,
    _reserved1: [u8; 36usize],
    # [ doc = "0x40 - OTG_FS host port control and status register (OTG_FS_HPRT)" ]
    pub otg_fs_hprt: volatile::ReadWrite<OtgFsHprt>,
    _reserved2: [u8; 188usize],
    # [ doc = "0x100 - OTG_FS host channel-0 characteristics register (OTG_FS_HCCHAR0)" ]
    pub otg_fs_hcchar0: volatile::ReadWrite<OtgFsHcchar0>,
    _reserved3: [u8; 4usize],
    # [ doc = "0x108 - OTG_FS host channel-0 interrupt register (OTG_FS_HCINT0)" ]
    pub otg_fs_hcint0: volatile::ReadWrite<OtgFsHcint0>,
    # [ doc = "0x10c - OTG_FS host channel-0 mask register (OTG_FS_HCINTMSK0)" ]
    pub otg_fs_hcintmsk0: volatile::ReadWrite<OtgFsHcintmsk0>,
    # [ doc = "0x110 - OTG_FS host channel-0 transfer size register" ]
    pub otg_fs_hctsiz0: volatile::ReadWrite<OtgFsHctsiz0>,
    _reserved4: [u8; 12usize],
    # [ doc = "0x120 - OTG_FS host channel-1 characteristics register (OTG_FS_HCCHAR1)" ]
    pub otg_fs_hcchar1: volatile::ReadWrite<OtgFsHcchar1>,
    _reserved5: [u8; 4usize],
    # [ doc = "0x128 - OTG_FS host channel-1 interrupt register (OTG_FS_HCINT1)" ]
    pub otg_fs_hcint1: volatile::ReadWrite<OtgFsHcint1>,
    # [ doc = "0x12c - OTG_FS host channel-1 mask register (OTG_FS_HCINTMSK1)" ]
    pub otg_fs_hcintmsk1: volatile::ReadWrite<OtgFsHcintmsk1>,
    # [ doc = "0x130 - OTG_FS host channel-1 transfer size register" ]
    pub otg_fs_hctsiz1: volatile::ReadWrite<OtgFsHctsiz1>,
    _reserved6: [u8; 12usize],
    # [ doc = "0x140 - OTG_FS host channel-2 characteristics register (OTG_FS_HCCHAR2)" ]
    pub otg_fs_hcchar2: volatile::ReadWrite<OtgFsHcchar2>,
    _reserved7: [u8; 4usize],
    # [ doc = "0x148 - OTG_FS host channel-2 interrupt register (OTG_FS_HCINT2)" ]
    pub otg_fs_hcint2: volatile::ReadWrite<OtgFsHcint2>,
    # [ doc = "0x14c - OTG_FS host channel-2 mask register (OTG_FS_HCINTMSK2)" ]
    pub otg_fs_hcintmsk2: volatile::ReadWrite<OtgFsHcintmsk2>,
    # [ doc = "0x150 - OTG_FS host channel-2 transfer size register" ]
    pub otg_fs_hctsiz2: volatile::ReadWrite<OtgFsHctsiz2>,
    _reserved8: [u8; 12usize],
    # [ doc = "0x160 - OTG_FS host channel-3 characteristics register (OTG_FS_HCCHAR3)" ]
    pub otg_fs_hcchar3: volatile::ReadWrite<OtgFsHcchar3>,
    _reserved9: [u8; 4usize],
    # [ doc = "0x168 - OTG_FS host channel-3 interrupt register (OTG_FS_HCINT3)" ]
    pub otg_fs_hcint3: volatile::ReadWrite<OtgFsHcint3>,
    # [ doc = "0x16c - OTG_FS host channel-3 mask register (OTG_FS_HCINTMSK3)" ]
    pub otg_fs_hcintmsk3: volatile::ReadWrite<OtgFsHcintmsk3>,
    # [ doc = "0x170 - OTG_FS host channel-3 transfer size register" ]
    pub otg_fs_hctsiz3: volatile::ReadWrite<OtgFsHctsiz3>,
    _reserved10: [u8; 12usize],
    # [ doc = "0x180 - OTG_FS host channel-4 characteristics register (OTG_FS_HCCHAR4)" ]
    pub otg_fs_hcchar4: volatile::ReadWrite<OtgFsHcchar4>,
    _reserved11: [u8; 4usize],
    # [ doc = "0x188 - OTG_FS host channel-4 interrupt register (OTG_FS_HCINT4)" ]
    pub otg_fs_hcint4: volatile::ReadWrite<OtgFsHcint4>,
    # [ doc = "0x18c - OTG_FS host channel-4 mask register (OTG_FS_HCINTMSK4)" ]
    pub otg_fs_hcintmsk4: volatile::ReadWrite<OtgFsHcintmsk4>,
    # [ doc = "0x190 - OTG_FS host channel-x transfer size register" ]
    pub otg_fs_hctsiz4: volatile::ReadWrite<OtgFsHctsiz4>,
    _reserved12: [u8; 12usize],
    # [ doc = "0x1a0 - OTG_FS host channel-5 characteristics register (OTG_FS_HCCHAR5)" ]
    pub otg_fs_hcchar5: volatile::ReadWrite<OtgFsHcchar5>,
    _reserved13: [u8; 4usize],
    # [ doc = "0x1a8 - OTG_FS host channel-5 interrupt register (OTG_FS_HCINT5)" ]
    pub otg_fs_hcint5: volatile::ReadWrite<OtgFsHcint5>,
    # [ doc = "0x1ac - OTG_FS host channel-5 mask register (OTG_FS_HCINTMSK5)" ]
    pub otg_fs_hcintmsk5: volatile::ReadWrite<OtgFsHcintmsk5>,
    # [ doc = "0x1b0 - OTG_FS host channel-5 transfer size register" ]
    pub otg_fs_hctsiz5: volatile::ReadWrite<OtgFsHctsiz5>,
    _reserved14: [u8; 12usize],
    # [ doc = "0x1c0 - OTG_FS host channel-6 characteristics register (OTG_FS_HCCHAR6)" ]
    pub otg_fs_hcchar6: volatile::ReadWrite<OtgFsHcchar6>,
    _reserved15: [u8; 4usize],
    # [ doc = "0x1c8 - OTG_FS host channel-6 interrupt register (OTG_FS_HCINT6)" ]
    pub otg_fs_hcint6: volatile::ReadWrite<OtgFsHcint6>,
    # [ doc = "0x1cc - OTG_FS host channel-6 mask register (OTG_FS_HCINTMSK6)" ]
    pub otg_fs_hcintmsk6: volatile::ReadWrite<OtgFsHcintmsk6>,
    # [ doc = "0x1d0 - OTG_FS host channel-6 transfer size register" ]
    pub otg_fs_hctsiz6: volatile::ReadWrite<OtgFsHctsiz6>,
    _reserved16: [u8; 12usize],
    # [ doc = "0x1e0 - OTG_FS host channel-7 characteristics register (OTG_FS_HCCHAR7)" ]
    pub otg_fs_hcchar7: volatile::ReadWrite<OtgFsHcchar7>,
    _reserved17: [u8; 4usize],
    # [ doc = "0x1e8 - OTG_FS host channel-7 interrupt register (OTG_FS_HCINT7)" ]
    pub otg_fs_hcint7: volatile::ReadWrite<OtgFsHcint7>,
    # [ doc = "0x1ec - OTG_FS host channel-7 mask register (OTG_FS_HCINTMSK7)" ]
    pub otg_fs_hcintmsk7: volatile::ReadWrite<OtgFsHcintmsk7>,
    # [ doc = "0x1f0 - OTG_FS host channel-7 transfer size register" ]
    pub otg_fs_hctsiz7: volatile::ReadWrite<OtgFsHctsiz7>,
    # [ doc = "0x1f4 - OTG_FS host channel-8 characteristics register" ]
    pub otg_fs_hcchar8: volatile::ReadWrite<OtgFsHcchar8>,
    # [ doc = "0x1f8 - OTG_FS host channel-8 interrupt register" ]
    pub otg_fs_hcint8: volatile::ReadWrite<OtgFsHcint8>,
    # [ doc = "0x1fc - OTG_FS host channel-8 mask register" ]
    pub otg_fs_hcintmsk8: volatile::ReadWrite<OtgFsHcintmsk8>,
    # [ doc = "0x200 - OTG_FS host channel-8 transfer size register" ]
    pub otg_fs_hctsiz8: volatile::ReadWrite<OtgFsHctsiz8>,
    # [ doc = "0x204 - OTG_FS host channel-9 characteristics register" ]
    pub otg_fs_hcchar9: volatile::ReadWrite<OtgFsHcchar9>,
    # [ doc = "0x208 - OTG_FS host channel-9 interrupt register" ]
    pub otg_fs_hcint9: volatile::ReadWrite<OtgFsHcint9>,
    # [ doc = "0x20c - OTG_FS host channel-9 mask register" ]
    pub otg_fs_hcintmsk9: volatile::ReadWrite<OtgFsHcintmsk9>,
    # [ doc = "0x210 - OTG_FS host channel-9 transfer size register" ]
    pub otg_fs_hctsiz9: volatile::ReadWrite<OtgFsHctsiz9>,
    # [ doc = "0x214 - OTG_FS host channel-10 characteristics register" ]
    pub otg_fs_hcchar10: volatile::ReadWrite<OtgFsHcchar10>,
    # [ doc = "0x218 - OTG_FS host channel-10 interrupt register" ]
    pub otg_fs_hcint10: volatile::ReadWrite<OtgFsHcint10>,
    # [ doc = "0x21c - OTG_FS host channel-10 mask register" ]
    pub otg_fs_hcintmsk10: volatile::ReadWrite<OtgFsHcintmsk10>,
    # [ doc = "0x220 - OTG_FS host channel-10 transfer size register" ]
    pub otg_fs_hctsiz10: volatile::ReadWrite<OtgFsHctsiz10>,
    # [ doc = "0x224 - OTG_FS host channel-11 characteristics register" ]
    pub otg_fs_hcchar11: volatile::ReadWrite<OtgFsHcchar11>,
    # [ doc = "0x228 - OTG_FS host channel-11 interrupt register" ]
    pub otg_fs_hcint11: volatile::ReadWrite<OtgFsHcint11>,
    # [ doc = "0x22c - OTG_FS host channel-11 mask register" ]
    pub otg_fs_hcintmsk11: volatile::ReadWrite<OtgFsHcintmsk11>,
    # [ doc = "0x230 - OTG_FS host channel-11 transfer size register" ]
    pub otg_fs_hctsiz11: volatile::ReadWrite<OtgFsHctsiz11>,
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcfg {
    bits: u32,
}

impl OtgFsHcfg {
    # [ doc = "Bits 0:1 - FS/LS PHY clock select" ]
    pub fn fslspcs(&self) -> u8 {
        self.bits.get_range(0u8..2u8) as u8
    }
    # [ doc = "Bit 2 - FS- and LS-only support" ]
    pub fn fslss(&self) -> bool {
        self.bits.get_bit(2u8)
    }
}

impl Default for OtgFsHcfg {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcfg { bits: 0u32 }
    }
}

impl OtgFsHcfg {
    # [ doc = "Bits 0:1 - FS/LS PHY clock select" ]
    pub fn set_fslspcs(&mut self, value: u8) {
        self.bits.set_range(0u8..2u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHfir {
    bits: u32,
}

impl OtgFsHfir {
    # [ doc = "Bits 0:15 - Frame interval" ]
    pub fn frivl(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for OtgFsHfir {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHfir { bits: 60000u32 }
    }
}

impl OtgFsHfir {
    # [ doc = "Bits 0:15 - Frame interval" ]
    pub fn set_frivl(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHfnum {
    bits: u32,
}

impl OtgFsHfnum {
    # [ doc = "Bits 0:15 - Frame number" ]
    pub fn frnum(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:31 - Frame time remaining" ]
    pub fn ftrem(&self) -> u16 {
        self.bits.get_range(16u8..32u8) as u16
    }
}

impl Default for OtgFsHfnum {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHfnum { bits: 16383u32 }
    }
}

impl OtgFsHfnum {
    # [ doc = "Bits 0:15 - Frame number" ]
    pub fn set_frnum(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:31 - Frame time remaining" ]
    pub fn set_ftrem(&mut self, value: u16) {
        self.bits.set_range(16u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHptxsts {
    bits: u32,
}

impl OtgFsHptxsts {
    # [ doc = "Bits 0:15 - Periodic transmit data FIFO space available" ]
    pub fn ptxfsavl(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:23 - Periodic transmit request queue space available" ]
    pub fn ptxqsav(&self) -> u8 {
        self.bits.get_range(16u8..24u8) as u8
    }
    # [ doc = "Bits 24:31 - Top of the periodic transmit request queue" ]
    pub fn ptxqtop(&self) -> u8 {
        self.bits.get_range(24u8..32u8) as u8
    }
}

impl Default for OtgFsHptxsts {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHptxsts { bits: 524544u32 }
    }
}

impl OtgFsHptxsts {
    # [ doc = "Bits 0:15 - Periodic transmit data FIFO space available" ]
    pub fn set_ptxfsavl(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHaint {
    bits: u32,
}

impl OtgFsHaint {
    # [ doc = "Bits 0:15 - Channel interrupts" ]
    pub fn haint(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for OtgFsHaint {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHaint { bits: 0u32 }
    }
}

impl OtgFsHaint {
    # [ doc = "Bits 0:15 - Channel interrupts" ]
    pub fn set_haint(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHaintmsk {
    bits: u32,
}

impl OtgFsHaintmsk {
    # [ doc = "Bits 0:15 - Channel interrupt mask" ]
    pub fn haintm(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for OtgFsHaintmsk {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHaintmsk { bits: 0u32 }
    }
}

impl OtgFsHaintmsk {
    # [ doc = "Bits 0:15 - Channel interrupt mask" ]
    pub fn set_haintm(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHprt {
    bits: u32,
}

impl OtgFsHprt {
    # [ doc = "Bit 0 - Port connect status" ]
    pub fn pcsts(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Port connect detected" ]
    pub fn pcdet(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - Port enable" ]
    pub fn pena(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - Port enable/disable change" ]
    pub fn penchng(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - Port overcurrent active" ]
    pub fn poca(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - Port overcurrent change" ]
    pub fn pocchng(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Port resume" ]
    pub fn pres(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Port suspend" ]
    pub fn psusp(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Port reset" ]
    pub fn prst(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bits 10:11 - Port line status" ]
    pub fn plsts(&self) -> u8 {
        self.bits.get_range(10u8..12u8) as u8
    }
    # [ doc = "Bit 12 - Port power" ]
    pub fn ppwr(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bits 13:16 - Port test control" ]
    pub fn ptctl(&self) -> u8 {
        self.bits.get_range(13u8..17u8) as u8
    }
    # [ doc = "Bits 17:18 - Port speed" ]
    pub fn pspd(&self) -> u8 {
        self.bits.get_range(17u8..19u8) as u8
    }
}

impl Default for OtgFsHprt {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHprt { bits: 0u32 }
    }
}

impl OtgFsHprt {
    # [ doc = "Bit 1 - Port connect detected" ]
    pub fn set_pcdet(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - Port enable" ]
    pub fn set_pena(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - Port enable/disable change" ]
    pub fn set_penchng(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 5 - Port overcurrent change" ]
    pub fn set_pocchng(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Port resume" ]
    pub fn set_pres(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Port suspend" ]
    pub fn set_psusp(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Port reset" ]
    pub fn set_prst(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 12 - Port power" ]
    pub fn set_ppwr(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bits 13:16 - Port test control" ]
    pub fn set_ptctl(&mut self, value: u8) {
        self.bits.set_range(13u8..17u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcchar0 {
    bits: u32,
}

impl OtgFsHcchar0 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn mcnt(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgFsHcchar0 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcchar0 { bits: 0u32 }
    }
}

impl OtgFsHcchar0 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn set_mcnt(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcint0 {
    bits: u32,
}

impl OtgFsHcint0 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcint0 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcint0 { bits: 0u32 }
    }
}

impl OtgFsHcint0 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcintmsk0 {
    bits: u32,
}

impl OtgFsHcintmsk0 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcintmsk0 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcintmsk0 { bits: 0u32 }
    }
}

impl OtgFsHcintmsk0 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHctsiz0 {
    bits: u32,
}

impl OtgFsHctsiz0 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgFsHctsiz0 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHctsiz0 { bits: 0u32 }
    }
}

impl OtgFsHctsiz0 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcchar1 {
    bits: u32,
}

impl OtgFsHcchar1 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn mcnt(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgFsHcchar1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcchar1 { bits: 0u32 }
    }
}

impl OtgFsHcchar1 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn set_mcnt(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcint1 {
    bits: u32,
}

impl OtgFsHcint1 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcint1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcint1 { bits: 0u32 }
    }
}

impl OtgFsHcint1 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcintmsk1 {
    bits: u32,
}

impl OtgFsHcintmsk1 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcintmsk1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcintmsk1 { bits: 0u32 }
    }
}

impl OtgFsHcintmsk1 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHctsiz1 {
    bits: u32,
}

impl OtgFsHctsiz1 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgFsHctsiz1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHctsiz1 { bits: 0u32 }
    }
}

impl OtgFsHctsiz1 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcchar2 {
    bits: u32,
}

impl OtgFsHcchar2 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn mcnt(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgFsHcchar2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcchar2 { bits: 0u32 }
    }
}

impl OtgFsHcchar2 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn set_mcnt(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcint2 {
    bits: u32,
}

impl OtgFsHcint2 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcint2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcint2 { bits: 0u32 }
    }
}

impl OtgFsHcint2 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcintmsk2 {
    bits: u32,
}

impl OtgFsHcintmsk2 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcintmsk2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcintmsk2 { bits: 0u32 }
    }
}

impl OtgFsHcintmsk2 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHctsiz2 {
    bits: u32,
}

impl OtgFsHctsiz2 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgFsHctsiz2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHctsiz2 { bits: 0u32 }
    }
}

impl OtgFsHctsiz2 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcchar3 {
    bits: u32,
}

impl OtgFsHcchar3 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn mcnt(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgFsHcchar3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcchar3 { bits: 0u32 }
    }
}

impl OtgFsHcchar3 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn set_mcnt(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcint3 {
    bits: u32,
}

impl OtgFsHcint3 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcint3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcint3 { bits: 0u32 }
    }
}

impl OtgFsHcint3 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcintmsk3 {
    bits: u32,
}

impl OtgFsHcintmsk3 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcintmsk3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcintmsk3 { bits: 0u32 }
    }
}

impl OtgFsHcintmsk3 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHctsiz3 {
    bits: u32,
}

impl OtgFsHctsiz3 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgFsHctsiz3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHctsiz3 { bits: 0u32 }
    }
}

impl OtgFsHctsiz3 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcchar4 {
    bits: u32,
}

impl OtgFsHcchar4 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn mcnt(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgFsHcchar4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcchar4 { bits: 0u32 }
    }
}

impl OtgFsHcchar4 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn set_mcnt(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcint4 {
    bits: u32,
}

impl OtgFsHcint4 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcint4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcint4 { bits: 0u32 }
    }
}

impl OtgFsHcint4 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcintmsk4 {
    bits: u32,
}

impl OtgFsHcintmsk4 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcintmsk4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcintmsk4 { bits: 0u32 }
    }
}

impl OtgFsHcintmsk4 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHctsiz4 {
    bits: u32,
}

impl OtgFsHctsiz4 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgFsHctsiz4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHctsiz4 { bits: 0u32 }
    }
}

impl OtgFsHctsiz4 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcchar5 {
    bits: u32,
}

impl OtgFsHcchar5 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn mcnt(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgFsHcchar5 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcchar5 { bits: 0u32 }
    }
}

impl OtgFsHcchar5 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn set_mcnt(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcint5 {
    bits: u32,
}

impl OtgFsHcint5 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcint5 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcint5 { bits: 0u32 }
    }
}

impl OtgFsHcint5 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcintmsk5 {
    bits: u32,
}

impl OtgFsHcintmsk5 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcintmsk5 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcintmsk5 { bits: 0u32 }
    }
}

impl OtgFsHcintmsk5 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHctsiz5 {
    bits: u32,
}

impl OtgFsHctsiz5 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgFsHctsiz5 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHctsiz5 { bits: 0u32 }
    }
}

impl OtgFsHctsiz5 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcchar6 {
    bits: u32,
}

impl OtgFsHcchar6 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn mcnt(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgFsHcchar6 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcchar6 { bits: 0u32 }
    }
}

impl OtgFsHcchar6 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn set_mcnt(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcint6 {
    bits: u32,
}

impl OtgFsHcint6 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcint6 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcint6 { bits: 0u32 }
    }
}

impl OtgFsHcint6 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcintmsk6 {
    bits: u32,
}

impl OtgFsHcintmsk6 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcintmsk6 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcintmsk6 { bits: 0u32 }
    }
}

impl OtgFsHcintmsk6 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHctsiz6 {
    bits: u32,
}

impl OtgFsHctsiz6 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgFsHctsiz6 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHctsiz6 { bits: 0u32 }
    }
}

impl OtgFsHctsiz6 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcchar7 {
    bits: u32,
}

impl OtgFsHcchar7 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn mcnt(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgFsHcchar7 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcchar7 { bits: 0u32 }
    }
}

impl OtgFsHcchar7 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn set_mcnt(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcint7 {
    bits: u32,
}

impl OtgFsHcint7 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcint7 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcint7 { bits: 0u32 }
    }
}

impl OtgFsHcint7 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcintmsk7 {
    bits: u32,
}

impl OtgFsHcintmsk7 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcintmsk7 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcintmsk7 { bits: 0u32 }
    }
}

impl OtgFsHcintmsk7 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHctsiz7 {
    bits: u32,
}

impl OtgFsHctsiz7 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgFsHctsiz7 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHctsiz7 { bits: 0u32 }
    }
}

impl OtgFsHctsiz7 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcchar8 {
    bits: u32,
}

impl OtgFsHcchar8 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn mcnt(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgFsHcchar8 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcchar8 { bits: 0u32 }
    }
}

impl OtgFsHcchar8 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn set_mcnt(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcint8 {
    bits: u32,
}

impl OtgFsHcint8 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcint8 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcint8 { bits: 0u32 }
    }
}

impl OtgFsHcint8 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcintmsk8 {
    bits: u32,
}

impl OtgFsHcintmsk8 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcintmsk8 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcintmsk8 { bits: 0u32 }
    }
}

impl OtgFsHcintmsk8 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHctsiz8 {
    bits: u32,
}

impl OtgFsHctsiz8 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgFsHctsiz8 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHctsiz8 { bits: 0u32 }
    }
}

impl OtgFsHctsiz8 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcchar9 {
    bits: u32,
}

impl OtgFsHcchar9 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn mcnt(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgFsHcchar9 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcchar9 { bits: 0u32 }
    }
}

impl OtgFsHcchar9 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn set_mcnt(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcint9 {
    bits: u32,
}

impl OtgFsHcint9 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcint9 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcint9 { bits: 0u32 }
    }
}

impl OtgFsHcint9 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcintmsk9 {
    bits: u32,
}

impl OtgFsHcintmsk9 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcintmsk9 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcintmsk9 { bits: 0u32 }
    }
}

impl OtgFsHcintmsk9 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHctsiz9 {
    bits: u32,
}

impl OtgFsHctsiz9 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgFsHctsiz9 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHctsiz9 { bits: 0u32 }
    }
}

impl OtgFsHctsiz9 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcchar10 {
    bits: u32,
}

impl OtgFsHcchar10 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn mcnt(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgFsHcchar10 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcchar10 { bits: 0u32 }
    }
}

impl OtgFsHcchar10 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn set_mcnt(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcint10 {
    bits: u32,
}

impl OtgFsHcint10 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcint10 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcint10 { bits: 0u32 }
    }
}

impl OtgFsHcint10 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcintmsk10 {
    bits: u32,
}

impl OtgFsHcintmsk10 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcintmsk10 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcintmsk10 { bits: 0u32 }
    }
}

impl OtgFsHcintmsk10 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHctsiz10 {
    bits: u32,
}

impl OtgFsHctsiz10 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgFsHctsiz10 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHctsiz10 { bits: 0u32 }
    }
}

impl OtgFsHctsiz10 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcchar11 {
    bits: u32,
}

impl OtgFsHcchar11 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn mpsiz(&self) -> u16 {
        self.bits.get_range(0u8..11u8) as u16
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(11u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn epdir(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn lsdev(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn eptyp(&self) -> u8 {
        self.bits.get_range(18u8..20u8) as u8
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn mcnt(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn dad(&self) -> u8 {
        self.bits.get_range(22u8..29u8) as u8
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn oddfrm(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn chdis(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn chena(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgFsHcchar11 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcchar11 { bits: 0u32 }
    }
}

impl OtgFsHcchar11 {
    # [ doc = "Bits 0:10 - Maximum packet size" ]
    pub fn set_mpsiz(&mut self, value: u16) {
        self.bits.set_range(0u8..11u8, value as u32);
    }
    # [ doc = "Bits 11:14 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(11u8..15u8, value as u32);
    }
    # [ doc = "Bit 15 - Endpoint direction" ]
    pub fn set_epdir(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - Low-speed device" ]
    pub fn set_lsdev(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bits 18:19 - Endpoint type" ]
    pub fn set_eptyp(&mut self, value: u8) {
        self.bits.set_range(18u8..20u8, value as u32);
    }
    # [ doc = "Bits 20:21 - Multicount" ]
    pub fn set_mcnt(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 22:28 - Device address" ]
    pub fn set_dad(&mut self, value: u8) {
        self.bits.set_range(22u8..29u8, value as u32);
    }
    # [ doc = "Bit 29 - Odd frame" ]
    pub fn set_oddfrm(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Channel disable" ]
    pub fn set_chdis(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Channel enable" ]
    pub fn set_chena(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcint11 {
    bits: u32,
}

impl OtgFsHcint11 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn xfrc(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn chh(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn stall(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn nak(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn txerr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn bberr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn frmor(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn dterr(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcint11 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcint11 { bits: 0u32 }
    }
}

impl OtgFsHcint11 {
    # [ doc = "Bit 0 - Transfer completed" ]
    pub fn set_xfrc(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted" ]
    pub fn set_chh(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt" ]
    pub fn set_stall(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt" ]
    pub fn set_nak(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 7 - Transaction error" ]
    pub fn set_txerr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error" ]
    pub fn set_bberr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun" ]
    pub fn set_frmor(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error" ]
    pub fn set_dterr(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHcintmsk11 {
    bits: u32,
}

impl OtgFsHcintmsk11 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn xfrcm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn chhm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn stallm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn nakm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn ackm(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn nyet(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn txerrm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn bberrm(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn frmorm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn dterrm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
}

impl Default for OtgFsHcintmsk11 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHcintmsk11 { bits: 0u32 }
    }
}

impl OtgFsHcintmsk11 {
    # [ doc = "Bit 0 - Transfer completed mask" ]
    pub fn set_xfrcm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Channel halted mask" ]
    pub fn set_chhm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - STALL response received interrupt mask" ]
    pub fn set_stallm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - NAK response received interrupt mask" ]
    pub fn set_nakm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - ACK response received/transmitted interrupt mask" ]
    pub fn set_ackm(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - response received interrupt mask" ]
    pub fn set_nyet(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Transaction error mask" ]
    pub fn set_txerrm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Babble error mask" ]
    pub fn set_bberrm(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Frame overrun mask" ]
    pub fn set_frmorm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Data toggle error mask" ]
    pub fn set_dterrm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgFsHctsiz11 {
    bits: u32,
}

impl OtgFsHctsiz11 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn xfrsiz(&self) -> u32 {
        self.bits.get_range(0u8..19u8) as u32
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn pktcnt(&self) -> u16 {
        self.bits.get_range(19u8..29u8) as u16
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(29u8..31u8) as u8
    }
}

impl Default for OtgFsHctsiz11 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgFsHctsiz11 { bits: 0u32 }
    }
}

impl OtgFsHctsiz11 {
    # [ doc = "Bits 0:18 - Transfer size" ]
    pub fn set_xfrsiz(&mut self, value: u32) {
        self.bits.set_range(0u8..19u8, value as u32);
    }
    # [ doc = "Bits 19:28 - Packet count" ]
    pub fn set_pktcnt(&mut self, value: u16) {
        self.bits.set_range(19u8..29u8, value as u32);
    }
    # [ doc = "Bits 29:30 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(29u8..31u8, value as u32);
    }
}
