// autogenerated

use volatile;
use bit_field::BitField;

# [ doc = "Analog-to-digital converter" ]
# [ repr ( C ) ]
pub struct Adc {
    # [ doc = "0x00 - status register" ]
    pub sr: volatile::ReadWrite<Sr>,
    # [ doc = "0x04 - control register 1" ]
    pub cr1: volatile::ReadWrite<Cr1>,
    # [ doc = "0x08 - control register 2" ]
    pub cr2: volatile::ReadWrite<Cr2>,
    # [ doc = "0x0c - sample time register 1" ]
    pub smpr1: volatile::ReadWrite<Smpr1>,
    # [ doc = "0x10 - sample time register 2" ]
    pub smpr2: volatile::ReadWrite<Smpr2>,
    # [ doc = "0x14 - injected channel data offset register x" ]
    pub jofr1: volatile::ReadWrite<Jofr1>,
    # [ doc = "0x18 - injected channel data offset register x" ]
    pub jofr2: volatile::ReadWrite<Jofr2>,
    # [ doc = "0x1c - injected channel data offset register x" ]
    pub jofr3: volatile::ReadWrite<Jofr3>,
    # [ doc = "0x20 - injected channel data offset register x" ]
    pub jofr4: volatile::ReadWrite<Jofr4>,
    # [ doc = "0x24 - watchdog higher threshold register" ]
    pub htr: volatile::ReadWrite<Htr>,
    # [ doc = "0x28 - watchdog lower threshold register" ]
    pub ltr: volatile::ReadWrite<Ltr>,
    # [ doc = "0x2c - regular sequence register 1" ]
    pub sqr1: volatile::ReadWrite<Sqr1>,
    # [ doc = "0x30 - regular sequence register 2" ]
    pub sqr2: volatile::ReadWrite<Sqr2>,
    # [ doc = "0x34 - regular sequence register 3" ]
    pub sqr3: volatile::ReadWrite<Sqr3>,
    # [ doc = "0x38 - injected sequence register" ]
    pub jsqr: volatile::ReadWrite<Jsqr>,
    # [ doc = "0x3c - injected data register x" ]
    pub jdr1: volatile::ReadOnly<Jdr1>,
    # [ doc = "0x40 - injected data register x" ]
    pub jdr2: volatile::ReadOnly<Jdr2>,
    # [ doc = "0x44 - injected data register x" ]
    pub jdr3: volatile::ReadOnly<Jdr3>,
    # [ doc = "0x48 - injected data register x" ]
    pub jdr4: volatile::ReadOnly<Jdr4>,
    # [ doc = "0x4c - regular data register" ]
    pub dr: volatile::ReadOnly<Dr>,
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Sr {
    bits: u32,
}

impl Sr {
    # [ doc = "Bit 5 - Overrun" ]
    pub fn ovr(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Regular channel start flag" ]
    pub fn strt(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Injected channel start flag" ]
    pub fn jstrt(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Injected channel end of conversion" ]
    pub fn jeoc(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Regular channel end of conversion" ]
    pub fn eoc(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Analog watchdog flag" ]
    pub fn awd(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Sr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Sr { bits: 0u32 }
    }
}

impl Sr {
    # [ doc = "Bit 5 - Overrun" ]
    pub fn set_ovr(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Regular channel start flag" ]
    pub fn set_strt(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Injected channel start flag" ]
    pub fn set_jstrt(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Injected channel end of conversion" ]
    pub fn set_jeoc(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Regular channel end of conversion" ]
    pub fn set_eoc(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Analog watchdog flag" ]
    pub fn set_awd(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Cr1 {
    bits: u32,
}

impl Cr1 {
    # [ doc = "Bit 26 - Overrun interrupt enable" ]
    pub fn ovrie(&self) -> bool {
        self.bits.get_bit(26u8)
    }
    # [ doc = "Bits 24:25 - Resolution" ]
    pub fn res(&self) -> u8 {
        self.bits.get_range(24u8..26u8) as u8
    }
    # [ doc = "Bit 23 - Analog watchdog enable on regular channels" ]
    pub fn awden(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bit 22 - Analog watchdog enable on injected channels" ]
    pub fn jawden(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bits 13:15 - Discontinuous mode channel count" ]
    pub fn discnum(&self) -> u8 {
        self.bits.get_range(13u8..16u8) as u8
    }
    # [ doc = "Bit 12 - Discontinuous mode on injected channels" ]
    pub fn jdiscen(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 11 - Discontinuous mode on regular channels" ]
    pub fn discen(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 10 - Automatic injected group conversion" ]
    pub fn jauto(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - Enable the watchdog on a single channel in scan mode" ]
    pub fn awdsgl(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - Scan mode" ]
    pub fn scan(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 7 - Interrupt enable for injected channels" ]
    pub fn jeocie(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 6 - Analog watchdog interrupt enable" ]
    pub fn awdie(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 5 - Interrupt enable for EOC" ]
    pub fn eocie(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bits 0:4 - Analog watchdog channel select bits" ]
    pub fn awdch(&self) -> u8 {
        self.bits.get_range(0u8..5u8) as u8
    }
}

impl Default for Cr1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Cr1 { bits: 0u32 }
    }
}

impl Cr1 {
    # [ doc = "Bit 26 - Overrun interrupt enable" ]
    pub fn set_ovrie(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bits 24:25 - Resolution" ]
    pub fn set_res(&mut self, value: u8) {
        self.bits.set_range(24u8..26u8, value as u32);
    }
    # [ doc = "Bit 23 - Analog watchdog enable on regular channels" ]
    pub fn set_awden(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 22 - Analog watchdog enable on injected channels" ]
    pub fn set_jawden(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bits 13:15 - Discontinuous mode channel count" ]
    pub fn set_discnum(&mut self, value: u8) {
        self.bits.set_range(13u8..16u8, value as u32);
    }
    # [ doc = "Bit 12 - Discontinuous mode on injected channels" ]
    pub fn set_jdiscen(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 11 - Discontinuous mode on regular channels" ]
    pub fn set_discen(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 10 - Automatic injected group conversion" ]
    pub fn set_jauto(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - Enable the watchdog on a single channel in scan mode" ]
    pub fn set_awdsgl(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - Scan mode" ]
    pub fn set_scan(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 7 - Interrupt enable for injected channels" ]
    pub fn set_jeocie(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 6 - Analog watchdog interrupt enable" ]
    pub fn set_awdie(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 5 - Interrupt enable for EOC" ]
    pub fn set_eocie(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bits 0:4 - Analog watchdog channel select bits" ]
    pub fn set_awdch(&mut self, value: u8) {
        self.bits.set_range(0u8..5u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Cr2 {
    bits: u32,
}

impl Cr2 {
    # [ doc = "Bit 30 - Start conversion of regular channels" ]
    pub fn swstart(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bits 28:29 - External trigger enable for regular channels" ]
    pub fn exten(&self) -> u8 {
        self.bits.get_range(28u8..30u8) as u8
    }
    # [ doc = "Bits 24:27 - External event select for regular group" ]
    pub fn extsel(&self) -> u8 {
        self.bits.get_range(24u8..28u8) as u8
    }
    # [ doc = "Bit 22 - Start conversion of injected channels" ]
    pub fn jswstart(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bits 20:21 - External trigger enable for injected channels" ]
    pub fn jexten(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 16:19 - External event select for injected group" ]
    pub fn jextsel(&self) -> u8 {
        self.bits.get_range(16u8..20u8) as u8
    }
    # [ doc = "Bit 11 - Data alignment" ]
    pub fn align(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 10 - End of conversion selection" ]
    pub fn eocs(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - DMA disable selection (for single ADC mode)" ]
    pub fn dds(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - Direct memory access mode (for single ADC mode)" ]
    pub fn dma(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 1 - Continuous conversion" ]
    pub fn cont(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - A/D Converter ON / OFF" ]
    pub fn adon(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Cr2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Cr2 { bits: 0u32 }
    }
}

impl Cr2 {
    # [ doc = "Bit 30 - Start conversion of regular channels" ]
    pub fn set_swstart(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bits 28:29 - External trigger enable for regular channels" ]
    pub fn set_exten(&mut self, value: u8) {
        self.bits.set_range(28u8..30u8, value as u32);
    }
    # [ doc = "Bits 24:27 - External event select for regular group" ]
    pub fn set_extsel(&mut self, value: u8) {
        self.bits.set_range(24u8..28u8, value as u32);
    }
    # [ doc = "Bit 22 - Start conversion of injected channels" ]
    pub fn set_jswstart(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bits 20:21 - External trigger enable for injected channels" ]
    pub fn set_jexten(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 16:19 - External event select for injected group" ]
    pub fn set_jextsel(&mut self, value: u8) {
        self.bits.set_range(16u8..20u8, value as u32);
    }
    # [ doc = "Bit 11 - Data alignment" ]
    pub fn set_align(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 10 - End of conversion selection" ]
    pub fn set_eocs(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - DMA disable selection (for single ADC mode)" ]
    pub fn set_dds(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - Direct memory access mode (for single ADC mode)" ]
    pub fn set_dma(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 1 - Continuous conversion" ]
    pub fn set_cont(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - A/D Converter ON / OFF" ]
    pub fn set_adon(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Smpr1 {
    bits: u32,
}

impl Smpr1 {
    # [ doc = "Bits 24:26 - Sample time bits" ]
    pub fn smp18(&self) -> u8 {
        self.bits.get_range(24u8..27u8) as u8
    }
    # [ doc = "Bits 21:23 - Sample time bits" ]
    pub fn smp17(&self) -> u8 {
        self.bits.get_range(21u8..24u8) as u8
    }
    # [ doc = "Bits 18:20 - Sample time bits" ]
    pub fn smp16(&self) -> u8 {
        self.bits.get_range(18u8..21u8) as u8
    }
    # [ doc = "Bits 15:17 - Sample time bits" ]
    pub fn smp15(&self) -> u8 {
        self.bits.get_range(15u8..18u8) as u8
    }
    # [ doc = "Bits 12:14 - Sample time bits" ]
    pub fn smp14(&self) -> u8 {
        self.bits.get_range(12u8..15u8) as u8
    }
    # [ doc = "Bits 9:11 - Sample time bits" ]
    pub fn smp13(&self) -> u8 {
        self.bits.get_range(9u8..12u8) as u8
    }
    # [ doc = "Bits 6:8 - Sample time bits" ]
    pub fn smp12(&self) -> u8 {
        self.bits.get_range(6u8..9u8) as u8
    }
    # [ doc = "Bits 3:5 - Sample time bits" ]
    pub fn smp11(&self) -> u8 {
        self.bits.get_range(3u8..6u8) as u8
    }
    # [ doc = "Bits 0:2 - Sample time bits" ]
    pub fn smp10(&self) -> u8 {
        self.bits.get_range(0u8..3u8) as u8
    }
}

impl Default for Smpr1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Smpr1 { bits: 0u32 }
    }
}

impl Smpr1 {
    # [ doc = "Bits 24:26 - Sample time bits" ]
    pub fn set_smp18(&mut self, value: u8) {
        self.bits.set_range(24u8..27u8, value as u32);
    }
    # [ doc = "Bits 21:23 - Sample time bits" ]
    pub fn set_smp17(&mut self, value: u8) {
        self.bits.set_range(21u8..24u8, value as u32);
    }
    # [ doc = "Bits 18:20 - Sample time bits" ]
    pub fn set_smp16(&mut self, value: u8) {
        self.bits.set_range(18u8..21u8, value as u32);
    }
    # [ doc = "Bits 15:17 - Sample time bits" ]
    pub fn set_smp15(&mut self, value: u8) {
        self.bits.set_range(15u8..18u8, value as u32);
    }
    # [ doc = "Bits 12:14 - Sample time bits" ]
    pub fn set_smp14(&mut self, value: u8) {
        self.bits.set_range(12u8..15u8, value as u32);
    }
    # [ doc = "Bits 9:11 - Sample time bits" ]
    pub fn set_smp13(&mut self, value: u8) {
        self.bits.set_range(9u8..12u8, value as u32);
    }
    # [ doc = "Bits 6:8 - Sample time bits" ]
    pub fn set_smp12(&mut self, value: u8) {
        self.bits.set_range(6u8..9u8, value as u32);
    }
    # [ doc = "Bits 3:5 - Sample time bits" ]
    pub fn set_smp11(&mut self, value: u8) {
        self.bits.set_range(3u8..6u8, value as u32);
    }
    # [ doc = "Bits 0:2 - Sample time bits" ]
    pub fn set_smp10(&mut self, value: u8) {
        self.bits.set_range(0u8..3u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Smpr2 {
    bits: u32,
}

impl Smpr2 {
    # [ doc = "Bits 27:29 - Sample time bits" ]
    pub fn smp9(&self) -> u8 {
        self.bits.get_range(27u8..30u8) as u8
    }
    # [ doc = "Bits 24:26 - Sample time bits" ]
    pub fn smp8(&self) -> u8 {
        self.bits.get_range(24u8..27u8) as u8
    }
    # [ doc = "Bits 21:23 - Sample time bits" ]
    pub fn smp7(&self) -> u8 {
        self.bits.get_range(21u8..24u8) as u8
    }
    # [ doc = "Bits 18:20 - Sample time bits" ]
    pub fn smp6(&self) -> u8 {
        self.bits.get_range(18u8..21u8) as u8
    }
    # [ doc = "Bits 15:17 - Sample time bits" ]
    pub fn smp5(&self) -> u8 {
        self.bits.get_range(15u8..18u8) as u8
    }
    # [ doc = "Bits 12:14 - Sample time bits" ]
    pub fn smp4(&self) -> u8 {
        self.bits.get_range(12u8..15u8) as u8
    }
    # [ doc = "Bits 9:11 - Sample time bits" ]
    pub fn smp3(&self) -> u8 {
        self.bits.get_range(9u8..12u8) as u8
    }
    # [ doc = "Bits 6:8 - Sample time bits" ]
    pub fn smp2(&self) -> u8 {
        self.bits.get_range(6u8..9u8) as u8
    }
    # [ doc = "Bits 3:5 - Sample time bits" ]
    pub fn smp1(&self) -> u8 {
        self.bits.get_range(3u8..6u8) as u8
    }
    # [ doc = "Bits 0:2 - Sample time bits" ]
    pub fn smp0(&self) -> u8 {
        self.bits.get_range(0u8..3u8) as u8
    }
}

impl Default for Smpr2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Smpr2 { bits: 0u32 }
    }
}

impl Smpr2 {
    # [ doc = "Bits 27:29 - Sample time bits" ]
    pub fn set_smp9(&mut self, value: u8) {
        self.bits.set_range(27u8..30u8, value as u32);
    }
    # [ doc = "Bits 24:26 - Sample time bits" ]
    pub fn set_smp8(&mut self, value: u8) {
        self.bits.set_range(24u8..27u8, value as u32);
    }
    # [ doc = "Bits 21:23 - Sample time bits" ]
    pub fn set_smp7(&mut self, value: u8) {
        self.bits.set_range(21u8..24u8, value as u32);
    }
    # [ doc = "Bits 18:20 - Sample time bits" ]
    pub fn set_smp6(&mut self, value: u8) {
        self.bits.set_range(18u8..21u8, value as u32);
    }
    # [ doc = "Bits 15:17 - Sample time bits" ]
    pub fn set_smp5(&mut self, value: u8) {
        self.bits.set_range(15u8..18u8, value as u32);
    }
    # [ doc = "Bits 12:14 - Sample time bits" ]
    pub fn set_smp4(&mut self, value: u8) {
        self.bits.set_range(12u8..15u8, value as u32);
    }
    # [ doc = "Bits 9:11 - Sample time bits" ]
    pub fn set_smp3(&mut self, value: u8) {
        self.bits.set_range(9u8..12u8, value as u32);
    }
    # [ doc = "Bits 6:8 - Sample time bits" ]
    pub fn set_smp2(&mut self, value: u8) {
        self.bits.set_range(6u8..9u8, value as u32);
    }
    # [ doc = "Bits 3:5 - Sample time bits" ]
    pub fn set_smp1(&mut self, value: u8) {
        self.bits.set_range(3u8..6u8, value as u32);
    }
    # [ doc = "Bits 0:2 - Sample time bits" ]
    pub fn set_smp0(&mut self, value: u8) {
        self.bits.set_range(0u8..3u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Jofr1 {
    bits: u32,
}

impl Jofr1 {
    # [ doc = "Bits 0:11 - Data offset for injected channel x" ]
    pub fn joffset1(&self) -> u16 {
        self.bits.get_range(0u8..12u8) as u16
    }
}

impl Default for Jofr1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Jofr1 { bits: 0u32 }
    }
}

impl Jofr1 {
    # [ doc = "Bits 0:11 - Data offset for injected channel x" ]
    pub fn set_joffset1(&mut self, value: u16) {
        self.bits.set_range(0u8..12u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Jofr2 {
    bits: u32,
}

impl Jofr2 {
    # [ doc = "Bits 0:11 - Data offset for injected channel x" ]
    pub fn joffset2(&self) -> u16 {
        self.bits.get_range(0u8..12u8) as u16
    }
}

impl Default for Jofr2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Jofr2 { bits: 0u32 }
    }
}

impl Jofr2 {
    # [ doc = "Bits 0:11 - Data offset for injected channel x" ]
    pub fn set_joffset2(&mut self, value: u16) {
        self.bits.set_range(0u8..12u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Jofr3 {
    bits: u32,
}

impl Jofr3 {
    # [ doc = "Bits 0:11 - Data offset for injected channel x" ]
    pub fn joffset3(&self) -> u16 {
        self.bits.get_range(0u8..12u8) as u16
    }
}

impl Default for Jofr3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Jofr3 { bits: 0u32 }
    }
}

impl Jofr3 {
    # [ doc = "Bits 0:11 - Data offset for injected channel x" ]
    pub fn set_joffset3(&mut self, value: u16) {
        self.bits.set_range(0u8..12u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Jofr4 {
    bits: u32,
}

impl Jofr4 {
    # [ doc = "Bits 0:11 - Data offset for injected channel x" ]
    pub fn joffset4(&self) -> u16 {
        self.bits.get_range(0u8..12u8) as u16
    }
}

impl Default for Jofr4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Jofr4 { bits: 0u32 }
    }
}

impl Jofr4 {
    # [ doc = "Bits 0:11 - Data offset for injected channel x" ]
    pub fn set_joffset4(&mut self, value: u16) {
        self.bits.set_range(0u8..12u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Htr {
    bits: u32,
}

impl Htr {
    # [ doc = "Bits 0:11 - Analog watchdog higher threshold" ]
    pub fn ht(&self) -> u16 {
        self.bits.get_range(0u8..12u8) as u16
    }
}

impl Default for Htr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Htr { bits: 4095u32 }
    }
}

impl Htr {
    # [ doc = "Bits 0:11 - Analog watchdog higher threshold" ]
    pub fn set_ht(&mut self, value: u16) {
        self.bits.set_range(0u8..12u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ltr {
    bits: u32,
}

impl Ltr {
    # [ doc = "Bits 0:11 - Analog watchdog lower threshold" ]
    pub fn lt(&self) -> u16 {
        self.bits.get_range(0u8..12u8) as u16
    }
}

impl Default for Ltr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ltr { bits: 0u32 }
    }
}

impl Ltr {
    # [ doc = "Bits 0:11 - Analog watchdog lower threshold" ]
    pub fn set_lt(&mut self, value: u16) {
        self.bits.set_range(0u8..12u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Sqr1 {
    bits: u32,
}

impl Sqr1 {
    # [ doc = "Bits 20:23 - Regular channel sequence length" ]
    pub fn l(&self) -> u8 {
        self.bits.get_range(20u8..24u8) as u8
    }
    # [ doc = "Bits 15:19 - 16th conversion in regular sequence" ]
    pub fn sq16(&self) -> u8 {
        self.bits.get_range(15u8..20u8) as u8
    }
    # [ doc = "Bits 10:14 - 15th conversion in regular sequence" ]
    pub fn sq15(&self) -> u8 {
        self.bits.get_range(10u8..15u8) as u8
    }
    # [ doc = "Bits 5:9 - 14th conversion in regular sequence" ]
    pub fn sq14(&self) -> u8 {
        self.bits.get_range(5u8..10u8) as u8
    }
    # [ doc = "Bits 0:4 - 13th conversion in regular sequence" ]
    pub fn sq13(&self) -> u8 {
        self.bits.get_range(0u8..5u8) as u8
    }
}

impl Default for Sqr1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Sqr1 { bits: 0u32 }
    }
}

impl Sqr1 {
    # [ doc = "Bits 20:23 - Regular channel sequence length" ]
    pub fn set_l(&mut self, value: u8) {
        self.bits.set_range(20u8..24u8, value as u32);
    }
    # [ doc = "Bits 15:19 - 16th conversion in regular sequence" ]
    pub fn set_sq16(&mut self, value: u8) {
        self.bits.set_range(15u8..20u8, value as u32);
    }
    # [ doc = "Bits 10:14 - 15th conversion in regular sequence" ]
    pub fn set_sq15(&mut self, value: u8) {
        self.bits.set_range(10u8..15u8, value as u32);
    }
    # [ doc = "Bits 5:9 - 14th conversion in regular sequence" ]
    pub fn set_sq14(&mut self, value: u8) {
        self.bits.set_range(5u8..10u8, value as u32);
    }
    # [ doc = "Bits 0:4 - 13th conversion in regular sequence" ]
    pub fn set_sq13(&mut self, value: u8) {
        self.bits.set_range(0u8..5u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Sqr2 {
    bits: u32,
}

impl Sqr2 {
    # [ doc = "Bits 25:29 - 12th conversion in regular sequence" ]
    pub fn sq12(&self) -> u8 {
        self.bits.get_range(25u8..30u8) as u8
    }
    # [ doc = "Bits 20:24 - 11th conversion in regular sequence" ]
    pub fn sq11(&self) -> u8 {
        self.bits.get_range(20u8..25u8) as u8
    }
    # [ doc = "Bits 15:19 - 10th conversion in regular sequence" ]
    pub fn sq10(&self) -> u8 {
        self.bits.get_range(15u8..20u8) as u8
    }
    # [ doc = "Bits 10:14 - 9th conversion in regular sequence" ]
    pub fn sq9(&self) -> u8 {
        self.bits.get_range(10u8..15u8) as u8
    }
    # [ doc = "Bits 5:9 - 8th conversion in regular sequence" ]
    pub fn sq8(&self) -> u8 {
        self.bits.get_range(5u8..10u8) as u8
    }
    # [ doc = "Bits 0:4 - 7th conversion in regular sequence" ]
    pub fn sq7(&self) -> u8 {
        self.bits.get_range(0u8..5u8) as u8
    }
}

impl Default for Sqr2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Sqr2 { bits: 0u32 }
    }
}

impl Sqr2 {
    # [ doc = "Bits 25:29 - 12th conversion in regular sequence" ]
    pub fn set_sq12(&mut self, value: u8) {
        self.bits.set_range(25u8..30u8, value as u32);
    }
    # [ doc = "Bits 20:24 - 11th conversion in regular sequence" ]
    pub fn set_sq11(&mut self, value: u8) {
        self.bits.set_range(20u8..25u8, value as u32);
    }
    # [ doc = "Bits 15:19 - 10th conversion in regular sequence" ]
    pub fn set_sq10(&mut self, value: u8) {
        self.bits.set_range(15u8..20u8, value as u32);
    }
    # [ doc = "Bits 10:14 - 9th conversion in regular sequence" ]
    pub fn set_sq9(&mut self, value: u8) {
        self.bits.set_range(10u8..15u8, value as u32);
    }
    # [ doc = "Bits 5:9 - 8th conversion in regular sequence" ]
    pub fn set_sq8(&mut self, value: u8) {
        self.bits.set_range(5u8..10u8, value as u32);
    }
    # [ doc = "Bits 0:4 - 7th conversion in regular sequence" ]
    pub fn set_sq7(&mut self, value: u8) {
        self.bits.set_range(0u8..5u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Sqr3 {
    bits: u32,
}

impl Sqr3 {
    # [ doc = "Bits 25:29 - 6th conversion in regular sequence" ]
    pub fn sq6(&self) -> u8 {
        self.bits.get_range(25u8..30u8) as u8
    }
    # [ doc = "Bits 20:24 - 5th conversion in regular sequence" ]
    pub fn sq5(&self) -> u8 {
        self.bits.get_range(20u8..25u8) as u8
    }
    # [ doc = "Bits 15:19 - 4th conversion in regular sequence" ]
    pub fn sq4(&self) -> u8 {
        self.bits.get_range(15u8..20u8) as u8
    }
    # [ doc = "Bits 10:14 - 3rd conversion in regular sequence" ]
    pub fn sq3(&self) -> u8 {
        self.bits.get_range(10u8..15u8) as u8
    }
    # [ doc = "Bits 5:9 - 2nd conversion in regular sequence" ]
    pub fn sq2(&self) -> u8 {
        self.bits.get_range(5u8..10u8) as u8
    }
    # [ doc = "Bits 0:4 - 1st conversion in regular sequence" ]
    pub fn sq1(&self) -> u8 {
        self.bits.get_range(0u8..5u8) as u8
    }
}

impl Default for Sqr3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Sqr3 { bits: 0u32 }
    }
}

impl Sqr3 {
    # [ doc = "Bits 25:29 - 6th conversion in regular sequence" ]
    pub fn set_sq6(&mut self, value: u8) {
        self.bits.set_range(25u8..30u8, value as u32);
    }
    # [ doc = "Bits 20:24 - 5th conversion in regular sequence" ]
    pub fn set_sq5(&mut self, value: u8) {
        self.bits.set_range(20u8..25u8, value as u32);
    }
    # [ doc = "Bits 15:19 - 4th conversion in regular sequence" ]
    pub fn set_sq4(&mut self, value: u8) {
        self.bits.set_range(15u8..20u8, value as u32);
    }
    # [ doc = "Bits 10:14 - 3rd conversion in regular sequence" ]
    pub fn set_sq3(&mut self, value: u8) {
        self.bits.set_range(10u8..15u8, value as u32);
    }
    # [ doc = "Bits 5:9 - 2nd conversion in regular sequence" ]
    pub fn set_sq2(&mut self, value: u8) {
        self.bits.set_range(5u8..10u8, value as u32);
    }
    # [ doc = "Bits 0:4 - 1st conversion in regular sequence" ]
    pub fn set_sq1(&mut self, value: u8) {
        self.bits.set_range(0u8..5u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Jsqr {
    bits: u32,
}

impl Jsqr {
    # [ doc = "Bits 20:21 - Injected sequence length" ]
    pub fn jl(&self) -> u8 {
        self.bits.get_range(20u8..22u8) as u8
    }
    # [ doc = "Bits 15:19 - 4th conversion in injected sequence" ]
    pub fn jsq4(&self) -> u8 {
        self.bits.get_range(15u8..20u8) as u8
    }
    # [ doc = "Bits 10:14 - 3rd conversion in injected sequence" ]
    pub fn jsq3(&self) -> u8 {
        self.bits.get_range(10u8..15u8) as u8
    }
    # [ doc = "Bits 5:9 - 2nd conversion in injected sequence" ]
    pub fn jsq2(&self) -> u8 {
        self.bits.get_range(5u8..10u8) as u8
    }
    # [ doc = "Bits 0:4 - 1st conversion in injected sequence" ]
    pub fn jsq1(&self) -> u8 {
        self.bits.get_range(0u8..5u8) as u8
    }
}

impl Default for Jsqr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Jsqr { bits: 0u32 }
    }
}

impl Jsqr {
    # [ doc = "Bits 20:21 - Injected sequence length" ]
    pub fn set_jl(&mut self, value: u8) {
        self.bits.set_range(20u8..22u8, value as u32);
    }
    # [ doc = "Bits 15:19 - 4th conversion in injected sequence" ]
    pub fn set_jsq4(&mut self, value: u8) {
        self.bits.set_range(15u8..20u8, value as u32);
    }
    # [ doc = "Bits 10:14 - 3rd conversion in injected sequence" ]
    pub fn set_jsq3(&mut self, value: u8) {
        self.bits.set_range(10u8..15u8, value as u32);
    }
    # [ doc = "Bits 5:9 - 2nd conversion in injected sequence" ]
    pub fn set_jsq2(&mut self, value: u8) {
        self.bits.set_range(5u8..10u8, value as u32);
    }
    # [ doc = "Bits 0:4 - 1st conversion in injected sequence" ]
    pub fn set_jsq1(&mut self, value: u8) {
        self.bits.set_range(0u8..5u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Jdr1 {
    bits: u32,
}

impl Jdr1 {
    # [ doc = "Bits 0:15 - Injected data" ]
    pub fn jdata(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for Jdr1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Jdr1 { bits: 0u32 }
    }
}

impl Jdr1 {
    # [ doc = "Bits 0:15 - Injected data" ]
    pub fn set_jdata(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Jdr2 {
    bits: u32,
}

impl Jdr2 {
    # [ doc = "Bits 0:15 - Injected data" ]
    pub fn jdata(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for Jdr2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Jdr2 { bits: 0u32 }
    }
}

impl Jdr2 {
    # [ doc = "Bits 0:15 - Injected data" ]
    pub fn set_jdata(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Jdr3 {
    bits: u32,
}

impl Jdr3 {
    # [ doc = "Bits 0:15 - Injected data" ]
    pub fn jdata(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for Jdr3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Jdr3 { bits: 0u32 }
    }
}

impl Jdr3 {
    # [ doc = "Bits 0:15 - Injected data" ]
    pub fn set_jdata(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Jdr4 {
    bits: u32,
}

impl Jdr4 {
    # [ doc = "Bits 0:15 - Injected data" ]
    pub fn jdata(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for Jdr4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Jdr4 { bits: 0u32 }
    }
}

impl Jdr4 {
    # [ doc = "Bits 0:15 - Injected data" ]
    pub fn set_jdata(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Dr {
    bits: u32,
}

impl Dr {
    # [ doc = "Bits 0:15 - Regular data" ]
    pub fn data(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for Dr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Dr { bits: 0u32 }
    }
}

impl Dr {
    # [ doc = "Bits 0:15 - Regular data" ]
    pub fn set_data(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}
