// autogenerated

use volatile;
use bit_field::BitField;

# [ doc = "Receiver Interface" ]
# [ repr ( C ) ]
pub struct SpdifRx {
    # [ doc = "0x00 - Control register" ]
    pub cr: volatile::ReadWrite<Cr>,
    # [ doc = "0x04 - Interrupt mask register" ]
    pub imr: volatile::ReadWrite<Imr>,
    # [ doc = "0x08 - Status register" ]
    pub sr: volatile::ReadOnly<Sr>,
    # [ doc = "0x0c - Interrupt Flag Clear register" ]
    pub ifcr: volatile::WriteOnly<Ifcr>,
    # [ doc = "0x10 - Data input register" ]
    pub dr: volatile::ReadOnly<Dr>,
    # [ doc = "0x14 - Channel Status register" ]
    pub csr: volatile::ReadOnly<Csr>,
    # [ doc = "0x18 - Debug Information register" ]
    pub dir: volatile::ReadOnly<Dir>,
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Cr {
    bits: u32,
}

impl Cr {
    # [ doc = "Bits 0:1 - Peripheral Block Enable" ]
    pub fn spdifen(&self) -> u8 {
        self.bits.get_range(0u8..2u8) as u8
    }
    # [ doc = "Bit 2 - Receiver DMA ENable for data flow" ]
    pub fn rxdmaen(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - STerEO Mode" ]
    pub fn rxsteo(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bits 4:5 - RX Data format" ]
    pub fn drfmt(&self) -> u8 {
        self.bits.get_range(4u8..6u8) as u8
    }
    # [ doc = "Bit 6 - Mask Parity error bit" ]
    pub fn pmsk(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Mask of Validity bit" ]
    pub fn vmsk(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Mask of channel status and user bits" ]
    pub fn cumsk(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Mask of Preamble Type bits" ]
    pub fn ptmsk(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Control Buffer DMA ENable for control flow" ]
    pub fn cbdmaen(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 11 - Channel Selection" ]
    pub fn chsel(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bits 12:13 - Maximum allowed re-tries during synchronization phase" ]
    pub fn nbtr(&self) -> u8 {
        self.bits.get_range(12u8..14u8) as u8
    }
    # [ doc = "Bit 14 - Wait For Activity" ]
    pub fn wfa(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bits 16:18 - input selection" ]
    pub fn insel(&self) -> u8 {
        self.bits.get_range(16u8..19u8) as u8
    }
}

impl Default for Cr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Cr { bits: 0u32 }
    }
}

impl Cr {
    # [ doc = "Bits 0:1 - Peripheral Block Enable" ]
    pub fn set_spdifen(&mut self, value: u8) {
        self.bits.set_range(0u8..2u8, value as u32);
    }
    # [ doc = "Bit 2 - Receiver DMA ENable for data flow" ]
    pub fn set_rxdmaen(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - STerEO Mode" ]
    pub fn set_rxsteo(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bits 4:5 - RX Data format" ]
    pub fn set_drfmt(&mut self, value: u8) {
        self.bits.set_range(4u8..6u8, value as u32);
    }
    # [ doc = "Bit 6 - Mask Parity error bit" ]
    pub fn set_pmsk(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Mask of Validity bit" ]
    pub fn set_vmsk(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Mask of channel status and user bits" ]
    pub fn set_cumsk(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Mask of Preamble Type bits" ]
    pub fn set_ptmsk(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Control Buffer DMA ENable for control flow" ]
    pub fn set_cbdmaen(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 11 - Channel Selection" ]
    pub fn set_chsel(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bits 12:13 - Maximum allowed re-tries during synchronization phase" ]
    pub fn set_nbtr(&mut self, value: u8) {
        self.bits.set_range(12u8..14u8, value as u32);
    }
    # [ doc = "Bit 14 - Wait For Activity" ]
    pub fn set_wfa(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bits 16:18 - input selection" ]
    pub fn set_insel(&mut self, value: u8) {
        self.bits.set_range(16u8..19u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Imr {
    bits: u32,
}

impl Imr {
    # [ doc = "Bit 0 - RXNE interrupt enable" ]
    pub fn rxneie(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Control Buffer Ready Interrupt Enable" ]
    pub fn csrneie(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - Parity error interrupt enable" ]
    pub fn perrie(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - Overrun error Interrupt Enable" ]
    pub fn ovrie(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - Synchronization Block Detected Interrupt Enable" ]
    pub fn sblkie(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - Synchronization Done" ]
    pub fn syncdie(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Serial Interface Error Interrupt Enable" ]
    pub fn ifeie(&self) -> bool {
        self.bits.get_bit(6u8)
    }
}

impl Default for Imr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Imr { bits: 0u32 }
    }
}

impl Imr {
    # [ doc = "Bit 0 - RXNE interrupt enable" ]
    pub fn set_rxneie(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Control Buffer Ready Interrupt Enable" ]
    pub fn set_csrneie(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - Parity error interrupt enable" ]
    pub fn set_perrie(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - Overrun error Interrupt Enable" ]
    pub fn set_ovrie(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - Synchronization Block Detected Interrupt Enable" ]
    pub fn set_sblkie(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - Synchronization Done" ]
    pub fn set_syncdie(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Serial Interface Error Interrupt Enable" ]
    pub fn set_ifeie(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Sr {
    bits: u32,
}

impl Sr {
    # [ doc = "Bit 0 - Read data register not empty" ]
    pub fn rxne(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Control Buffer register is not empty" ]
    pub fn csrne(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - Parity error" ]
    pub fn perr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - Overrun error" ]
    pub fn ovr(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - Synchronization Block Detected" ]
    pub fn sbd(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - Synchronization Done" ]
    pub fn syncd(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Framing error" ]
    pub fn ferr(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Synchronization error" ]
    pub fn serr(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Time-out error" ]
    pub fn terr(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bits 16:30 - Duration of 5 symbols counted with SPDIF_CLK" ]
    pub fn width5(&self) -> u16 {
        self.bits.get_range(16u8..31u8) as u16
    }
}

impl Default for Sr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Sr { bits: 0u32 }
    }
}

impl Sr {
    # [ doc = "Bit 0 - Read data register not empty" ]
    pub fn set_rxne(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Control Buffer register is not empty" ]
    pub fn set_csrne(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - Parity error" ]
    pub fn set_perr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - Overrun error" ]
    pub fn set_ovr(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - Synchronization Block Detected" ]
    pub fn set_sbd(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - Synchronization Done" ]
    pub fn set_syncd(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Framing error" ]
    pub fn set_ferr(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Synchronization error" ]
    pub fn set_serr(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Time-out error" ]
    pub fn set_terr(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bits 16:30 - Duration of 5 symbols counted with SPDIF_CLK" ]
    pub fn set_width5(&mut self, value: u16) {
        self.bits.set_range(16u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ifcr {
    bits: u32,
}

impl Ifcr {
    # [ doc = "Bit 2 - Clears the Parity error flag" ]
    pub fn perrcf(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - Clears the Overrun error flag" ]
    pub fn ovrcf(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - Clears the Synchronization Block Detected flag" ]
    pub fn sbdcf(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - Clears the Synchronization Done flag" ]
    pub fn syncdcf(&self) -> bool {
        self.bits.get_bit(5u8)
    }
}

impl Default for Ifcr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ifcr { bits: 0u32 }
    }
}

impl Ifcr {
    # [ doc = "Bit 2 - Clears the Parity error flag" ]
    pub fn set_perrcf(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - Clears the Overrun error flag" ]
    pub fn set_ovrcf(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - Clears the Synchronization Block Detected flag" ]
    pub fn set_sbdcf(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - Clears the Synchronization Done flag" ]
    pub fn set_syncdcf(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Dr {
    bits: u32,
}

impl Dr {
    # [ doc = "Bits 0:23 - Parity Error bit" ]
    pub fn dr(&self) -> u32 {
        self.bits.get_range(0u8..24u8) as u32
    }
    # [ doc = "Bit 24 - Parity Error bit" ]
    pub fn pe(&self) -> bool {
        self.bits.get_bit(24u8)
    }
    # [ doc = "Bit 25 - Validity bit" ]
    pub fn v(&self) -> bool {
        self.bits.get_bit(25u8)
    }
    # [ doc = "Bit 26 - User bit" ]
    pub fn u(&self) -> bool {
        self.bits.get_bit(26u8)
    }
    # [ doc = "Bit 27 - Channel Status bit" ]
    pub fn c(&self) -> bool {
        self.bits.get_bit(27u8)
    }
    # [ doc = "Bits 28:29 - Preamble Type" ]
    pub fn pt(&self) -> u8 {
        self.bits.get_range(28u8..30u8) as u8
    }
}

impl Default for Dr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Dr { bits: 0u32 }
    }
}

impl Dr {
    # [ doc = "Bits 0:23 - Parity Error bit" ]
    pub fn set_dr(&mut self, value: u32) {
        self.bits.set_range(0u8..24u8, value as u32);
    }
    # [ doc = "Bit 24 - Parity Error bit" ]
    pub fn set_pe(&mut self, value: bool) {
        self.bits.set_bit(24u8, value);
    }
    # [ doc = "Bit 25 - Validity bit" ]
    pub fn set_v(&mut self, value: bool) {
        self.bits.set_bit(25u8, value);
    }
    # [ doc = "Bit 26 - User bit" ]
    pub fn set_u(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 27 - Channel Status bit" ]
    pub fn set_c(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bits 28:29 - Preamble Type" ]
    pub fn set_pt(&mut self, value: u8) {
        self.bits.set_range(28u8..30u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Csr {
    bits: u32,
}

impl Csr {
    # [ doc = "Bits 0:15 - User data information" ]
    pub fn usr(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:23 - Channel A status information" ]
    pub fn cs(&self) -> u8 {
        self.bits.get_range(16u8..24u8) as u8
    }
    # [ doc = "Bit 24 - Start Of Block" ]
    pub fn sob(&self) -> bool {
        self.bits.get_bit(24u8)
    }
}

impl Default for Csr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Csr { bits: 0u32 }
    }
}

impl Csr {
    # [ doc = "Bits 0:15 - User data information" ]
    pub fn set_usr(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:23 - Channel A status information" ]
    pub fn set_cs(&mut self, value: u8) {
        self.bits.set_range(16u8..24u8, value as u32);
    }
    # [ doc = "Bit 24 - Start Of Block" ]
    pub fn set_sob(&mut self, value: bool) {
        self.bits.set_bit(24u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Dir {
    bits: u32,
}

impl Dir {
    # [ doc = "Bits 0:12 - Threshold HIGH" ]
    pub fn thi(&self) -> u16 {
        self.bits.get_range(0u8..13u8) as u16
    }
    # [ doc = "Bits 16:28 - Threshold LOW" ]
    pub fn tlo(&self) -> u16 {
        self.bits.get_range(16u8..29u8) as u16
    }
}

impl Default for Dir {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Dir { bits: 0u32 }
    }
}

impl Dir {
    # [ doc = "Bits 0:12 - Threshold HIGH" ]
    pub fn set_thi(&mut self, value: u16) {
        self.bits.set_range(0u8..13u8, value as u32);
    }
    # [ doc = "Bits 16:28 - Threshold LOW" ]
    pub fn set_tlo(&mut self, value: u16) {
        self.bits.set_range(16u8..29u8, value as u32);
    }
}
