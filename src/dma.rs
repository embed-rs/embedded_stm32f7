// autogenerated

use volatile;
use bit_field::BitField;

# [ doc = "DMA controller" ]
# [ repr ( C ) ]
pub struct Dma {
    # [ doc = "0x00 - low interrupt status register" ]
    pub lisr: volatile::ReadOnly<Lisr>,
    # [ doc = "0x04 - high interrupt status register" ]
    pub hisr: volatile::ReadOnly<Hisr>,
    # [ doc = "0x08 - low interrupt flag clear register" ]
    pub lifcr: volatile::ReadWrite<Lifcr>,
    # [ doc = "0x0c - high interrupt flag clear register" ]
    pub hifcr: volatile::ReadWrite<Hifcr>,
    # [ doc = "0x10 - stream x configuration register" ]
    pub s0cr: volatile::ReadWrite<S0cr>,
    # [ doc = "0x14 - stream x number of data register" ]
    pub s0ndtr: volatile::ReadWrite<S0ndtr>,
    # [ doc = "0x18 - stream x peripheral address register" ]
    pub s0par: volatile::ReadWrite<S0par>,
    # [ doc = "0x1c - stream x memory 0 address register" ]
    pub s0m0ar: volatile::ReadWrite<S0m0ar>,
    # [ doc = "0x20 - stream x memory 1 address register" ]
    pub s0m1ar: volatile::ReadWrite<S0m0ar>,
    # [ doc = "0x24 - stream x FIFO control register" ]
    pub s0fcr: volatile::ReadWrite<S0fcr>,
    # [ doc = "0x28 - stream x configuration register" ]
    pub s1cr: volatile::ReadWrite<S0cr>,
    # [ doc = "0x2c - stream x number of data register" ]
    pub s1ndtr: volatile::ReadWrite<S0ndtr>,
    # [ doc = "0x30 - stream x peripheral address register" ]
    pub s1par: volatile::ReadWrite<S0par>,
    # [ doc = "0x34 - stream x memory 0 address register" ]
    pub s1m0ar: volatile::ReadWrite<S0m0ar>,
    # [ doc = "0x38 - stream x memory 1 address register" ]
    pub s1m1ar: volatile::ReadWrite<S0m0ar>,
    # [ doc = "0x3c - stream x FIFO control register" ]
    pub s1fcr: volatile::ReadWrite<S0fcr>,
    # [ doc = "0x40 - stream x configuration register" ]
    pub s2cr: volatile::ReadWrite<S0cr>,
    # [ doc = "0x44 - stream x number of data register" ]
    pub s2ndtr: volatile::ReadWrite<S0ndtr>,
    # [ doc = "0x48 - stream x peripheral address register" ]
    pub s2par: volatile::ReadWrite<S0par>,
    # [ doc = "0x4c - stream x memory 0 address register" ]
    pub s2m0ar: volatile::ReadWrite<S0m0ar>,
    # [ doc = "0x50 - stream x memory 1 address register" ]
    pub s2m1ar: volatile::ReadWrite<S0m0ar>,
    # [ doc = "0x54 - stream x FIFO control register" ]
    pub s2fcr: volatile::ReadWrite<S0fcr>,
    # [ doc = "0x58 - stream x configuration register" ]
    pub s3cr: volatile::ReadWrite<S0cr>,
    # [ doc = "0x5c - stream x number of data register" ]
    pub s3ndtr: volatile::ReadWrite<S0ndtr>,
    # [ doc = "0x60 - stream x peripheral address register" ]
    pub s3par: volatile::ReadWrite<S0par>,
    # [ doc = "0x64 - stream x memory 0 address register" ]
    pub s3m0ar: volatile::ReadWrite<S0m0ar>,
    # [ doc = "0x68 - stream x memory 1 address register" ]
    pub s3m1ar: volatile::ReadWrite<S0m0ar>,
    # [ doc = "0x6c - stream x FIFO control register" ]
    pub s3fcr: volatile::ReadWrite<S0fcr>,
    # [ doc = "0x70 - stream x configuration register" ]
    pub s4cr: volatile::ReadWrite<S0cr>,
    # [ doc = "0x74 - stream x number of data register" ]
    pub s4ndtr: volatile::ReadWrite<S0ndtr>,
    # [ doc = "0x78 - stream x peripheral address register" ]
    pub s4par: volatile::ReadWrite<S0par>,
    # [ doc = "0x7c - stream x memory 0 address register" ]
    pub s4m0ar: volatile::ReadWrite<S0m0ar>,
    # [ doc = "0x80 - stream x memory 1 address register" ]
    pub s4m1ar: volatile::ReadWrite<S0m0ar>,
    # [ doc = "0x84 - stream x FIFO control register" ]
    pub s4fcr: volatile::ReadWrite<S0fcr>,
    # [ doc = "0x88 - stream x configuration register" ]
    pub s5cr: volatile::ReadWrite<S0cr>,
    # [ doc = "0x8c - stream x number of data register" ]
    pub s5ndtr: volatile::ReadWrite<S0ndtr>,
    # [ doc = "0x90 - stream x peripheral address register" ]
    pub s5par: volatile::ReadWrite<S0par>,
    # [ doc = "0x94 - stream x memory 0 address register" ]
    pub s5m0ar: volatile::ReadWrite<S0m0ar>,
    # [ doc = "0x98 - stream x memory 1 address register" ]
    pub s5m1ar: volatile::ReadWrite<S0m0ar>,
    # [ doc = "0x9c - stream x FIFO control register" ]
    pub s5fcr: volatile::ReadWrite<S0fcr>,
    # [ doc = "0xa0 - stream x configuration register" ]
    pub s6cr: volatile::ReadWrite<S0cr>,
    # [ doc = "0xa4 - stream x number of data register" ]
    pub s6ndtr: volatile::ReadWrite<S0ndtr>,
    # [ doc = "0xa8 - stream x peripheral address register" ]
    pub s6par: volatile::ReadWrite<S0par>,
    # [ doc = "0xac - stream x memory 0 address register" ]
    pub s6m0ar: volatile::ReadWrite<S0m0ar>,
    # [ doc = "0xb0 - stream x memory 1 address register" ]
    pub s6m1ar: volatile::ReadWrite<S0m0ar>,
    # [ doc = "0xb4 - stream x FIFO control register" ]
    pub s6fcr: volatile::ReadWrite<S0fcr>,
    # [ doc = "0xb8 - stream x configuration register" ]
    pub s7cr: volatile::ReadWrite<S0cr>,
    # [ doc = "0xbc - stream x number of data register" ]
    pub s7ndtr: volatile::ReadWrite<S0ndtr>,
    # [ doc = "0xc0 - stream x peripheral address register" ]
    pub s7par: volatile::ReadWrite<S0par>,
    # [ doc = "0xc4 - stream x memory 0 address register" ]
    pub s7m0ar: volatile::ReadWrite<S0m0ar>,
    # [ doc = "0xc8 - stream x memory 1 address register" ]
    pub s7m1ar: volatile::ReadWrite<S0m0ar>,
    # [ doc = "0xcc - stream x FIFO control register" ]
    pub s7fcr: volatile::ReadWrite<S0fcr>,
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Lisr {
    bits: u32,
}

impl Lisr {
    # [ doc = "Bit 27 - Stream x transfer complete interrupt flag (x = 3..0)" ]
    pub fn tcif3(&self) -> bool {
        self.bits.get_bit(27u8)
    }
    # [ doc = "Bit 26 - Stream x half transfer interrupt flag (x=3..0)" ]
    pub fn htif3(&self) -> bool {
        self.bits.get_bit(26u8)
    }
    # [ doc = "Bit 25 - Stream x transfer error interrupt flag (x=3..0)" ]
    pub fn teif3(&self) -> bool {
        self.bits.get_bit(25u8)
    }
    # [ doc = "Bit 24 - Stream x direct mode error interrupt flag (x=3..0)" ]
    pub fn dmeif3(&self) -> bool {
        self.bits.get_bit(24u8)
    }
    # [ doc = "Bit 22 - Stream x FIFO error interrupt flag (x=3..0)" ]
    pub fn feif3(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bit 21 - Stream x transfer complete interrupt flag (x = 3..0)" ]
    pub fn tcif2(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 20 - Stream x half transfer interrupt flag (x=3..0)" ]
    pub fn htif2(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 19 - Stream x transfer error interrupt flag (x=3..0)" ]
    pub fn teif2(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 18 - Stream x direct mode error interrupt flag (x=3..0)" ]
    pub fn dmeif2(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 16 - Stream x FIFO error interrupt flag (x=3..0)" ]
    pub fn feif2(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 11 - Stream x transfer complete interrupt flag (x = 3..0)" ]
    pub fn tcif1(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 10 - Stream x half transfer interrupt flag (x=3..0)" ]
    pub fn htif1(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - Stream x transfer error interrupt flag (x=3..0)" ]
    pub fn teif1(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - Stream x direct mode error interrupt flag (x=3..0)" ]
    pub fn dmeif1(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 6 - Stream x FIFO error interrupt flag (x=3..0)" ]
    pub fn feif1(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 5 - Stream x transfer complete interrupt flag (x = 3..0)" ]
    pub fn tcif0(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Stream x half transfer interrupt flag (x=3..0)" ]
    pub fn htif0(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Stream x transfer error interrupt flag (x=3..0)" ]
    pub fn teif0(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Stream x direct mode error interrupt flag (x=3..0)" ]
    pub fn dmeif0(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 0 - Stream x FIFO error interrupt flag (x=3..0)" ]
    pub fn feif0(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Lisr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Lisr { bits: 0u32 }
    }
}

impl Lisr {
    # [ doc = "Bit 27 - Stream x transfer complete interrupt flag (x = 3..0)" ]
    pub fn set_tcif3(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 26 - Stream x half transfer interrupt flag (x=3..0)" ]
    pub fn set_htif3(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 25 - Stream x transfer error interrupt flag (x=3..0)" ]
    pub fn set_teif3(&mut self, value: bool) {
        self.bits.set_bit(25u8, value);
    }
    # [ doc = "Bit 24 - Stream x direct mode error interrupt flag (x=3..0)" ]
    pub fn set_dmeif3(&mut self, value: bool) {
        self.bits.set_bit(24u8, value);
    }
    # [ doc = "Bit 22 - Stream x FIFO error interrupt flag (x=3..0)" ]
    pub fn set_feif3(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 21 - Stream x transfer complete interrupt flag (x = 3..0)" ]
    pub fn set_tcif2(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 20 - Stream x half transfer interrupt flag (x=3..0)" ]
    pub fn set_htif2(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 19 - Stream x transfer error interrupt flag (x=3..0)" ]
    pub fn set_teif2(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 18 - Stream x direct mode error interrupt flag (x=3..0)" ]
    pub fn set_dmeif2(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 16 - Stream x FIFO error interrupt flag (x=3..0)" ]
    pub fn set_feif2(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 11 - Stream x transfer complete interrupt flag (x = 3..0)" ]
    pub fn set_tcif1(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 10 - Stream x half transfer interrupt flag (x=3..0)" ]
    pub fn set_htif1(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - Stream x transfer error interrupt flag (x=3..0)" ]
    pub fn set_teif1(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - Stream x direct mode error interrupt flag (x=3..0)" ]
    pub fn set_dmeif1(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 6 - Stream x FIFO error interrupt flag (x=3..0)" ]
    pub fn set_feif1(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 5 - Stream x transfer complete interrupt flag (x = 3..0)" ]
    pub fn set_tcif0(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Stream x half transfer interrupt flag (x=3..0)" ]
    pub fn set_htif0(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Stream x transfer error interrupt flag (x=3..0)" ]
    pub fn set_teif0(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Stream x direct mode error interrupt flag (x=3..0)" ]
    pub fn set_dmeif0(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 0 - Stream x FIFO error interrupt flag (x=3..0)" ]
    pub fn set_feif0(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Hisr {
    bits: u32,
}

impl Hisr {
    # [ doc = "Bit 27 - Stream x transfer complete interrupt flag (x=7..4)" ]
    pub fn tcif7(&self) -> bool {
        self.bits.get_bit(27u8)
    }
    # [ doc = "Bit 26 - Stream x half transfer interrupt flag (x=7..4)" ]
    pub fn htif7(&self) -> bool {
        self.bits.get_bit(26u8)
    }
    # [ doc = "Bit 25 - Stream x transfer error interrupt flag (x=7..4)" ]
    pub fn teif7(&self) -> bool {
        self.bits.get_bit(25u8)
    }
    # [ doc = "Bit 24 - Stream x direct mode error interrupt flag (x=7..4)" ]
    pub fn dmeif7(&self) -> bool {
        self.bits.get_bit(24u8)
    }
    # [ doc = "Bit 22 - Stream x FIFO error interrupt flag (x=7..4)" ]
    pub fn feif7(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bit 21 - Stream x transfer complete interrupt flag (x=7..4)" ]
    pub fn tcif6(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 20 - Stream x half transfer interrupt flag (x=7..4)" ]
    pub fn htif6(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 19 - Stream x transfer error interrupt flag (x=7..4)" ]
    pub fn teif6(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 18 - Stream x direct mode error interrupt flag (x=7..4)" ]
    pub fn dmeif6(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 16 - Stream x FIFO error interrupt flag (x=7..4)" ]
    pub fn feif6(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 11 - Stream x transfer complete interrupt flag (x=7..4)" ]
    pub fn tcif5(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 10 - Stream x half transfer interrupt flag (x=7..4)" ]
    pub fn htif5(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - Stream x transfer error interrupt flag (x=7..4)" ]
    pub fn teif5(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - Stream x direct mode error interrupt flag (x=7..4)" ]
    pub fn dmeif5(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 6 - Stream x FIFO error interrupt flag (x=7..4)" ]
    pub fn feif5(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 5 - Stream x transfer complete interrupt flag (x=7..4)" ]
    pub fn tcif4(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Stream x half transfer interrupt flag (x=7..4)" ]
    pub fn htif4(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Stream x transfer error interrupt flag (x=7..4)" ]
    pub fn teif4(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Stream x direct mode error interrupt flag (x=7..4)" ]
    pub fn dmeif4(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 0 - Stream x FIFO error interrupt flag (x=7..4)" ]
    pub fn feif4(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Hisr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Hisr { bits: 0u32 }
    }
}

impl Hisr {
    # [ doc = "Bit 27 - Stream x transfer complete interrupt flag (x=7..4)" ]
    pub fn set_tcif7(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 26 - Stream x half transfer interrupt flag (x=7..4)" ]
    pub fn set_htif7(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 25 - Stream x transfer error interrupt flag (x=7..4)" ]
    pub fn set_teif7(&mut self, value: bool) {
        self.bits.set_bit(25u8, value);
    }
    # [ doc = "Bit 24 - Stream x direct mode error interrupt flag (x=7..4)" ]
    pub fn set_dmeif7(&mut self, value: bool) {
        self.bits.set_bit(24u8, value);
    }
    # [ doc = "Bit 22 - Stream x FIFO error interrupt flag (x=7..4)" ]
    pub fn set_feif7(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 21 - Stream x transfer complete interrupt flag (x=7..4)" ]
    pub fn set_tcif6(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 20 - Stream x half transfer interrupt flag (x=7..4)" ]
    pub fn set_htif6(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 19 - Stream x transfer error interrupt flag (x=7..4)" ]
    pub fn set_teif6(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 18 - Stream x direct mode error interrupt flag (x=7..4)" ]
    pub fn set_dmeif6(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 16 - Stream x FIFO error interrupt flag (x=7..4)" ]
    pub fn set_feif6(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 11 - Stream x transfer complete interrupt flag (x=7..4)" ]
    pub fn set_tcif5(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 10 - Stream x half transfer interrupt flag (x=7..4)" ]
    pub fn set_htif5(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - Stream x transfer error interrupt flag (x=7..4)" ]
    pub fn set_teif5(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - Stream x direct mode error interrupt flag (x=7..4)" ]
    pub fn set_dmeif5(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 6 - Stream x FIFO error interrupt flag (x=7..4)" ]
    pub fn set_feif5(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 5 - Stream x transfer complete interrupt flag (x=7..4)" ]
    pub fn set_tcif4(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Stream x half transfer interrupt flag (x=7..4)" ]
    pub fn set_htif4(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Stream x transfer error interrupt flag (x=7..4)" ]
    pub fn set_teif4(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Stream x direct mode error interrupt flag (x=7..4)" ]
    pub fn set_dmeif4(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 0 - Stream x FIFO error interrupt flag (x=7..4)" ]
    pub fn set_feif4(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Lifcr {
    bits: u32,
}

impl Lifcr {
    # [ doc = "Bit 27 - Stream x clear transfer complete interrupt flag (x = 3..0)" ]
    pub fn ctcif3(&self) -> bool {
        self.bits.get_bit(27u8)
    }
    # [ doc = "Bit 26 - Stream x clear half transfer interrupt flag (x = 3..0)" ]
    pub fn chtif3(&self) -> bool {
        self.bits.get_bit(26u8)
    }
    # [ doc = "Bit 25 - Stream x clear transfer error interrupt flag (x = 3..0)" ]
    pub fn cteif3(&self) -> bool {
        self.bits.get_bit(25u8)
    }
    # [ doc = "Bit 24 - Stream x clear direct mode error interrupt flag (x = 3..0)" ]
    pub fn cdmeif3(&self) -> bool {
        self.bits.get_bit(24u8)
    }
    # [ doc = "Bit 22 - Stream x clear FIFO error interrupt flag (x = 3..0)" ]
    pub fn cfeif3(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bit 21 - Stream x clear transfer complete interrupt flag (x = 3..0)" ]
    pub fn ctcif2(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 20 - Stream x clear half transfer interrupt flag (x = 3..0)" ]
    pub fn chtif2(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 19 - Stream x clear transfer error interrupt flag (x = 3..0)" ]
    pub fn cteif2(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 18 - Stream x clear direct mode error interrupt flag (x = 3..0)" ]
    pub fn cdmeif2(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 16 - Stream x clear FIFO error interrupt flag (x = 3..0)" ]
    pub fn cfeif2(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 11 - Stream x clear transfer complete interrupt flag (x = 3..0)" ]
    pub fn ctcif1(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 10 - Stream x clear half transfer interrupt flag (x = 3..0)" ]
    pub fn chtif1(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - Stream x clear transfer error interrupt flag (x = 3..0)" ]
    pub fn cteif1(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - Stream x clear direct mode error interrupt flag (x = 3..0)" ]
    pub fn cdmeif1(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 6 - Stream x clear FIFO error interrupt flag (x = 3..0)" ]
    pub fn cfeif1(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 5 - Stream x clear transfer complete interrupt flag (x = 3..0)" ]
    pub fn ctcif0(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Stream x clear half transfer interrupt flag (x = 3..0)" ]
    pub fn chtif0(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Stream x clear transfer error interrupt flag (x = 3..0)" ]
    pub fn cteif0(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Stream x clear direct mode error interrupt flag (x = 3..0)" ]
    pub fn cdmeif0(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 0 - Stream x clear FIFO error interrupt flag (x = 3..0)" ]
    pub fn cfeif0(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Lifcr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Lifcr { bits: 0u32 }
    }
}

impl Lifcr {
    # [ doc = "Bit 27 - Stream x clear transfer complete interrupt flag (x = 3..0)" ]
    pub fn set_ctcif3(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 26 - Stream x clear half transfer interrupt flag (x = 3..0)" ]
    pub fn set_chtif3(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 25 - Stream x clear transfer error interrupt flag (x = 3..0)" ]
    pub fn set_cteif3(&mut self, value: bool) {
        self.bits.set_bit(25u8, value);
    }
    # [ doc = "Bit 24 - Stream x clear direct mode error interrupt flag (x = 3..0)" ]
    pub fn set_cdmeif3(&mut self, value: bool) {
        self.bits.set_bit(24u8, value);
    }
    # [ doc = "Bit 22 - Stream x clear FIFO error interrupt flag (x = 3..0)" ]
    pub fn set_cfeif3(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 21 - Stream x clear transfer complete interrupt flag (x = 3..0)" ]
    pub fn set_ctcif2(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 20 - Stream x clear half transfer interrupt flag (x = 3..0)" ]
    pub fn set_chtif2(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 19 - Stream x clear transfer error interrupt flag (x = 3..0)" ]
    pub fn set_cteif2(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 18 - Stream x clear direct mode error interrupt flag (x = 3..0)" ]
    pub fn set_cdmeif2(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 16 - Stream x clear FIFO error interrupt flag (x = 3..0)" ]
    pub fn set_cfeif2(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 11 - Stream x clear transfer complete interrupt flag (x = 3..0)" ]
    pub fn set_ctcif1(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 10 - Stream x clear half transfer interrupt flag (x = 3..0)" ]
    pub fn set_chtif1(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - Stream x clear transfer error interrupt flag (x = 3..0)" ]
    pub fn set_cteif1(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - Stream x clear direct mode error interrupt flag (x = 3..0)" ]
    pub fn set_cdmeif1(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 6 - Stream x clear FIFO error interrupt flag (x = 3..0)" ]
    pub fn set_cfeif1(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 5 - Stream x clear transfer complete interrupt flag (x = 3..0)" ]
    pub fn set_ctcif0(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Stream x clear half transfer interrupt flag (x = 3..0)" ]
    pub fn set_chtif0(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Stream x clear transfer error interrupt flag (x = 3..0)" ]
    pub fn set_cteif0(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Stream x clear direct mode error interrupt flag (x = 3..0)" ]
    pub fn set_cdmeif0(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 0 - Stream x clear FIFO error interrupt flag (x = 3..0)" ]
    pub fn set_cfeif0(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Hifcr {
    bits: u32,
}

impl Hifcr {
    # [ doc = "Bit 27 - Stream x clear transfer complete interrupt flag (x = 7..4)" ]
    pub fn ctcif7(&self) -> bool {
        self.bits.get_bit(27u8)
    }
    # [ doc = "Bit 26 - Stream x clear half transfer interrupt flag (x = 7..4)" ]
    pub fn chtif7(&self) -> bool {
        self.bits.get_bit(26u8)
    }
    # [ doc = "Bit 25 - Stream x clear transfer error interrupt flag (x = 7..4)" ]
    pub fn cteif7(&self) -> bool {
        self.bits.get_bit(25u8)
    }
    # [ doc = "Bit 24 - Stream x clear direct mode error interrupt flag (x = 7..4)" ]
    pub fn cdmeif7(&self) -> bool {
        self.bits.get_bit(24u8)
    }
    # [ doc = "Bit 22 - Stream x clear FIFO error interrupt flag (x = 7..4)" ]
    pub fn cfeif7(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bit 21 - Stream x clear transfer complete interrupt flag (x = 7..4)" ]
    pub fn ctcif6(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 20 - Stream x clear half transfer interrupt flag (x = 7..4)" ]
    pub fn chtif6(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 19 - Stream x clear transfer error interrupt flag (x = 7..4)" ]
    pub fn cteif6(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 18 - Stream x clear direct mode error interrupt flag (x = 7..4)" ]
    pub fn cdmeif6(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 16 - Stream x clear FIFO error interrupt flag (x = 7..4)" ]
    pub fn cfeif6(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 11 - Stream x clear transfer complete interrupt flag (x = 7..4)" ]
    pub fn ctcif5(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 10 - Stream x clear half transfer interrupt flag (x = 7..4)" ]
    pub fn chtif5(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - Stream x clear transfer error interrupt flag (x = 7..4)" ]
    pub fn cteif5(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - Stream x clear direct mode error interrupt flag (x = 7..4)" ]
    pub fn cdmeif5(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 6 - Stream x clear FIFO error interrupt flag (x = 7..4)" ]
    pub fn cfeif5(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 5 - Stream x clear transfer complete interrupt flag (x = 7..4)" ]
    pub fn ctcif4(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Stream x clear half transfer interrupt flag (x = 7..4)" ]
    pub fn chtif4(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Stream x clear transfer error interrupt flag (x = 7..4)" ]
    pub fn cteif4(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Stream x clear direct mode error interrupt flag (x = 7..4)" ]
    pub fn cdmeif4(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 0 - Stream x clear FIFO error interrupt flag (x = 7..4)" ]
    pub fn cfeif4(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Hifcr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Hifcr { bits: 0u32 }
    }
}

impl Hifcr {
    # [ doc = "Bit 27 - Stream x clear transfer complete interrupt flag (x = 7..4)" ]
    pub fn set_ctcif7(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
    # [ doc = "Bit 26 - Stream x clear half transfer interrupt flag (x = 7..4)" ]
    pub fn set_chtif7(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 25 - Stream x clear transfer error interrupt flag (x = 7..4)" ]
    pub fn set_cteif7(&mut self, value: bool) {
        self.bits.set_bit(25u8, value);
    }
    # [ doc = "Bit 24 - Stream x clear direct mode error interrupt flag (x = 7..4)" ]
    pub fn set_cdmeif7(&mut self, value: bool) {
        self.bits.set_bit(24u8, value);
    }
    # [ doc = "Bit 22 - Stream x clear FIFO error interrupt flag (x = 7..4)" ]
    pub fn set_cfeif7(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 21 - Stream x clear transfer complete interrupt flag (x = 7..4)" ]
    pub fn set_ctcif6(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 20 - Stream x clear half transfer interrupt flag (x = 7..4)" ]
    pub fn set_chtif6(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 19 - Stream x clear transfer error interrupt flag (x = 7..4)" ]
    pub fn set_cteif6(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 18 - Stream x clear direct mode error interrupt flag (x = 7..4)" ]
    pub fn set_cdmeif6(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 16 - Stream x clear FIFO error interrupt flag (x = 7..4)" ]
    pub fn set_cfeif6(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 11 - Stream x clear transfer complete interrupt flag (x = 7..4)" ]
    pub fn set_ctcif5(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 10 - Stream x clear half transfer interrupt flag (x = 7..4)" ]
    pub fn set_chtif5(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - Stream x clear transfer error interrupt flag (x = 7..4)" ]
    pub fn set_cteif5(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - Stream x clear direct mode error interrupt flag (x = 7..4)" ]
    pub fn set_cdmeif5(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 6 - Stream x clear FIFO error interrupt flag (x = 7..4)" ]
    pub fn set_cfeif5(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 5 - Stream x clear transfer complete interrupt flag (x = 7..4)" ]
    pub fn set_ctcif4(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Stream x clear half transfer interrupt flag (x = 7..4)" ]
    pub fn set_chtif4(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Stream x clear transfer error interrupt flag (x = 7..4)" ]
    pub fn set_cteif4(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Stream x clear direct mode error interrupt flag (x = 7..4)" ]
    pub fn set_cdmeif4(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 0 - Stream x clear FIFO error interrupt flag (x = 7..4)" ]
    pub fn set_cfeif4(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S0cr {
    bits: u32,
}

impl S0cr {
    # [ doc = "Bits 25:27 - Channel selection" ]
    pub fn chsel(&self) -> u8 {
        self.bits.get_range(25u8..28u8) as u8
    }
    # [ doc = "Bits 23:24 - Memory burst transfer configuration" ]
    pub fn mburst(&self) -> u8 {
        self.bits.get_range(23u8..25u8) as u8
    }
    # [ doc = "Bits 21:22 - Peripheral burst transfer configuration" ]
    pub fn pburst(&self) -> u8 {
        self.bits.get_range(21u8..23u8) as u8
    }
    # [ doc = "Bit 19 - Current target (only in double buffer mode)" ]
    pub fn ct(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 18 - Double buffer mode" ]
    pub fn dbm(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bits 16:17 - Priority level" ]
    pub fn pl(&self) -> u8 {
        self.bits.get_range(16u8..18u8) as u8
    }
    # [ doc = "Bit 15 - Peripheral increment offset size" ]
    pub fn pincos(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bits 13:14 - Memory data size" ]
    pub fn msize(&self) -> u8 {
        self.bits.get_range(13u8..15u8) as u8
    }
    # [ doc = "Bits 11:12 - Peripheral data size" ]
    pub fn psize(&self) -> u8 {
        self.bits.get_range(11u8..13u8) as u8
    }
    # [ doc = "Bit 10 - Memory increment mode" ]
    pub fn minc(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - Peripheral increment mode" ]
    pub fn pinc(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - Circular mode" ]
    pub fn circ(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bits 6:7 - Data transfer direction" ]
    pub fn dir(&self) -> u8 {
        self.bits.get_range(6u8..8u8) as u8
    }
    # [ doc = "Bit 5 - Peripheral flow controller" ]
    pub fn pfctrl(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Transfer complete interrupt enable" ]
    pub fn tcie(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Half transfer interrupt enable" ]
    pub fn htie(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Transfer error interrupt enable" ]
    pub fn teie(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Direct mode error interrupt enable" ]
    pub fn dmeie(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Stream enable / flag stream ready when read low" ]
    pub fn en(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for S0cr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S0cr { bits: 0u32 }
    }
}

impl S0cr {
    # [ doc = "Bits 25:27 - Channel selection" ]
    pub fn set_chsel(&mut self, value: u8) {
        self.bits.set_range(25u8..28u8, value as u32);
    }
    # [ doc = "Bits 23:24 - Memory burst transfer configuration" ]
    pub fn set_mburst(&mut self, value: u8) {
        self.bits.set_range(23u8..25u8, value as u32);
    }
    # [ doc = "Bits 21:22 - Peripheral burst transfer configuration" ]
    pub fn set_pburst(&mut self, value: u8) {
        self.bits.set_range(21u8..23u8, value as u32);
    }
    # [ doc = "Bit 19 - Current target (only in double buffer mode)" ]
    pub fn set_ct(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 18 - Double buffer mode" ]
    pub fn set_dbm(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bits 16:17 - Priority level" ]
    pub fn set_pl(&mut self, value: u8) {
        self.bits.set_range(16u8..18u8, value as u32);
    }
    # [ doc = "Bit 15 - Peripheral increment offset size" ]
    pub fn set_pincos(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 13:14 - Memory data size" ]
    pub fn set_msize(&mut self, value: u8) {
        self.bits.set_range(13u8..15u8, value as u32);
    }
    # [ doc = "Bits 11:12 - Peripheral data size" ]
    pub fn set_psize(&mut self, value: u8) {
        self.bits.set_range(11u8..13u8, value as u32);
    }
    # [ doc = "Bit 10 - Memory increment mode" ]
    pub fn set_minc(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - Peripheral increment mode" ]
    pub fn set_pinc(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - Circular mode" ]
    pub fn set_circ(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bits 6:7 - Data transfer direction" ]
    pub fn set_dir(&mut self, value: u8) {
        self.bits.set_range(6u8..8u8, value as u32);
    }
    # [ doc = "Bit 5 - Peripheral flow controller" ]
    pub fn set_pfctrl(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Transfer complete interrupt enable" ]
    pub fn set_tcie(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Half transfer interrupt enable" ]
    pub fn set_htie(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Transfer error interrupt enable" ]
    pub fn set_teie(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Direct mode error interrupt enable" ]
    pub fn set_dmeie(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Stream enable / flag stream ready when read low" ]
    pub fn set_en(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S0ndtr {
    bits: u32,
}

impl S0ndtr {
    # [ doc = "Bits 0:15 - Number of data items to transfer" ]
    pub fn ndt(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for S0ndtr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S0ndtr { bits: 0u32 }
    }
}

impl S0ndtr {
    # [ doc = "Bits 0:15 - Number of data items to transfer" ]
    pub fn set_ndt(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S0par {
    bits: u32,
}

impl S0par {
    # [ doc = "Bits 0:31 - Peripheral address" ]
    pub fn pa(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S0par {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S0par { bits: 0u32 }
    }
}

impl S0par {
    # [ doc = "Bits 0:31 - Peripheral address" ]
    pub fn set_pa(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S0m0ar {
    bits: u32,
}

impl S0m0ar {
    # [ doc = "Bits 0:31 - Memory 0 address" ]
    pub fn m0a(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S0m0ar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S0m0ar { bits: 0u32 }
    }
}

impl S0m0ar {
    # [ doc = "Bits 0:31 - Memory 0 address" ]
    pub fn set_m0a(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S0m1ar {
    bits: u32,
}

impl S0m1ar {
    # [ doc = "Bits 0:31 - Memory 1 address (used in case of Double buffer mode)" ]
    pub fn m1a(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S0m1ar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S0m1ar { bits: 0u32 }
    }
}

impl S0m1ar {
    # [ doc = "Bits 0:31 - Memory 1 address (used in case of Double buffer mode)" ]
    pub fn set_m1a(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S0fcr {
    bits: u32,
}

impl S0fcr {
    # [ doc = "Bit 7 - FIFO error interrupt enable" ]
    pub fn feie(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bits 3:5 - FIFO status" ]
    pub fn fs(&self) -> u8 {
        self.bits.get_range(3u8..6u8) as u8
    }
    # [ doc = "Bit 2 - Direct mode disable" ]
    pub fn dmdis(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bits 0:1 - FIFO threshold selection" ]
    pub fn fth(&self) -> u8 {
        self.bits.get_range(0u8..2u8) as u8
    }
}

impl Default for S0fcr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S0fcr { bits: 33u32 }
    }
}

impl S0fcr {
    # [ doc = "Bit 7 - FIFO error interrupt enable" ]
    pub fn set_feie(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 2 - Direct mode disable" ]
    pub fn set_dmdis(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bits 0:1 - FIFO threshold selection" ]
    pub fn set_fth(&mut self, value: u8) {
        self.bits.set_range(0u8..2u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S1cr {
    bits: u32,
}

impl S1cr {
    # [ doc = "Bits 25:27 - Channel selection" ]
    pub fn chsel(&self) -> u8 {
        self.bits.get_range(25u8..28u8) as u8
    }
    # [ doc = "Bits 23:24 - Memory burst transfer configuration" ]
    pub fn mburst(&self) -> u8 {
        self.bits.get_range(23u8..25u8) as u8
    }
    # [ doc = "Bits 21:22 - Peripheral burst transfer configuration" ]
    pub fn pburst(&self) -> u8 {
        self.bits.get_range(21u8..23u8) as u8
    }
    # [ doc = "Bit 19 - Current target (only in double buffer mode)" ]
    pub fn ct(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 18 - Double buffer mode" ]
    pub fn dbm(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bits 16:17 - Priority level" ]
    pub fn pl(&self) -> u8 {
        self.bits.get_range(16u8..18u8) as u8
    }
    # [ doc = "Bit 15 - Peripheral increment offset size" ]
    pub fn pincos(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bits 13:14 - Memory data size" ]
    pub fn msize(&self) -> u8 {
        self.bits.get_range(13u8..15u8) as u8
    }
    # [ doc = "Bits 11:12 - Peripheral data size" ]
    pub fn psize(&self) -> u8 {
        self.bits.get_range(11u8..13u8) as u8
    }
    # [ doc = "Bit 10 - Memory increment mode" ]
    pub fn minc(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - Peripheral increment mode" ]
    pub fn pinc(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - Circular mode" ]
    pub fn circ(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bits 6:7 - Data transfer direction" ]
    pub fn dir(&self) -> u8 {
        self.bits.get_range(6u8..8u8) as u8
    }
    # [ doc = "Bit 5 - Peripheral flow controller" ]
    pub fn pfctrl(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Transfer complete interrupt enable" ]
    pub fn tcie(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Half transfer interrupt enable" ]
    pub fn htie(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Transfer error interrupt enable" ]
    pub fn teie(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Direct mode error interrupt enable" ]
    pub fn dmeie(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Stream enable / flag stream ready when read low" ]
    pub fn en(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for S1cr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S1cr { bits: 0u32 }
    }
}

impl S1cr {
    # [ doc = "Bits 25:27 - Channel selection" ]
    pub fn set_chsel(&mut self, value: u8) {
        self.bits.set_range(25u8..28u8, value as u32);
    }
    # [ doc = "Bits 23:24 - Memory burst transfer configuration" ]
    pub fn set_mburst(&mut self, value: u8) {
        self.bits.set_range(23u8..25u8, value as u32);
    }
    # [ doc = "Bits 21:22 - Peripheral burst transfer configuration" ]
    pub fn set_pburst(&mut self, value: u8) {
        self.bits.set_range(21u8..23u8, value as u32);
    }
    # [ doc = "Bit 19 - Current target (only in double buffer mode)" ]
    pub fn set_ct(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 18 - Double buffer mode" ]
    pub fn set_dbm(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bits 16:17 - Priority level" ]
    pub fn set_pl(&mut self, value: u8) {
        self.bits.set_range(16u8..18u8, value as u32);
    }
    # [ doc = "Bit 15 - Peripheral increment offset size" ]
    pub fn set_pincos(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 13:14 - Memory data size" ]
    pub fn set_msize(&mut self, value: u8) {
        self.bits.set_range(13u8..15u8, value as u32);
    }
    # [ doc = "Bits 11:12 - Peripheral data size" ]
    pub fn set_psize(&mut self, value: u8) {
        self.bits.set_range(11u8..13u8, value as u32);
    }
    # [ doc = "Bit 10 - Memory increment mode" ]
    pub fn set_minc(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - Peripheral increment mode" ]
    pub fn set_pinc(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - Circular mode" ]
    pub fn set_circ(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bits 6:7 - Data transfer direction" ]
    pub fn set_dir(&mut self, value: u8) {
        self.bits.set_range(6u8..8u8, value as u32);
    }
    # [ doc = "Bit 5 - Peripheral flow controller" ]
    pub fn set_pfctrl(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Transfer complete interrupt enable" ]
    pub fn set_tcie(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Half transfer interrupt enable" ]
    pub fn set_htie(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Transfer error interrupt enable" ]
    pub fn set_teie(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Direct mode error interrupt enable" ]
    pub fn set_dmeie(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Stream enable / flag stream ready when read low" ]
    pub fn set_en(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S1ndtr {
    bits: u32,
}

impl S1ndtr {
    # [ doc = "Bits 0:15 - Number of data items to transfer" ]
    pub fn ndt(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for S1ndtr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S1ndtr { bits: 0u32 }
    }
}

impl S1ndtr {
    # [ doc = "Bits 0:15 - Number of data items to transfer" ]
    pub fn set_ndt(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S1par {
    bits: u32,
}

impl S1par {
    # [ doc = "Bits 0:31 - Peripheral address" ]
    pub fn pa(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S1par {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S1par { bits: 0u32 }
    }
}

impl S1par {
    # [ doc = "Bits 0:31 - Peripheral address" ]
    pub fn set_pa(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S1m0ar {
    bits: u32,
}

impl S1m0ar {
    # [ doc = "Bits 0:31 - Memory 0 address" ]
    pub fn m0a(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S1m0ar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S1m0ar { bits: 0u32 }
    }
}

impl S1m0ar {
    # [ doc = "Bits 0:31 - Memory 0 address" ]
    pub fn set_m0a(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S1m1ar {
    bits: u32,
}

impl S1m1ar {
    # [ doc = "Bits 0:31 - Memory 1 address (used in case of Double buffer mode)" ]
    pub fn m1a(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S1m1ar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S1m1ar { bits: 0u32 }
    }
}

impl S1m1ar {
    # [ doc = "Bits 0:31 - Memory 1 address (used in case of Double buffer mode)" ]
    pub fn set_m1a(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S1fcr {
    bits: u32,
}

impl S1fcr {
    # [ doc = "Bit 7 - FIFO error interrupt enable" ]
    pub fn feie(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bits 3:5 - FIFO status" ]
    pub fn fs(&self) -> u8 {
        self.bits.get_range(3u8..6u8) as u8
    }
    # [ doc = "Bit 2 - Direct mode disable" ]
    pub fn dmdis(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bits 0:1 - FIFO threshold selection" ]
    pub fn fth(&self) -> u8 {
        self.bits.get_range(0u8..2u8) as u8
    }
}

impl Default for S1fcr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S1fcr { bits: 33u32 }
    }
}

impl S1fcr {
    # [ doc = "Bit 7 - FIFO error interrupt enable" ]
    pub fn set_feie(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 2 - Direct mode disable" ]
    pub fn set_dmdis(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bits 0:1 - FIFO threshold selection" ]
    pub fn set_fth(&mut self, value: u8) {
        self.bits.set_range(0u8..2u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S2cr {
    bits: u32,
}

impl S2cr {
    # [ doc = "Bits 25:27 - Channel selection" ]
    pub fn chsel(&self) -> u8 {
        self.bits.get_range(25u8..28u8) as u8
    }
    # [ doc = "Bits 23:24 - Memory burst transfer configuration" ]
    pub fn mburst(&self) -> u8 {
        self.bits.get_range(23u8..25u8) as u8
    }
    # [ doc = "Bits 21:22 - Peripheral burst transfer configuration" ]
    pub fn pburst(&self) -> u8 {
        self.bits.get_range(21u8..23u8) as u8
    }
    # [ doc = "Bit 20 - ACK" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 19 - Current target (only in double buffer mode)" ]
    pub fn ct(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 18 - Double buffer mode" ]
    pub fn dbm(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bits 16:17 - Priority level" ]
    pub fn pl(&self) -> u8 {
        self.bits.get_range(16u8..18u8) as u8
    }
    # [ doc = "Bit 15 - Peripheral increment offset size" ]
    pub fn pincos(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bits 13:14 - Memory data size" ]
    pub fn msize(&self) -> u8 {
        self.bits.get_range(13u8..15u8) as u8
    }
    # [ doc = "Bits 11:12 - Peripheral data size" ]
    pub fn psize(&self) -> u8 {
        self.bits.get_range(11u8..13u8) as u8
    }
    # [ doc = "Bit 10 - Memory increment mode" ]
    pub fn minc(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - Peripheral increment mode" ]
    pub fn pinc(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - Circular mode" ]
    pub fn circ(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bits 6:7 - Data transfer direction" ]
    pub fn dir(&self) -> u8 {
        self.bits.get_range(6u8..8u8) as u8
    }
    # [ doc = "Bit 5 - Peripheral flow controller" ]
    pub fn pfctrl(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Transfer complete interrupt enable" ]
    pub fn tcie(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Half transfer interrupt enable" ]
    pub fn htie(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Transfer error interrupt enable" ]
    pub fn teie(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Direct mode error interrupt enable" ]
    pub fn dmeie(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Stream enable / flag stream ready when read low" ]
    pub fn en(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for S2cr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S2cr { bits: 0u32 }
    }
}

impl S2cr {
    # [ doc = "Bits 25:27 - Channel selection" ]
    pub fn set_chsel(&mut self, value: u8) {
        self.bits.set_range(25u8..28u8, value as u32);
    }
    # [ doc = "Bits 23:24 - Memory burst transfer configuration" ]
    pub fn set_mburst(&mut self, value: u8) {
        self.bits.set_range(23u8..25u8, value as u32);
    }
    # [ doc = "Bits 21:22 - Peripheral burst transfer configuration" ]
    pub fn set_pburst(&mut self, value: u8) {
        self.bits.set_range(21u8..23u8, value as u32);
    }
    # [ doc = "Bit 20 - ACK" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 19 - Current target (only in double buffer mode)" ]
    pub fn set_ct(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 18 - Double buffer mode" ]
    pub fn set_dbm(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bits 16:17 - Priority level" ]
    pub fn set_pl(&mut self, value: u8) {
        self.bits.set_range(16u8..18u8, value as u32);
    }
    # [ doc = "Bit 15 - Peripheral increment offset size" ]
    pub fn set_pincos(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 13:14 - Memory data size" ]
    pub fn set_msize(&mut self, value: u8) {
        self.bits.set_range(13u8..15u8, value as u32);
    }
    # [ doc = "Bits 11:12 - Peripheral data size" ]
    pub fn set_psize(&mut self, value: u8) {
        self.bits.set_range(11u8..13u8, value as u32);
    }
    # [ doc = "Bit 10 - Memory increment mode" ]
    pub fn set_minc(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - Peripheral increment mode" ]
    pub fn set_pinc(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - Circular mode" ]
    pub fn set_circ(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bits 6:7 - Data transfer direction" ]
    pub fn set_dir(&mut self, value: u8) {
        self.bits.set_range(6u8..8u8, value as u32);
    }
    # [ doc = "Bit 5 - Peripheral flow controller" ]
    pub fn set_pfctrl(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Transfer complete interrupt enable" ]
    pub fn set_tcie(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Half transfer interrupt enable" ]
    pub fn set_htie(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Transfer error interrupt enable" ]
    pub fn set_teie(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Direct mode error interrupt enable" ]
    pub fn set_dmeie(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Stream enable / flag stream ready when read low" ]
    pub fn set_en(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S2ndtr {
    bits: u32,
}

impl S2ndtr {
    # [ doc = "Bits 0:15 - Number of data items to transfer" ]
    pub fn ndt(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for S2ndtr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S2ndtr { bits: 0u32 }
    }
}

impl S2ndtr {
    # [ doc = "Bits 0:15 - Number of data items to transfer" ]
    pub fn set_ndt(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S2par {
    bits: u32,
}

impl S2par {
    # [ doc = "Bits 0:31 - Peripheral address" ]
    pub fn pa(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S2par {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S2par { bits: 0u32 }
    }
}

impl S2par {
    # [ doc = "Bits 0:31 - Peripheral address" ]
    pub fn set_pa(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S2m0ar {
    bits: u32,
}

impl S2m0ar {
    # [ doc = "Bits 0:31 - Memory 0 address" ]
    pub fn m0a(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S2m0ar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S2m0ar { bits: 0u32 }
    }
}

impl S2m0ar {
    # [ doc = "Bits 0:31 - Memory 0 address" ]
    pub fn set_m0a(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S2m1ar {
    bits: u32,
}

impl S2m1ar {
    # [ doc = "Bits 0:31 - Memory 1 address (used in case of Double buffer mode)" ]
    pub fn m1a(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S2m1ar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S2m1ar { bits: 0u32 }
    }
}

impl S2m1ar {
    # [ doc = "Bits 0:31 - Memory 1 address (used in case of Double buffer mode)" ]
    pub fn set_m1a(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S2fcr {
    bits: u32,
}

impl S2fcr {
    # [ doc = "Bit 7 - FIFO error interrupt enable" ]
    pub fn feie(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bits 3:5 - FIFO status" ]
    pub fn fs(&self) -> u8 {
        self.bits.get_range(3u8..6u8) as u8
    }
    # [ doc = "Bit 2 - Direct mode disable" ]
    pub fn dmdis(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bits 0:1 - FIFO threshold selection" ]
    pub fn fth(&self) -> u8 {
        self.bits.get_range(0u8..2u8) as u8
    }
}

impl Default for S2fcr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S2fcr { bits: 33u32 }
    }
}

impl S2fcr {
    # [ doc = "Bit 7 - FIFO error interrupt enable" ]
    pub fn set_feie(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 2 - Direct mode disable" ]
    pub fn set_dmdis(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bits 0:1 - FIFO threshold selection" ]
    pub fn set_fth(&mut self, value: u8) {
        self.bits.set_range(0u8..2u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S3cr {
    bits: u32,
}

impl S3cr {
    # [ doc = "Bits 25:27 - Channel selection" ]
    pub fn chsel(&self) -> u8 {
        self.bits.get_range(25u8..28u8) as u8
    }
    # [ doc = "Bits 23:24 - Memory burst transfer configuration" ]
    pub fn mburst(&self) -> u8 {
        self.bits.get_range(23u8..25u8) as u8
    }
    # [ doc = "Bits 21:22 - Peripheral burst transfer configuration" ]
    pub fn pburst(&self) -> u8 {
        self.bits.get_range(21u8..23u8) as u8
    }
    # [ doc = "Bit 20 - ACK" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 19 - Current target (only in double buffer mode)" ]
    pub fn ct(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 18 - Double buffer mode" ]
    pub fn dbm(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bits 16:17 - Priority level" ]
    pub fn pl(&self) -> u8 {
        self.bits.get_range(16u8..18u8) as u8
    }
    # [ doc = "Bit 15 - Peripheral increment offset size" ]
    pub fn pincos(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bits 13:14 - Memory data size" ]
    pub fn msize(&self) -> u8 {
        self.bits.get_range(13u8..15u8) as u8
    }
    # [ doc = "Bits 11:12 - Peripheral data size" ]
    pub fn psize(&self) -> u8 {
        self.bits.get_range(11u8..13u8) as u8
    }
    # [ doc = "Bit 10 - Memory increment mode" ]
    pub fn minc(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - Peripheral increment mode" ]
    pub fn pinc(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - Circular mode" ]
    pub fn circ(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bits 6:7 - Data transfer direction" ]
    pub fn dir(&self) -> u8 {
        self.bits.get_range(6u8..8u8) as u8
    }
    # [ doc = "Bit 5 - Peripheral flow controller" ]
    pub fn pfctrl(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Transfer complete interrupt enable" ]
    pub fn tcie(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Half transfer interrupt enable" ]
    pub fn htie(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Transfer error interrupt enable" ]
    pub fn teie(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Direct mode error interrupt enable" ]
    pub fn dmeie(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Stream enable / flag stream ready when read low" ]
    pub fn en(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for S3cr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S3cr { bits: 0u32 }
    }
}

impl S3cr {
    # [ doc = "Bits 25:27 - Channel selection" ]
    pub fn set_chsel(&mut self, value: u8) {
        self.bits.set_range(25u8..28u8, value as u32);
    }
    # [ doc = "Bits 23:24 - Memory burst transfer configuration" ]
    pub fn set_mburst(&mut self, value: u8) {
        self.bits.set_range(23u8..25u8, value as u32);
    }
    # [ doc = "Bits 21:22 - Peripheral burst transfer configuration" ]
    pub fn set_pburst(&mut self, value: u8) {
        self.bits.set_range(21u8..23u8, value as u32);
    }
    # [ doc = "Bit 20 - ACK" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 19 - Current target (only in double buffer mode)" ]
    pub fn set_ct(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 18 - Double buffer mode" ]
    pub fn set_dbm(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bits 16:17 - Priority level" ]
    pub fn set_pl(&mut self, value: u8) {
        self.bits.set_range(16u8..18u8, value as u32);
    }
    # [ doc = "Bit 15 - Peripheral increment offset size" ]
    pub fn set_pincos(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 13:14 - Memory data size" ]
    pub fn set_msize(&mut self, value: u8) {
        self.bits.set_range(13u8..15u8, value as u32);
    }
    # [ doc = "Bits 11:12 - Peripheral data size" ]
    pub fn set_psize(&mut self, value: u8) {
        self.bits.set_range(11u8..13u8, value as u32);
    }
    # [ doc = "Bit 10 - Memory increment mode" ]
    pub fn set_minc(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - Peripheral increment mode" ]
    pub fn set_pinc(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - Circular mode" ]
    pub fn set_circ(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bits 6:7 - Data transfer direction" ]
    pub fn set_dir(&mut self, value: u8) {
        self.bits.set_range(6u8..8u8, value as u32);
    }
    # [ doc = "Bit 5 - Peripheral flow controller" ]
    pub fn set_pfctrl(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Transfer complete interrupt enable" ]
    pub fn set_tcie(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Half transfer interrupt enable" ]
    pub fn set_htie(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Transfer error interrupt enable" ]
    pub fn set_teie(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Direct mode error interrupt enable" ]
    pub fn set_dmeie(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Stream enable / flag stream ready when read low" ]
    pub fn set_en(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S3ndtr {
    bits: u32,
}

impl S3ndtr {
    # [ doc = "Bits 0:15 - Number of data items to transfer" ]
    pub fn ndt(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for S3ndtr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S3ndtr { bits: 0u32 }
    }
}

impl S3ndtr {
    # [ doc = "Bits 0:15 - Number of data items to transfer" ]
    pub fn set_ndt(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S3par {
    bits: u32,
}

impl S3par {
    # [ doc = "Bits 0:31 - Peripheral address" ]
    pub fn pa(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S3par {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S3par { bits: 0u32 }
    }
}

impl S3par {
    # [ doc = "Bits 0:31 - Peripheral address" ]
    pub fn set_pa(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S3m0ar {
    bits: u32,
}

impl S3m0ar {
    # [ doc = "Bits 0:31 - Memory 0 address" ]
    pub fn m0a(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S3m0ar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S3m0ar { bits: 0u32 }
    }
}

impl S3m0ar {
    # [ doc = "Bits 0:31 - Memory 0 address" ]
    pub fn set_m0a(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S3m1ar {
    bits: u32,
}

impl S3m1ar {
    # [ doc = "Bits 0:31 - Memory 1 address (used in case of Double buffer mode)" ]
    pub fn m1a(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S3m1ar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S3m1ar { bits: 0u32 }
    }
}

impl S3m1ar {
    # [ doc = "Bits 0:31 - Memory 1 address (used in case of Double buffer mode)" ]
    pub fn set_m1a(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S3fcr {
    bits: u32,
}

impl S3fcr {
    # [ doc = "Bit 7 - FIFO error interrupt enable" ]
    pub fn feie(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bits 3:5 - FIFO status" ]
    pub fn fs(&self) -> u8 {
        self.bits.get_range(3u8..6u8) as u8
    }
    # [ doc = "Bit 2 - Direct mode disable" ]
    pub fn dmdis(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bits 0:1 - FIFO threshold selection" ]
    pub fn fth(&self) -> u8 {
        self.bits.get_range(0u8..2u8) as u8
    }
}

impl Default for S3fcr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S3fcr { bits: 33u32 }
    }
}

impl S3fcr {
    # [ doc = "Bit 7 - FIFO error interrupt enable" ]
    pub fn set_feie(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 2 - Direct mode disable" ]
    pub fn set_dmdis(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bits 0:1 - FIFO threshold selection" ]
    pub fn set_fth(&mut self, value: u8) {
        self.bits.set_range(0u8..2u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S4cr {
    bits: u32,
}

impl S4cr {
    # [ doc = "Bits 25:27 - Channel selection" ]
    pub fn chsel(&self) -> u8 {
        self.bits.get_range(25u8..28u8) as u8
    }
    # [ doc = "Bits 23:24 - Memory burst transfer configuration" ]
    pub fn mburst(&self) -> u8 {
        self.bits.get_range(23u8..25u8) as u8
    }
    # [ doc = "Bits 21:22 - Peripheral burst transfer configuration" ]
    pub fn pburst(&self) -> u8 {
        self.bits.get_range(21u8..23u8) as u8
    }
    # [ doc = "Bit 20 - ACK" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 19 - Current target (only in double buffer mode)" ]
    pub fn ct(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 18 - Double buffer mode" ]
    pub fn dbm(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bits 16:17 - Priority level" ]
    pub fn pl(&self) -> u8 {
        self.bits.get_range(16u8..18u8) as u8
    }
    # [ doc = "Bit 15 - Peripheral increment offset size" ]
    pub fn pincos(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bits 13:14 - Memory data size" ]
    pub fn msize(&self) -> u8 {
        self.bits.get_range(13u8..15u8) as u8
    }
    # [ doc = "Bits 11:12 - Peripheral data size" ]
    pub fn psize(&self) -> u8 {
        self.bits.get_range(11u8..13u8) as u8
    }
    # [ doc = "Bit 10 - Memory increment mode" ]
    pub fn minc(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - Peripheral increment mode" ]
    pub fn pinc(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - Circular mode" ]
    pub fn circ(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bits 6:7 - Data transfer direction" ]
    pub fn dir(&self) -> u8 {
        self.bits.get_range(6u8..8u8) as u8
    }
    # [ doc = "Bit 5 - Peripheral flow controller" ]
    pub fn pfctrl(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Transfer complete interrupt enable" ]
    pub fn tcie(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Half transfer interrupt enable" ]
    pub fn htie(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Transfer error interrupt enable" ]
    pub fn teie(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Direct mode error interrupt enable" ]
    pub fn dmeie(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Stream enable / flag stream ready when read low" ]
    pub fn en(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for S4cr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S4cr { bits: 0u32 }
    }
}

impl S4cr {
    # [ doc = "Bits 25:27 - Channel selection" ]
    pub fn set_chsel(&mut self, value: u8) {
        self.bits.set_range(25u8..28u8, value as u32);
    }
    # [ doc = "Bits 23:24 - Memory burst transfer configuration" ]
    pub fn set_mburst(&mut self, value: u8) {
        self.bits.set_range(23u8..25u8, value as u32);
    }
    # [ doc = "Bits 21:22 - Peripheral burst transfer configuration" ]
    pub fn set_pburst(&mut self, value: u8) {
        self.bits.set_range(21u8..23u8, value as u32);
    }
    # [ doc = "Bit 20 - ACK" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 19 - Current target (only in double buffer mode)" ]
    pub fn set_ct(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 18 - Double buffer mode" ]
    pub fn set_dbm(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bits 16:17 - Priority level" ]
    pub fn set_pl(&mut self, value: u8) {
        self.bits.set_range(16u8..18u8, value as u32);
    }
    # [ doc = "Bit 15 - Peripheral increment offset size" ]
    pub fn set_pincos(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 13:14 - Memory data size" ]
    pub fn set_msize(&mut self, value: u8) {
        self.bits.set_range(13u8..15u8, value as u32);
    }
    # [ doc = "Bits 11:12 - Peripheral data size" ]
    pub fn set_psize(&mut self, value: u8) {
        self.bits.set_range(11u8..13u8, value as u32);
    }
    # [ doc = "Bit 10 - Memory increment mode" ]
    pub fn set_minc(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - Peripheral increment mode" ]
    pub fn set_pinc(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - Circular mode" ]
    pub fn set_circ(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bits 6:7 - Data transfer direction" ]
    pub fn set_dir(&mut self, value: u8) {
        self.bits.set_range(6u8..8u8, value as u32);
    }
    # [ doc = "Bit 5 - Peripheral flow controller" ]
    pub fn set_pfctrl(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Transfer complete interrupt enable" ]
    pub fn set_tcie(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Half transfer interrupt enable" ]
    pub fn set_htie(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Transfer error interrupt enable" ]
    pub fn set_teie(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Direct mode error interrupt enable" ]
    pub fn set_dmeie(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Stream enable / flag stream ready when read low" ]
    pub fn set_en(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S4ndtr {
    bits: u32,
}

impl S4ndtr {
    # [ doc = "Bits 0:15 - Number of data items to transfer" ]
    pub fn ndt(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for S4ndtr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S4ndtr { bits: 0u32 }
    }
}

impl S4ndtr {
    # [ doc = "Bits 0:15 - Number of data items to transfer" ]
    pub fn set_ndt(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S4par {
    bits: u32,
}

impl S4par {
    # [ doc = "Bits 0:31 - Peripheral address" ]
    pub fn pa(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S4par {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S4par { bits: 0u32 }
    }
}

impl S4par {
    # [ doc = "Bits 0:31 - Peripheral address" ]
    pub fn set_pa(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S4m0ar {
    bits: u32,
}

impl S4m0ar {
    # [ doc = "Bits 0:31 - Memory 0 address" ]
    pub fn m0a(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S4m0ar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S4m0ar { bits: 0u32 }
    }
}

impl S4m0ar {
    # [ doc = "Bits 0:31 - Memory 0 address" ]
    pub fn set_m0a(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S4m1ar {
    bits: u32,
}

impl S4m1ar {
    # [ doc = "Bits 0:31 - Memory 1 address (used in case of Double buffer mode)" ]
    pub fn m1a(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S4m1ar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S4m1ar { bits: 0u32 }
    }
}

impl S4m1ar {
    # [ doc = "Bits 0:31 - Memory 1 address (used in case of Double buffer mode)" ]
    pub fn set_m1a(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S4fcr {
    bits: u32,
}

impl S4fcr {
    # [ doc = "Bit 7 - FIFO error interrupt enable" ]
    pub fn feie(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bits 3:5 - FIFO status" ]
    pub fn fs(&self) -> u8 {
        self.bits.get_range(3u8..6u8) as u8
    }
    # [ doc = "Bit 2 - Direct mode disable" ]
    pub fn dmdis(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bits 0:1 - FIFO threshold selection" ]
    pub fn fth(&self) -> u8 {
        self.bits.get_range(0u8..2u8) as u8
    }
}

impl Default for S4fcr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S4fcr { bits: 33u32 }
    }
}

impl S4fcr {
    # [ doc = "Bit 7 - FIFO error interrupt enable" ]
    pub fn set_feie(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 2 - Direct mode disable" ]
    pub fn set_dmdis(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bits 0:1 - FIFO threshold selection" ]
    pub fn set_fth(&mut self, value: u8) {
        self.bits.set_range(0u8..2u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S5cr {
    bits: u32,
}

impl S5cr {
    # [ doc = "Bits 25:27 - Channel selection" ]
    pub fn chsel(&self) -> u8 {
        self.bits.get_range(25u8..28u8) as u8
    }
    # [ doc = "Bits 23:24 - Memory burst transfer configuration" ]
    pub fn mburst(&self) -> u8 {
        self.bits.get_range(23u8..25u8) as u8
    }
    # [ doc = "Bits 21:22 - Peripheral burst transfer configuration" ]
    pub fn pburst(&self) -> u8 {
        self.bits.get_range(21u8..23u8) as u8
    }
    # [ doc = "Bit 20 - ACK" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 19 - Current target (only in double buffer mode)" ]
    pub fn ct(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 18 - Double buffer mode" ]
    pub fn dbm(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bits 16:17 - Priority level" ]
    pub fn pl(&self) -> u8 {
        self.bits.get_range(16u8..18u8) as u8
    }
    # [ doc = "Bit 15 - Peripheral increment offset size" ]
    pub fn pincos(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bits 13:14 - Memory data size" ]
    pub fn msize(&self) -> u8 {
        self.bits.get_range(13u8..15u8) as u8
    }
    # [ doc = "Bits 11:12 - Peripheral data size" ]
    pub fn psize(&self) -> u8 {
        self.bits.get_range(11u8..13u8) as u8
    }
    # [ doc = "Bit 10 - Memory increment mode" ]
    pub fn minc(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - Peripheral increment mode" ]
    pub fn pinc(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - Circular mode" ]
    pub fn circ(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bits 6:7 - Data transfer direction" ]
    pub fn dir(&self) -> u8 {
        self.bits.get_range(6u8..8u8) as u8
    }
    # [ doc = "Bit 5 - Peripheral flow controller" ]
    pub fn pfctrl(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Transfer complete interrupt enable" ]
    pub fn tcie(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Half transfer interrupt enable" ]
    pub fn htie(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Transfer error interrupt enable" ]
    pub fn teie(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Direct mode error interrupt enable" ]
    pub fn dmeie(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Stream enable / flag stream ready when read low" ]
    pub fn en(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for S5cr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S5cr { bits: 0u32 }
    }
}

impl S5cr {
    # [ doc = "Bits 25:27 - Channel selection" ]
    pub fn set_chsel(&mut self, value: u8) {
        self.bits.set_range(25u8..28u8, value as u32);
    }
    # [ doc = "Bits 23:24 - Memory burst transfer configuration" ]
    pub fn set_mburst(&mut self, value: u8) {
        self.bits.set_range(23u8..25u8, value as u32);
    }
    # [ doc = "Bits 21:22 - Peripheral burst transfer configuration" ]
    pub fn set_pburst(&mut self, value: u8) {
        self.bits.set_range(21u8..23u8, value as u32);
    }
    # [ doc = "Bit 20 - ACK" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 19 - Current target (only in double buffer mode)" ]
    pub fn set_ct(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 18 - Double buffer mode" ]
    pub fn set_dbm(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bits 16:17 - Priority level" ]
    pub fn set_pl(&mut self, value: u8) {
        self.bits.set_range(16u8..18u8, value as u32);
    }
    # [ doc = "Bit 15 - Peripheral increment offset size" ]
    pub fn set_pincos(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 13:14 - Memory data size" ]
    pub fn set_msize(&mut self, value: u8) {
        self.bits.set_range(13u8..15u8, value as u32);
    }
    # [ doc = "Bits 11:12 - Peripheral data size" ]
    pub fn set_psize(&mut self, value: u8) {
        self.bits.set_range(11u8..13u8, value as u32);
    }
    # [ doc = "Bit 10 - Memory increment mode" ]
    pub fn set_minc(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - Peripheral increment mode" ]
    pub fn set_pinc(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - Circular mode" ]
    pub fn set_circ(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bits 6:7 - Data transfer direction" ]
    pub fn set_dir(&mut self, value: u8) {
        self.bits.set_range(6u8..8u8, value as u32);
    }
    # [ doc = "Bit 5 - Peripheral flow controller" ]
    pub fn set_pfctrl(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Transfer complete interrupt enable" ]
    pub fn set_tcie(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Half transfer interrupt enable" ]
    pub fn set_htie(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Transfer error interrupt enable" ]
    pub fn set_teie(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Direct mode error interrupt enable" ]
    pub fn set_dmeie(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Stream enable / flag stream ready when read low" ]
    pub fn set_en(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S5ndtr {
    bits: u32,
}

impl S5ndtr {
    # [ doc = "Bits 0:15 - Number of data items to transfer" ]
    pub fn ndt(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for S5ndtr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S5ndtr { bits: 0u32 }
    }
}

impl S5ndtr {
    # [ doc = "Bits 0:15 - Number of data items to transfer" ]
    pub fn set_ndt(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S5par {
    bits: u32,
}

impl S5par {
    # [ doc = "Bits 0:31 - Peripheral address" ]
    pub fn pa(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S5par {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S5par { bits: 0u32 }
    }
}

impl S5par {
    # [ doc = "Bits 0:31 - Peripheral address" ]
    pub fn set_pa(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S5m0ar {
    bits: u32,
}

impl S5m0ar {
    # [ doc = "Bits 0:31 - Memory 0 address" ]
    pub fn m0a(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S5m0ar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S5m0ar { bits: 0u32 }
    }
}

impl S5m0ar {
    # [ doc = "Bits 0:31 - Memory 0 address" ]
    pub fn set_m0a(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S5m1ar {
    bits: u32,
}

impl S5m1ar {
    # [ doc = "Bits 0:31 - Memory 1 address (used in case of Double buffer mode)" ]
    pub fn m1a(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S5m1ar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S5m1ar { bits: 0u32 }
    }
}

impl S5m1ar {
    # [ doc = "Bits 0:31 - Memory 1 address (used in case of Double buffer mode)" ]
    pub fn set_m1a(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S5fcr {
    bits: u32,
}

impl S5fcr {
    # [ doc = "Bit 7 - FIFO error interrupt enable" ]
    pub fn feie(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bits 3:5 - FIFO status" ]
    pub fn fs(&self) -> u8 {
        self.bits.get_range(3u8..6u8) as u8
    }
    # [ doc = "Bit 2 - Direct mode disable" ]
    pub fn dmdis(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bits 0:1 - FIFO threshold selection" ]
    pub fn fth(&self) -> u8 {
        self.bits.get_range(0u8..2u8) as u8
    }
}

impl Default for S5fcr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S5fcr { bits: 33u32 }
    }
}

impl S5fcr {
    # [ doc = "Bit 7 - FIFO error interrupt enable" ]
    pub fn set_feie(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 2 - Direct mode disable" ]
    pub fn set_dmdis(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bits 0:1 - FIFO threshold selection" ]
    pub fn set_fth(&mut self, value: u8) {
        self.bits.set_range(0u8..2u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S6cr {
    bits: u32,
}

impl S6cr {
    # [ doc = "Bits 25:27 - Channel selection" ]
    pub fn chsel(&self) -> u8 {
        self.bits.get_range(25u8..28u8) as u8
    }
    # [ doc = "Bits 23:24 - Memory burst transfer configuration" ]
    pub fn mburst(&self) -> u8 {
        self.bits.get_range(23u8..25u8) as u8
    }
    # [ doc = "Bits 21:22 - Peripheral burst transfer configuration" ]
    pub fn pburst(&self) -> u8 {
        self.bits.get_range(21u8..23u8) as u8
    }
    # [ doc = "Bit 20 - ACK" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 19 - Current target (only in double buffer mode)" ]
    pub fn ct(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 18 - Double buffer mode" ]
    pub fn dbm(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bits 16:17 - Priority level" ]
    pub fn pl(&self) -> u8 {
        self.bits.get_range(16u8..18u8) as u8
    }
    # [ doc = "Bit 15 - Peripheral increment offset size" ]
    pub fn pincos(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bits 13:14 - Memory data size" ]
    pub fn msize(&self) -> u8 {
        self.bits.get_range(13u8..15u8) as u8
    }
    # [ doc = "Bits 11:12 - Peripheral data size" ]
    pub fn psize(&self) -> u8 {
        self.bits.get_range(11u8..13u8) as u8
    }
    # [ doc = "Bit 10 - Memory increment mode" ]
    pub fn minc(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - Peripheral increment mode" ]
    pub fn pinc(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - Circular mode" ]
    pub fn circ(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bits 6:7 - Data transfer direction" ]
    pub fn dir(&self) -> u8 {
        self.bits.get_range(6u8..8u8) as u8
    }
    # [ doc = "Bit 5 - Peripheral flow controller" ]
    pub fn pfctrl(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Transfer complete interrupt enable" ]
    pub fn tcie(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Half transfer interrupt enable" ]
    pub fn htie(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Transfer error interrupt enable" ]
    pub fn teie(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Direct mode error interrupt enable" ]
    pub fn dmeie(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Stream enable / flag stream ready when read low" ]
    pub fn en(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for S6cr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S6cr { bits: 0u32 }
    }
}

impl S6cr {
    # [ doc = "Bits 25:27 - Channel selection" ]
    pub fn set_chsel(&mut self, value: u8) {
        self.bits.set_range(25u8..28u8, value as u32);
    }
    # [ doc = "Bits 23:24 - Memory burst transfer configuration" ]
    pub fn set_mburst(&mut self, value: u8) {
        self.bits.set_range(23u8..25u8, value as u32);
    }
    # [ doc = "Bits 21:22 - Peripheral burst transfer configuration" ]
    pub fn set_pburst(&mut self, value: u8) {
        self.bits.set_range(21u8..23u8, value as u32);
    }
    # [ doc = "Bit 20 - ACK" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 19 - Current target (only in double buffer mode)" ]
    pub fn set_ct(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 18 - Double buffer mode" ]
    pub fn set_dbm(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bits 16:17 - Priority level" ]
    pub fn set_pl(&mut self, value: u8) {
        self.bits.set_range(16u8..18u8, value as u32);
    }
    # [ doc = "Bit 15 - Peripheral increment offset size" ]
    pub fn set_pincos(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 13:14 - Memory data size" ]
    pub fn set_msize(&mut self, value: u8) {
        self.bits.set_range(13u8..15u8, value as u32);
    }
    # [ doc = "Bits 11:12 - Peripheral data size" ]
    pub fn set_psize(&mut self, value: u8) {
        self.bits.set_range(11u8..13u8, value as u32);
    }
    # [ doc = "Bit 10 - Memory increment mode" ]
    pub fn set_minc(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - Peripheral increment mode" ]
    pub fn set_pinc(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - Circular mode" ]
    pub fn set_circ(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bits 6:7 - Data transfer direction" ]
    pub fn set_dir(&mut self, value: u8) {
        self.bits.set_range(6u8..8u8, value as u32);
    }
    # [ doc = "Bit 5 - Peripheral flow controller" ]
    pub fn set_pfctrl(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Transfer complete interrupt enable" ]
    pub fn set_tcie(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Half transfer interrupt enable" ]
    pub fn set_htie(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Transfer error interrupt enable" ]
    pub fn set_teie(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Direct mode error interrupt enable" ]
    pub fn set_dmeie(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Stream enable / flag stream ready when read low" ]
    pub fn set_en(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S6ndtr {
    bits: u32,
}

impl S6ndtr {
    # [ doc = "Bits 0:15 - Number of data items to transfer" ]
    pub fn ndt(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for S6ndtr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S6ndtr { bits: 0u32 }
    }
}

impl S6ndtr {
    # [ doc = "Bits 0:15 - Number of data items to transfer" ]
    pub fn set_ndt(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S6par {
    bits: u32,
}

impl S6par {
    # [ doc = "Bits 0:31 - Peripheral address" ]
    pub fn pa(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S6par {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S6par { bits: 0u32 }
    }
}

impl S6par {
    # [ doc = "Bits 0:31 - Peripheral address" ]
    pub fn set_pa(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S6m0ar {
    bits: u32,
}

impl S6m0ar {
    # [ doc = "Bits 0:31 - Memory 0 address" ]
    pub fn m0a(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S6m0ar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S6m0ar { bits: 0u32 }
    }
}

impl S6m0ar {
    # [ doc = "Bits 0:31 - Memory 0 address" ]
    pub fn set_m0a(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S6m1ar {
    bits: u32,
}

impl S6m1ar {
    # [ doc = "Bits 0:31 - Memory 1 address (used in case of Double buffer mode)" ]
    pub fn m1a(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S6m1ar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S6m1ar { bits: 0u32 }
    }
}

impl S6m1ar {
    # [ doc = "Bits 0:31 - Memory 1 address (used in case of Double buffer mode)" ]
    pub fn set_m1a(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S6fcr {
    bits: u32,
}

impl S6fcr {
    # [ doc = "Bit 7 - FIFO error interrupt enable" ]
    pub fn feie(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bits 3:5 - FIFO status" ]
    pub fn fs(&self) -> u8 {
        self.bits.get_range(3u8..6u8) as u8
    }
    # [ doc = "Bit 2 - Direct mode disable" ]
    pub fn dmdis(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bits 0:1 - FIFO threshold selection" ]
    pub fn fth(&self) -> u8 {
        self.bits.get_range(0u8..2u8) as u8
    }
}

impl Default for S6fcr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S6fcr { bits: 33u32 }
    }
}

impl S6fcr {
    # [ doc = "Bit 7 - FIFO error interrupt enable" ]
    pub fn set_feie(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 2 - Direct mode disable" ]
    pub fn set_dmdis(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bits 0:1 - FIFO threshold selection" ]
    pub fn set_fth(&mut self, value: u8) {
        self.bits.set_range(0u8..2u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S7cr {
    bits: u32,
}

impl S7cr {
    # [ doc = "Bits 25:27 - Channel selection" ]
    pub fn chsel(&self) -> u8 {
        self.bits.get_range(25u8..28u8) as u8
    }
    # [ doc = "Bits 23:24 - Memory burst transfer configuration" ]
    pub fn mburst(&self) -> u8 {
        self.bits.get_range(23u8..25u8) as u8
    }
    # [ doc = "Bits 21:22 - Peripheral burst transfer configuration" ]
    pub fn pburst(&self) -> u8 {
        self.bits.get_range(21u8..23u8) as u8
    }
    # [ doc = "Bit 20 - ACK" ]
    pub fn ack(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 19 - Current target (only in double buffer mode)" ]
    pub fn ct(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 18 - Double buffer mode" ]
    pub fn dbm(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bits 16:17 - Priority level" ]
    pub fn pl(&self) -> u8 {
        self.bits.get_range(16u8..18u8) as u8
    }
    # [ doc = "Bit 15 - Peripheral increment offset size" ]
    pub fn pincos(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bits 13:14 - Memory data size" ]
    pub fn msize(&self) -> u8 {
        self.bits.get_range(13u8..15u8) as u8
    }
    # [ doc = "Bits 11:12 - Peripheral data size" ]
    pub fn psize(&self) -> u8 {
        self.bits.get_range(11u8..13u8) as u8
    }
    # [ doc = "Bit 10 - Memory increment mode" ]
    pub fn minc(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - Peripheral increment mode" ]
    pub fn pinc(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - Circular mode" ]
    pub fn circ(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bits 6:7 - Data transfer direction" ]
    pub fn dir(&self) -> u8 {
        self.bits.get_range(6u8..8u8) as u8
    }
    # [ doc = "Bit 5 - Peripheral flow controller" ]
    pub fn pfctrl(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Transfer complete interrupt enable" ]
    pub fn tcie(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Half transfer interrupt enable" ]
    pub fn htie(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Transfer error interrupt enable" ]
    pub fn teie(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Direct mode error interrupt enable" ]
    pub fn dmeie(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Stream enable / flag stream ready when read low" ]
    pub fn en(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for S7cr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S7cr { bits: 0u32 }
    }
}

impl S7cr {
    # [ doc = "Bits 25:27 - Channel selection" ]
    pub fn set_chsel(&mut self, value: u8) {
        self.bits.set_range(25u8..28u8, value as u32);
    }
    # [ doc = "Bits 23:24 - Memory burst transfer configuration" ]
    pub fn set_mburst(&mut self, value: u8) {
        self.bits.set_range(23u8..25u8, value as u32);
    }
    # [ doc = "Bits 21:22 - Peripheral burst transfer configuration" ]
    pub fn set_pburst(&mut self, value: u8) {
        self.bits.set_range(21u8..23u8, value as u32);
    }
    # [ doc = "Bit 20 - ACK" ]
    pub fn set_ack(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 19 - Current target (only in double buffer mode)" ]
    pub fn set_ct(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 18 - Double buffer mode" ]
    pub fn set_dbm(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bits 16:17 - Priority level" ]
    pub fn set_pl(&mut self, value: u8) {
        self.bits.set_range(16u8..18u8, value as u32);
    }
    # [ doc = "Bit 15 - Peripheral increment offset size" ]
    pub fn set_pincos(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bits 13:14 - Memory data size" ]
    pub fn set_msize(&mut self, value: u8) {
        self.bits.set_range(13u8..15u8, value as u32);
    }
    # [ doc = "Bits 11:12 - Peripheral data size" ]
    pub fn set_psize(&mut self, value: u8) {
        self.bits.set_range(11u8..13u8, value as u32);
    }
    # [ doc = "Bit 10 - Memory increment mode" ]
    pub fn set_minc(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - Peripheral increment mode" ]
    pub fn set_pinc(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - Circular mode" ]
    pub fn set_circ(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bits 6:7 - Data transfer direction" ]
    pub fn set_dir(&mut self, value: u8) {
        self.bits.set_range(6u8..8u8, value as u32);
    }
    # [ doc = "Bit 5 - Peripheral flow controller" ]
    pub fn set_pfctrl(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Transfer complete interrupt enable" ]
    pub fn set_tcie(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Half transfer interrupt enable" ]
    pub fn set_htie(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Transfer error interrupt enable" ]
    pub fn set_teie(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Direct mode error interrupt enable" ]
    pub fn set_dmeie(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Stream enable / flag stream ready when read low" ]
    pub fn set_en(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S7ndtr {
    bits: u32,
}

impl S7ndtr {
    # [ doc = "Bits 0:15 - Number of data items to transfer" ]
    pub fn ndt(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for S7ndtr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S7ndtr { bits: 0u32 }
    }
}

impl S7ndtr {
    # [ doc = "Bits 0:15 - Number of data items to transfer" ]
    pub fn set_ndt(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S7par {
    bits: u32,
}

impl S7par {
    # [ doc = "Bits 0:31 - Peripheral address" ]
    pub fn pa(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S7par {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S7par { bits: 0u32 }
    }
}

impl S7par {
    # [ doc = "Bits 0:31 - Peripheral address" ]
    pub fn set_pa(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S7m0ar {
    bits: u32,
}

impl S7m0ar {
    # [ doc = "Bits 0:31 - Memory 0 address" ]
    pub fn m0a(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S7m0ar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S7m0ar { bits: 0u32 }
    }
}

impl S7m0ar {
    # [ doc = "Bits 0:31 - Memory 0 address" ]
    pub fn set_m0a(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S7m1ar {
    bits: u32,
}

impl S7m1ar {
    # [ doc = "Bits 0:31 - Memory 1 address (used in case of Double buffer mode)" ]
    pub fn m1a(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for S7m1ar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S7m1ar { bits: 0u32 }
    }
}

impl S7m1ar {
    # [ doc = "Bits 0:31 - Memory 1 address (used in case of Double buffer mode)" ]
    pub fn set_m1a(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct S7fcr {
    bits: u32,
}

impl S7fcr {
    # [ doc = "Bit 7 - FIFO error interrupt enable" ]
    pub fn feie(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bits 3:5 - FIFO status" ]
    pub fn fs(&self) -> u8 {
        self.bits.get_range(3u8..6u8) as u8
    }
    # [ doc = "Bit 2 - Direct mode disable" ]
    pub fn dmdis(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bits 0:1 - FIFO threshold selection" ]
    pub fn fth(&self) -> u8 {
        self.bits.get_range(0u8..2u8) as u8
    }
}

impl Default for S7fcr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        S7fcr { bits: 33u32 }
    }
}

impl S7fcr {
    # [ doc = "Bit 7 - FIFO error interrupt enable" ]
    pub fn set_feie(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 2 - Direct mode disable" ]
    pub fn set_dmdis(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bits 0:1 - FIFO threshold selection" ]
    pub fn set_fth(&mut self, value: u8) {
        self.bits.set_range(0u8..2u8, value as u32);
    }
}
