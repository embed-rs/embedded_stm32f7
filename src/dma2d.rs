// autogenerated

use volatile;
use bit_field::BitField;

# [ doc = "DMA2D controller" ]
# [ repr ( C ) ]
pub struct Dma2d {
    # [ doc = "0x00 - control register" ]
    pub cr: volatile::ReadWrite<Cr>,
    # [ doc = "0x04 - Interrupt Status Register" ]
    pub isr: volatile::ReadOnly<Isr>,
    # [ doc = "0x08 - interrupt flag clear register" ]
    pub ifcr: volatile::ReadWrite<Ifcr>,
    # [ doc = "0x0c - foreground memory address register" ]
    pub fgmar: volatile::ReadWrite<Fgmar>,
    # [ doc = "0x10 - foreground offset register" ]
    pub fgor: volatile::ReadWrite<Fgor>,
    # [ doc = "0x14 - background memory address register" ]
    pub bgmar: volatile::ReadWrite<Bgmar>,
    # [ doc = "0x18 - background offset register" ]
    pub bgor: volatile::ReadWrite<Bgor>,
    # [ doc = "0x1c - foreground PFC control register" ]
    pub fgpfccr: volatile::ReadWrite<Fgpfccr>,
    # [ doc = "0x20 - foreground color register" ]
    pub fgcolr: volatile::ReadWrite<Fgcolr>,
    # [ doc = "0x24 - background PFC control register" ]
    pub bgpfccr: volatile::ReadWrite<Bgpfccr>,
    # [ doc = "0x28 - background color register" ]
    pub bgcolr: volatile::ReadWrite<Bgcolr>,
    # [ doc = "0x2c - foreground CLUT memory address register" ]
    pub fgcmar: volatile::ReadWrite<Fgcmar>,
    # [ doc = "0x30 - background CLUT memory address register" ]
    pub bgcmar: volatile::ReadWrite<Bgcmar>,
    # [ doc = "0x34 - output PFC control register" ]
    pub opfccr: volatile::ReadWrite<Opfccr>,
    # [ doc = "0x38 - output color register" ]
    pub ocolr: volatile::ReadWrite<Ocolr>,
    # [ doc = "0x3c - output memory address register" ]
    pub omar: volatile::ReadWrite<Omar>,
    # [ doc = "0x40 - output offset register" ]
    pub oor: volatile::ReadWrite<Oor>,
    # [ doc = "0x44 - number of line register" ]
    pub nlr: volatile::ReadWrite<Nlr>,
    # [ doc = "0x48 - line watermark register" ]
    pub lwr: volatile::ReadWrite<Lwr>,
    # [ doc = "0x4c - AHB master timer configuration register" ]
    pub amtcr: volatile::ReadWrite<Amtcr>,
    _reserved0: [u8; 944usize],
    # [ doc = "0x400 - FGCLUT" ]
    pub fgclut: volatile::ReadWrite<Fgclut>,
    _reserved1: [u8; 1020usize],
    # [ doc = "0x800 - BGCLUT" ]
    pub bgclut: volatile::ReadWrite<Bgclut>,
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Cr {
    bits: u32,
}

impl Cr {
    # [ doc = "Bits 16:17 - DMA2D mode" ]
    pub fn mode(&self) -> u8 {
        self.bits.get_range(16u8..18u8) as u8
    }
    # [ doc = "Bit 13 - Configuration Error Interrupt Enable" ]
    pub fn ceie(&self) -> bool {
        self.bits.get_bit(13u8)
    }
    # [ doc = "Bit 12 - CLUT transfer complete interrupt enable" ]
    pub fn ctcie(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 11 - CLUT access error interrupt enable" ]
    pub fn caeie(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 10 - Transfer watermark interrupt enable" ]
    pub fn twie(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - Transfer complete interrupt enable" ]
    pub fn tcie(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - Transfer error interrupt enable" ]
    pub fn teie(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 2 - Abort" ]
    pub fn abort(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Suspend" ]
    pub fn susp(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Start" ]
    pub fn start(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Cr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Cr { bits: 0u32 }
    }
}

impl Cr {
    # [ doc = "Bits 16:17 - DMA2D mode" ]
    pub fn set_mode(&mut self, value: u8) {
        self.bits.set_range(16u8..18u8, value as u32);
    }
    # [ doc = "Bit 13 - Configuration Error Interrupt Enable" ]
    pub fn set_ceie(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
    # [ doc = "Bit 12 - CLUT transfer complete interrupt enable" ]
    pub fn set_ctcie(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 11 - CLUT access error interrupt enable" ]
    pub fn set_caeie(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 10 - Transfer watermark interrupt enable" ]
    pub fn set_twie(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - Transfer complete interrupt enable" ]
    pub fn set_tcie(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - Transfer error interrupt enable" ]
    pub fn set_teie(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 2 - Abort" ]
    pub fn set_abort(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Suspend" ]
    pub fn set_susp(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Start" ]
    pub fn set_start(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Isr {
    bits: u32,
}

impl Isr {
    # [ doc = "Bit 5 - Configuration error interrupt flag" ]
    pub fn ceif(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - CLUT transfer complete interrupt flag" ]
    pub fn ctcif(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - CLUT access error interrupt flag" ]
    pub fn caeif(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Transfer watermark interrupt flag" ]
    pub fn twif(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Transfer complete interrupt flag" ]
    pub fn tcif(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Transfer error interrupt flag" ]
    pub fn teif(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Isr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Isr { bits: 0u32 }
    }
}

impl Isr {
    # [ doc = "Bit 5 - Configuration error interrupt flag" ]
    pub fn set_ceif(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - CLUT transfer complete interrupt flag" ]
    pub fn set_ctcif(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - CLUT access error interrupt flag" ]
    pub fn set_caeif(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Transfer watermark interrupt flag" ]
    pub fn set_twif(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Transfer complete interrupt flag" ]
    pub fn set_tcif(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Transfer error interrupt flag" ]
    pub fn set_teif(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ifcr {
    bits: u32,
}

impl Ifcr {
    # [ doc = "Bit 5 - Clear configuration error interrupt flag" ]
    pub fn cceif(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Clear CLUT transfer complete interrupt flag" ]
    pub fn cctcif(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Clear CLUT access error interrupt flag" ]
    pub fn caecif(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Clear transfer watermark interrupt flag" ]
    pub fn ctwif(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Clear transfer complete interrupt flag" ]
    pub fn ctcif(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Clear Transfer error interrupt flag" ]
    pub fn cteif(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Ifcr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ifcr { bits: 0u32 }
    }
}

impl Ifcr {
    # [ doc = "Bit 5 - Clear configuration error interrupt flag" ]
    pub fn set_cceif(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Clear CLUT transfer complete interrupt flag" ]
    pub fn set_cctcif(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Clear CLUT access error interrupt flag" ]
    pub fn set_caecif(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - Clear transfer watermark interrupt flag" ]
    pub fn set_ctwif(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Clear transfer complete interrupt flag" ]
    pub fn set_ctcif(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Clear Transfer error interrupt flag" ]
    pub fn set_cteif(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Fgmar {
    bits: u32,
}

impl Fgmar {
    # [ doc = "Bits 0:31 - Memory address" ]
    pub fn ma(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Fgmar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Fgmar { bits: 0u32 }
    }
}

impl Fgmar {
    # [ doc = "Bits 0:31 - Memory address" ]
    pub fn set_ma(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Fgor {
    bits: u32,
}

impl Fgor {
    # [ doc = "Bits 0:13 - Line offset" ]
    pub fn lo(&self) -> u16 {
        self.bits.get_range(0u8..14u8) as u16
    }
}

impl Default for Fgor {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Fgor { bits: 0u32 }
    }
}

impl Fgor {
    # [ doc = "Bits 0:13 - Line offset" ]
    pub fn set_lo(&mut self, value: u16) {
        self.bits.set_range(0u8..14u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bgmar {
    bits: u32,
}

impl Bgmar {
    # [ doc = "Bits 0:31 - Memory address" ]
    pub fn ma(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bgmar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bgmar { bits: 0u32 }
    }
}

impl Bgmar {
    # [ doc = "Bits 0:31 - Memory address" ]
    pub fn set_ma(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bgor {
    bits: u32,
}

impl Bgor {
    # [ doc = "Bits 0:13 - Line offset" ]
    pub fn lo(&self) -> u16 {
        self.bits.get_range(0u8..14u8) as u16
    }
}

impl Default for Bgor {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bgor { bits: 0u32 }
    }
}

impl Bgor {
    # [ doc = "Bits 0:13 - Line offset" ]
    pub fn set_lo(&mut self, value: u16) {
        self.bits.set_range(0u8..14u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Fgpfccr {
    bits: u32,
}

impl Fgpfccr {
    # [ doc = "Bits 24:31 - Alpha value" ]
    pub fn alpha(&self) -> u8 {
        self.bits.get_range(24u8..32u8) as u8
    }
    # [ doc = "Bits 16:17 - Alpha mode" ]
    pub fn am(&self) -> u8 {
        self.bits.get_range(16u8..18u8) as u8
    }
    # [ doc = "Bits 8:15 - CLUT size" ]
    pub fn cs(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bit 5 - Start" ]
    pub fn start(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - CLUT color mode" ]
    pub fn ccm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bits 0:3 - Color mode" ]
    pub fn cm(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
}

impl Default for Fgpfccr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Fgpfccr { bits: 0u32 }
    }
}

impl Fgpfccr {
    # [ doc = "Bits 24:31 - Alpha value" ]
    pub fn set_alpha(&mut self, value: u8) {
        self.bits.set_range(24u8..32u8, value as u32);
    }
    # [ doc = "Bits 16:17 - Alpha mode" ]
    pub fn set_am(&mut self, value: u8) {
        self.bits.set_range(16u8..18u8, value as u32);
    }
    # [ doc = "Bits 8:15 - CLUT size" ]
    pub fn set_cs(&mut self, value: u8) {
        self.bits.set_range(8u8..16u8, value as u32);
    }
    # [ doc = "Bit 5 - Start" ]
    pub fn set_start(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - CLUT color mode" ]
    pub fn set_ccm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bits 0:3 - Color mode" ]
    pub fn set_cm(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Fgcolr {
    bits: u32,
}

impl Fgcolr {
    # [ doc = "Bits 16:23 - Red Value" ]
    pub fn red(&self) -> u8 {
        self.bits.get_range(16u8..24u8) as u8
    }
    # [ doc = "Bits 8:15 - Green Value" ]
    pub fn green(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bits 0:7 - Blue Value" ]
    pub fn blue(&self) -> u8 {
        self.bits.get_range(0u8..8u8) as u8
    }
}

impl Default for Fgcolr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Fgcolr { bits: 0u32 }
    }
}

impl Fgcolr {
    # [ doc = "Bits 16:23 - Red Value" ]
    pub fn set_red(&mut self, value: u8) {
        self.bits.set_range(16u8..24u8, value as u32);
    }
    # [ doc = "Bits 8:15 - Green Value" ]
    pub fn set_green(&mut self, value: u8) {
        self.bits.set_range(8u8..16u8, value as u32);
    }
    # [ doc = "Bits 0:7 - Blue Value" ]
    pub fn set_blue(&mut self, value: u8) {
        self.bits.set_range(0u8..8u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bgpfccr {
    bits: u32,
}

impl Bgpfccr {
    # [ doc = "Bits 24:31 - Alpha value" ]
    pub fn alpha(&self) -> u8 {
        self.bits.get_range(24u8..32u8) as u8
    }
    # [ doc = "Bits 16:17 - Alpha mode" ]
    pub fn am(&self) -> u8 {
        self.bits.get_range(16u8..18u8) as u8
    }
    # [ doc = "Bits 8:15 - CLUT size" ]
    pub fn cs(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bit 5 - Start" ]
    pub fn start(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - CLUT Color mode" ]
    pub fn ccm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bits 0:3 - Color mode" ]
    pub fn cm(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
}

impl Default for Bgpfccr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bgpfccr { bits: 0u32 }
    }
}

impl Bgpfccr {
    # [ doc = "Bits 24:31 - Alpha value" ]
    pub fn set_alpha(&mut self, value: u8) {
        self.bits.set_range(24u8..32u8, value as u32);
    }
    # [ doc = "Bits 16:17 - Alpha mode" ]
    pub fn set_am(&mut self, value: u8) {
        self.bits.set_range(16u8..18u8, value as u32);
    }
    # [ doc = "Bits 8:15 - CLUT size" ]
    pub fn set_cs(&mut self, value: u8) {
        self.bits.set_range(8u8..16u8, value as u32);
    }
    # [ doc = "Bit 5 - Start" ]
    pub fn set_start(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - CLUT Color mode" ]
    pub fn set_ccm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bits 0:3 - Color mode" ]
    pub fn set_cm(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bgcolr {
    bits: u32,
}

impl Bgcolr {
    # [ doc = "Bits 16:23 - Red Value" ]
    pub fn red(&self) -> u8 {
        self.bits.get_range(16u8..24u8) as u8
    }
    # [ doc = "Bits 8:15 - Green Value" ]
    pub fn green(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bits 0:7 - Blue Value" ]
    pub fn blue(&self) -> u8 {
        self.bits.get_range(0u8..8u8) as u8
    }
}

impl Default for Bgcolr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bgcolr { bits: 0u32 }
    }
}

impl Bgcolr {
    # [ doc = "Bits 16:23 - Red Value" ]
    pub fn set_red(&mut self, value: u8) {
        self.bits.set_range(16u8..24u8, value as u32);
    }
    # [ doc = "Bits 8:15 - Green Value" ]
    pub fn set_green(&mut self, value: u8) {
        self.bits.set_range(8u8..16u8, value as u32);
    }
    # [ doc = "Bits 0:7 - Blue Value" ]
    pub fn set_blue(&mut self, value: u8) {
        self.bits.set_range(0u8..8u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Fgcmar {
    bits: u32,
}

impl Fgcmar {
    # [ doc = "Bits 0:31 - Memory Address" ]
    pub fn ma(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Fgcmar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Fgcmar { bits: 0u32 }
    }
}

impl Fgcmar {
    # [ doc = "Bits 0:31 - Memory Address" ]
    pub fn set_ma(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bgcmar {
    bits: u32,
}

impl Bgcmar {
    # [ doc = "Bits 0:31 - Memory address" ]
    pub fn ma(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Bgcmar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bgcmar { bits: 0u32 }
    }
}

impl Bgcmar {
    # [ doc = "Bits 0:31 - Memory address" ]
    pub fn set_ma(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Opfccr {
    bits: u32,
}

impl Opfccr {
    # [ doc = "Bits 0:2 - Color mode" ]
    pub fn cm(&self) -> u8 {
        self.bits.get_range(0u8..3u8) as u8
    }
}

impl Default for Opfccr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Opfccr { bits: 0u32 }
    }
}

impl Opfccr {
    # [ doc = "Bits 0:2 - Color mode" ]
    pub fn set_cm(&mut self, value: u8) {
        self.bits.set_range(0u8..3u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ocolr {
    bits: u32,
}

impl Ocolr {
    # [ doc = "Bits 24:31 - Alpha Channel Value" ]
    pub fn aplha(&self) -> u8 {
        self.bits.get_range(24u8..32u8) as u8
    }
    # [ doc = "Bits 16:23 - Red Value" ]
    pub fn red(&self) -> u8 {
        self.bits.get_range(16u8..24u8) as u8
    }
    # [ doc = "Bits 8:15 - Green Value" ]
    pub fn green(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bits 0:7 - Blue Value" ]
    pub fn blue(&self) -> u8 {
        self.bits.get_range(0u8..8u8) as u8
    }
}

impl Default for Ocolr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ocolr { bits: 0u32 }
    }
}

impl Ocolr {
    # [ doc = "Bits 24:31 - Alpha Channel Value" ]
    pub fn set_aplha(&mut self, value: u8) {
        self.bits.set_range(24u8..32u8, value as u32);
    }
    # [ doc = "Bits 16:23 - Red Value" ]
    pub fn set_red(&mut self, value: u8) {
        self.bits.set_range(16u8..24u8, value as u32);
    }
    # [ doc = "Bits 8:15 - Green Value" ]
    pub fn set_green(&mut self, value: u8) {
        self.bits.set_range(8u8..16u8, value as u32);
    }
    # [ doc = "Bits 0:7 - Blue Value" ]
    pub fn set_blue(&mut self, value: u8) {
        self.bits.set_range(0u8..8u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Omar {
    bits: u32,
}

impl Omar {
    # [ doc = "Bits 0:31 - Memory Address" ]
    pub fn ma(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Omar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Omar { bits: 0u32 }
    }
}

impl Omar {
    # [ doc = "Bits 0:31 - Memory Address" ]
    pub fn set_ma(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Oor {
    bits: u32,
}

impl Oor {
    # [ doc = "Bits 0:13 - Line Offset" ]
    pub fn lo(&self) -> u16 {
        self.bits.get_range(0u8..14u8) as u16
    }
}

impl Default for Oor {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Oor { bits: 0u32 }
    }
}

impl Oor {
    # [ doc = "Bits 0:13 - Line Offset" ]
    pub fn set_lo(&mut self, value: u16) {
        self.bits.set_range(0u8..14u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Nlr {
    bits: u32,
}

impl Nlr {
    # [ doc = "Bits 16:29 - Pixel per lines" ]
    pub fn pl(&self) -> u16 {
        self.bits.get_range(16u8..30u8) as u16
    }
    # [ doc = "Bits 0:15 - Number of lines" ]
    pub fn nl(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for Nlr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Nlr { bits: 0u32 }
    }
}

impl Nlr {
    # [ doc = "Bits 16:29 - Pixel per lines" ]
    pub fn set_pl(&mut self, value: u16) {
        self.bits.set_range(16u8..30u8, value as u32);
    }
    # [ doc = "Bits 0:15 - Number of lines" ]
    pub fn set_nl(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Lwr {
    bits: u32,
}

impl Lwr {
    # [ doc = "Bits 0:15 - Line watermark" ]
    pub fn lw(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for Lwr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Lwr { bits: 0u32 }
    }
}

impl Lwr {
    # [ doc = "Bits 0:15 - Line watermark" ]
    pub fn set_lw(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Amtcr {
    bits: u32,
}

impl Amtcr {
    # [ doc = "Bits 8:15 - Dead Time" ]
    pub fn dt(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bit 0 - Enable" ]
    pub fn en(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Amtcr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Amtcr { bits: 0u32 }
    }
}

impl Amtcr {
    # [ doc = "Bits 8:15 - Dead Time" ]
    pub fn set_dt(&mut self, value: u8) {
        self.bits.set_range(8u8..16u8, value as u32);
    }
    # [ doc = "Bit 0 - Enable" ]
    pub fn set_en(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Fgclut {
    bits: u32,
}

impl Fgclut {
    # [ doc = "Bits 24:31 - APLHA" ]
    pub fn aplha(&self) -> u8 {
        self.bits.get_range(24u8..32u8) as u8
    }
    # [ doc = "Bits 16:23 - RED" ]
    pub fn red(&self) -> u8 {
        self.bits.get_range(16u8..24u8) as u8
    }
    # [ doc = "Bits 8:15 - GREEN" ]
    pub fn green(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bits 0:7 - BLUE" ]
    pub fn blue(&self) -> u8 {
        self.bits.get_range(0u8..8u8) as u8
    }
}

impl Default for Fgclut {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Fgclut { bits: 0u32 }
    }
}

impl Fgclut {
    # [ doc = "Bits 24:31 - APLHA" ]
    pub fn set_aplha(&mut self, value: u8) {
        self.bits.set_range(24u8..32u8, value as u32);
    }
    # [ doc = "Bits 16:23 - RED" ]
    pub fn set_red(&mut self, value: u8) {
        self.bits.set_range(16u8..24u8, value as u32);
    }
    # [ doc = "Bits 8:15 - GREEN" ]
    pub fn set_green(&mut self, value: u8) {
        self.bits.set_range(8u8..16u8, value as u32);
    }
    # [ doc = "Bits 0:7 - BLUE" ]
    pub fn set_blue(&mut self, value: u8) {
        self.bits.set_range(0u8..8u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Bgclut {
    bits: u32,
}

impl Bgclut {
    # [ doc = "Bits 24:31 - APLHA" ]
    pub fn aplha(&self) -> u8 {
        self.bits.get_range(24u8..32u8) as u8
    }
    # [ doc = "Bits 16:23 - RED" ]
    pub fn red(&self) -> u8 {
        self.bits.get_range(16u8..24u8) as u8
    }
    # [ doc = "Bits 8:15 - GREEN" ]
    pub fn green(&self) -> u8 {
        self.bits.get_range(8u8..16u8) as u8
    }
    # [ doc = "Bits 0:7 - BLUE" ]
    pub fn blue(&self) -> u8 {
        self.bits.get_range(0u8..8u8) as u8
    }
}

impl Default for Bgclut {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Bgclut { bits: 0u32 }
    }
}

impl Bgclut {
    # [ doc = "Bits 24:31 - APLHA" ]
    pub fn set_aplha(&mut self, value: u8) {
        self.bits.set_range(24u8..32u8, value as u32);
    }
    # [ doc = "Bits 16:23 - RED" ]
    pub fn set_red(&mut self, value: u8) {
        self.bits.set_range(16u8..24u8, value as u32);
    }
    # [ doc = "Bits 8:15 - GREEN" ]
    pub fn set_green(&mut self, value: u8) {
        self.bits.set_range(8u8..16u8, value as u32);
    }
    # [ doc = "Bits 0:7 - BLUE" ]
    pub fn set_blue(&mut self, value: u8) {
        self.bits.set_range(0u8..8u8, value as u32);
    }
}
