// autogenerated and modified

use volatile;
use bit_field::BitField;

# [ doc = "Nested Vectored Interrupt Controller" ]
# [ repr ( C ) ]
pub struct Nvic {
    _reserved0: [u8; 4usize],
    
    # [ doc = "0x04 - Interrupt Controller Type Register" ]
    pub ictr: volatile::ReadOnly<Ictr>,
    
    _reserved1: [u8; 248usize],
    
    # [ doc = "0x100 - Interrupt Set-Enable Register" ]
    pub iser: [volatile::ReadWrite<Iser>; 4],
    
    _reserved2: [u8; 112usize],
    
    # [ doc = "0x180 - Interrupt Clear-Enable Register" ]
    pub icer: [volatile::ReadWrite<Icer>; 4],

    _reserved3: [u8; 112usize],
    
    # [ doc = "0x200 - Interrupt Set-Pending Register" ]
    pub ispr: [volatile::ReadWrite<Ispr>; 4],
    
    _reserved4: [u8; 112usize],
    
    # [ doc = "0x280 - Interrupt Clear-Pending Register" ]
    pub icpr: [volatile::ReadWrite<Icpr>; 4],
    
    _reserved5: [u8; 112usize],
    
    # [ doc = "0x300 - Interrupt Active Bit Register" ]
    pub iabr: [volatile::ReadOnly<Iabr>; 4],

    _reserved6: [u8; 240usize],
    
    # [ doc = "0x400 - Interrupt Priority Register" ]
    pub ipr: [volatile::ReadWrite<Ipr>;98],
    
    _reserved7: [u8; 2718usize],
    # [ doc = "0xf00 - Software Triggered Interrupt Register" ]
    pub stir: volatile::WriteOnly<Stir>,
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Ictr {
    bits: u32,
}

impl Ictr {
    # [ doc = "Bits 0:3 - Total number of interrupt lines in groups" ]
    pub fn intlinesnum(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
}

impl Default for Ictr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ictr { bits: 0u32 }
    }
}

impl Ictr {
    # [ doc = "Bits 0:3 - Total number of interrupt lines in groups" ]
    pub fn set_intlinesnum(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Iser {
    bits: u32,
}

impl Iser {
    # [ doc = "Bits 0:31 - SETENA" ]
    pub fn setena(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Iser {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Iser { bits: 0u32 }
    }
}

impl Iser {
    # [ doc = "Bits 0:31 - SETENA" ]
    pub fn set_setena(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Icer {
    bits: u32,
}

impl Icer {
    # [ doc = "Bits 0:31 - CLRENA" ]
    pub fn clrena(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Icer {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Icer { bits: 0u32 }
    }
}

impl Icer {
    # [ doc = "Bits 0:31 - CLRENA" ]
    pub fn set_clrena(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Ispr {
    bits: u32,
}

impl Ispr {
    # [ doc = "Bits 0:31 - SETPEND" ]
    pub fn setpend(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Ispr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ispr { bits: 0u32 }
    }
}

impl Ispr {
    # [ doc = "Bits 0:31 - SETPEND" ]
    pub fn set_setpend(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Icpr {
    bits: u32,
}

impl Icpr {
    # [ doc = "Bits 0:31 - CLRPEND" ]
    pub fn clrpend(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Icpr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Icpr { bits: 0u32 }
    }
}

impl Icpr {
    # [ doc = "Bits 0:31 - CLRPEND" ]
    pub fn set_clrpend(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Iabr {
    bits: u32,
}

impl Iabr {
    # [ doc = "Bits 0:31 - ACTIVE" ]
    pub fn active(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Iabr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Iabr { bits: 0u32 }
    }
}

impl Iabr {
    # [ doc = "Bits 0:31 - ACTIVE" ]
    pub fn set_active(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Ipr {
    bits: u8,
}

impl Ipr {
    # [ doc = "Bits 0:7 - IPR_N0" ]
    pub fn get(&self) -> u8 {
        self.bits
    }

    pub fn set(&mut self, value: u8) {
        self.bits = value;
    }
}

impl Default for Ipr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ipr { bits: 0u8 }
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct Stir {
    bits: u32,
}

impl Stir {
    # [ doc = "Bits 0:8 - interrupt to be triggered" ]
    pub fn intid(&self) -> u16 {
        self.bits.get_range(0u8..9u8) as u16
    }
}

impl Default for Stir {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Stir { bits: 0u32 }
    }
}

impl Stir {
    # [ doc = "Bits 0:8 - interrupt to be triggered" ]
    pub fn set_intid(&mut self, value: u16) {
        self.bits.set_range(0u8..9u8, value as u32);
    }
}
