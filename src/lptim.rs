// autogenerated

use volatile;
use bit_field::BitField;

# [ doc = "Low power timer" ]
# [ repr ( C ) ]
pub struct Lptim {
    # [ doc = "0x00 - Interrupt and Status Register" ]
    pub isr: volatile::ReadOnly<Isr>,
    # [ doc = "0x04 - Interrupt Clear Register" ]
    pub icr: volatile::WriteOnly<Icr>,
    # [ doc = "0x08 - Interrupt Enable Register" ]
    pub ier: volatile::ReadWrite<Ier>,
    # [ doc = "0x0c - Configuration Register" ]
    pub cfgr: volatile::ReadWrite<Cfgr>,
    # [ doc = "0x10 - Control Register" ]
    pub cr: volatile::ReadWrite<Cr>,
    # [ doc = "0x14 - Compare Register" ]
    pub cmp: volatile::ReadWrite<Cmp>,
    # [ doc = "0x18 - Autoreload Register" ]
    pub arr: volatile::ReadWrite<Arr>,
    # [ doc = "0x1c - Counter Register" ]
    pub cnt: volatile::ReadOnly<Cnt>,
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Isr {
    bits: u32,
}

impl Isr {
    # [ doc = "Bit 6 - Counter direction change up to down" ]
    pub fn down(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 5 - Counter direction change down to up" ]
    pub fn up(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Autoreload register update OK" ]
    pub fn arrok(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Compare register update OK" ]
    pub fn cmpok(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - External trigger edge event" ]
    pub fn exttrig(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Autoreload match" ]
    pub fn arrm(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Compare match" ]
    pub fn cmpm(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Isr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Isr { bits: 0u32 }
    }
}

impl Isr {
    # [ doc = "Bit 6 - Counter direction change up to down" ]
    pub fn set_down(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 5 - Counter direction change down to up" ]
    pub fn set_up(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Autoreload register update OK" ]
    pub fn set_arrok(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Compare register update OK" ]
    pub fn set_cmpok(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - External trigger edge event" ]
    pub fn set_exttrig(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Autoreload match" ]
    pub fn set_arrm(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Compare match" ]
    pub fn set_cmpm(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Icr {
    bits: u32,
}

impl Icr {
    # [ doc = "Bit 6 - Direction change to down Clear Flag" ]
    pub fn downcf(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 5 - Direction change to UP Clear Flag" ]
    pub fn upcf(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Autoreload register update OK Clear Flag" ]
    pub fn arrokcf(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Compare register update OK Clear Flag" ]
    pub fn cmpokcf(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - External trigger valid edge Clear Flag" ]
    pub fn exttrigcf(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Autoreload match Clear Flag" ]
    pub fn arrmcf(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - compare match Clear Flag" ]
    pub fn cmpmcf(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Icr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Icr { bits: 0u32 }
    }
}

impl Icr {
    # [ doc = "Bit 6 - Direction change to down Clear Flag" ]
    pub fn set_downcf(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 5 - Direction change to UP Clear Flag" ]
    pub fn set_upcf(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Autoreload register update OK Clear Flag" ]
    pub fn set_arrokcf(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Compare register update OK Clear Flag" ]
    pub fn set_cmpokcf(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - External trigger valid edge Clear Flag" ]
    pub fn set_exttrigcf(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Autoreload match Clear Flag" ]
    pub fn set_arrmcf(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - compare match Clear Flag" ]
    pub fn set_cmpmcf(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ier {
    bits: u32,
}

impl Ier {
    # [ doc = "Bit 6 - Direction change to down Interrupt Enable" ]
    pub fn downie(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 5 - Direction change to UP Interrupt Enable" ]
    pub fn upie(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Autoreload register update OK Interrupt Enable" ]
    pub fn arrokie(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Compare register update OK Interrupt Enable" ]
    pub fn cmpokie(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - External trigger valid edge Interrupt Enable" ]
    pub fn exttrigie(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Autoreload match Interrupt Enable" ]
    pub fn arrmie(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Compare match Interrupt Enable" ]
    pub fn cmpmie(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Ier {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ier { bits: 0u32 }
    }
}

impl Ier {
    # [ doc = "Bit 6 - Direction change to down Interrupt Enable" ]
    pub fn set_downie(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 5 - Direction change to UP Interrupt Enable" ]
    pub fn set_upie(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Autoreload register update OK Interrupt Enable" ]
    pub fn set_arrokie(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Compare register update OK Interrupt Enable" ]
    pub fn set_cmpokie(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - External trigger valid edge Interrupt Enable" ]
    pub fn set_exttrigie(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Autoreload match Interrupt Enable" ]
    pub fn set_arrmie(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Compare match Interrupt Enable" ]
    pub fn set_cmpmie(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Cfgr {
    bits: u32,
}

impl Cfgr {
    # [ doc = "Bit 24 - Encoder mode enable" ]
    pub fn enc(&self) -> bool {
        self.bits.get_bit(24u8)
    }
    # [ doc = "Bit 23 - counter mode enabled" ]
    pub fn countmode(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bit 22 - Registers update mode" ]
    pub fn preload(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bit 21 - Waveform shape polarity" ]
    pub fn wavpol(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 20 - Waveform shape" ]
    pub fn wave(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 19 - Timeout enable" ]
    pub fn timout(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bits 17:18 - Trigger enable and polarity" ]
    pub fn trigen(&self) -> u8 {
        self.bits.get_range(17u8..19u8) as u8
    }
    # [ doc = "Bits 13:15 - Trigger selector" ]
    pub fn trigsel(&self) -> u8 {
        self.bits.get_range(13u8..16u8) as u8
    }
    # [ doc = "Bits 9:11 - Clock prescaler" ]
    pub fn presc(&self) -> u8 {
        self.bits.get_range(9u8..12u8) as u8
    }
    # [ doc = "Bits 6:7 - Configurable digital filter for trigger" ]
    pub fn trgflt(&self) -> u8 {
        self.bits.get_range(6u8..8u8) as u8
    }
    # [ doc = "Bits 3:4 - Configurable digital filter for external clock" ]
    pub fn ckflt(&self) -> u8 {
        self.bits.get_range(3u8..5u8) as u8
    }
    # [ doc = "Bits 1:2 - Clock Polarity" ]
    pub fn ckpol(&self) -> u8 {
        self.bits.get_range(1u8..3u8) as u8
    }
    # [ doc = "Bit 0 - Clock selector" ]
    pub fn cksel(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Cfgr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Cfgr { bits: 0u32 }
    }
}

impl Cfgr {
    # [ doc = "Bit 24 - Encoder mode enable" ]
    pub fn set_enc(&mut self, value: bool) {
        self.bits.set_bit(24u8, value);
    }
    # [ doc = "Bit 23 - counter mode enabled" ]
    pub fn set_countmode(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 22 - Registers update mode" ]
    pub fn set_preload(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 21 - Waveform shape polarity" ]
    pub fn set_wavpol(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 20 - Waveform shape" ]
    pub fn set_wave(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 19 - Timeout enable" ]
    pub fn set_timout(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bits 17:18 - Trigger enable and polarity" ]
    pub fn set_trigen(&mut self, value: u8) {
        self.bits.set_range(17u8..19u8, value as u32);
    }
    # [ doc = "Bits 13:15 - Trigger selector" ]
    pub fn set_trigsel(&mut self, value: u8) {
        self.bits.set_range(13u8..16u8, value as u32);
    }
    # [ doc = "Bits 9:11 - Clock prescaler" ]
    pub fn set_presc(&mut self, value: u8) {
        self.bits.set_range(9u8..12u8, value as u32);
    }
    # [ doc = "Bits 6:7 - Configurable digital filter for trigger" ]
    pub fn set_trgflt(&mut self, value: u8) {
        self.bits.set_range(6u8..8u8, value as u32);
    }
    # [ doc = "Bits 3:4 - Configurable digital filter for external clock" ]
    pub fn set_ckflt(&mut self, value: u8) {
        self.bits.set_range(3u8..5u8, value as u32);
    }
    # [ doc = "Bits 1:2 - Clock Polarity" ]
    pub fn set_ckpol(&mut self, value: u8) {
        self.bits.set_range(1u8..3u8, value as u32);
    }
    # [ doc = "Bit 0 - Clock selector" ]
    pub fn set_cksel(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Cr {
    bits: u32,
}

impl Cr {
    # [ doc = "Bit 2 - Timer start in continuous mode" ]
    pub fn cntstrt(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - LPTIM start in single mode" ]
    pub fn sngstrt(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - LPTIM Enable" ]
    pub fn enable(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Cr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Cr { bits: 0u32 }
    }
}

impl Cr {
    # [ doc = "Bit 2 - Timer start in continuous mode" ]
    pub fn set_cntstrt(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - LPTIM start in single mode" ]
    pub fn set_sngstrt(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - LPTIM Enable" ]
    pub fn set_enable(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Cmp {
    bits: u32,
}

impl Cmp {
    # [ doc = "Bits 0:15 - Compare value" ]
    pub fn cmp(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for Cmp {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Cmp { bits: 0u32 }
    }
}

impl Cmp {
    # [ doc = "Bits 0:15 - Compare value" ]
    pub fn set_cmp(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Arr {
    bits: u32,
}

impl Arr {
    # [ doc = "Bits 0:15 - Auto reload value" ]
    pub fn arr(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for Arr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Arr { bits: 1u32 }
    }
}

impl Arr {
    # [ doc = "Bits 0:15 - Auto reload value" ]
    pub fn set_arr(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Cnt {
    bits: u32,
}

impl Cnt {
    # [ doc = "Bits 0:15 - Counter value" ]
    pub fn cnt(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for Cnt {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Cnt { bits: 0u32 }
    }
}

impl Cnt {
    # [ doc = "Bits 0:15 - Counter value" ]
    pub fn set_cnt(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}
