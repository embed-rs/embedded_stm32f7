// autogenerated

use volatile;
use bit_field::BitField;

# [ doc = "QuadSPI interface" ]
# [ repr ( C ) ]
pub struct Quadspi {
    # [ doc = "0x00 - control register" ]
    pub cr: volatile::ReadWrite<Cr>,
    # [ doc = "0x04 - device configuration register" ]
    pub dcr: volatile::ReadWrite<Dcr>,
    # [ doc = "0x08 - status register" ]
    pub sr: volatile::ReadOnly<Sr>,
    # [ doc = "0x0c - flag clear register" ]
    pub fcr: volatile::ReadWrite<Fcr>,
    # [ doc = "0x10 - data length register" ]
    pub dlr: volatile::ReadWrite<Dlr>,
    # [ doc = "0x14 - communication configuration register" ]
    pub ccr: volatile::ReadWrite<Ccr>,
    # [ doc = "0x18 - address register" ]
    pub ar: volatile::ReadWrite<Ar>,
    # [ doc = "0x1c - ABR" ]
    pub abr: volatile::ReadWrite<Abr>,
    # [ doc = "0x20 - data register" ]
    pub dr: volatile::ReadWrite<Dr>,
    # [ doc = "0x24 - polling status mask register" ]
    pub psmkr: volatile::ReadWrite<Psmkr>,
    # [ doc = "0x28 - polling status match register" ]
    pub psmar: volatile::ReadWrite<Psmar>,
    # [ doc = "0x2c - polling interval register" ]
    pub pir: volatile::ReadWrite<Pir>,
    # [ doc = "0x30 - low-power timeout register" ]
    pub lptr: volatile::ReadWrite<Lptr>,
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Cr {
    bits: u32,
}

impl Cr {
    # [ doc = "Bits 24:31 - Clock prescaler" ]
    pub fn prescaler(&self) -> u8 {
        self.bits.get_range(24u8..32u8) as u8
    }
    # [ doc = "Bit 23 - Polling match mode" ]
    pub fn pmm(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bit 22 - Automatic poll mode stop" ]
    pub fn apms(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bit 20 - TimeOut interrupt enable" ]
    pub fn toie(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 19 - Status match interrupt enable" ]
    pub fn smie(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 18 - FIFO threshold interrupt enable" ]
    pub fn ftie(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 17 - Transfer complete interrupt enable" ]
    pub fn tcie(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bit 16 - Transfer error interrupt enable" ]
    pub fn teie(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bits 8:12 - IFO threshold level" ]
    pub fn fthres(&self) -> u8 {
        self.bits.get_range(8u8..13u8) as u8
    }
    # [ doc = "Bit 7 - FLASH memory selection" ]
    pub fn fsel(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 6 - Dual-flash mode" ]
    pub fn dfm(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 4 - Sample shift" ]
    pub fn sshift(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Timeout counter enable" ]
    pub fn tcen(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - DMA enable" ]
    pub fn dmaen(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Abort request" ]
    pub fn abort(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Enable" ]
    pub fn en(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Cr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Cr { bits: 0u32 }
    }
}

impl Cr {
    # [ doc = "Bits 24:31 - Clock prescaler" ]
    pub fn set_prescaler(&mut self, value: u8) {
        self.bits.set_range(24u8..32u8, value as u32);
    }
    # [ doc = "Bit 23 - Polling match mode" ]
    pub fn set_pmm(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 22 - Automatic poll mode stop" ]
    pub fn set_apms(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 20 - TimeOut interrupt enable" ]
    pub fn set_toie(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 19 - Status match interrupt enable" ]
    pub fn set_smie(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 18 - FIFO threshold interrupt enable" ]
    pub fn set_ftie(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 17 - Transfer complete interrupt enable" ]
    pub fn set_tcie(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bit 16 - Transfer error interrupt enable" ]
    pub fn set_teie(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bits 8:12 - IFO threshold level" ]
    pub fn set_fthres(&mut self, value: u8) {
        self.bits.set_range(8u8..13u8, value as u32);
    }
    # [ doc = "Bit 7 - FLASH memory selection" ]
    pub fn set_fsel(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 6 - Dual-flash mode" ]
    pub fn set_dfm(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 4 - Sample shift" ]
    pub fn set_sshift(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Timeout counter enable" ]
    pub fn set_tcen(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - DMA enable" ]
    pub fn set_dmaen(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Abort request" ]
    pub fn set_abort(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Enable" ]
    pub fn set_en(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Dcr {
    bits: u32,
}

impl Dcr {
    # [ doc = "Bits 16:20 - FLASH memory size" ]
    pub fn fsize(&self) -> u8 {
        self.bits.get_range(16u8..21u8) as u8
    }
    # [ doc = "Bits 8:10 - Chip select high time" ]
    pub fn csht(&self) -> u8 {
        self.bits.get_range(8u8..11u8) as u8
    }
    # [ doc = "Bit 0 - Mode 0 / mode 3" ]
    pub fn ckmode(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Dcr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Dcr { bits: 0u32 }
    }
}

impl Dcr {
    # [ doc = "Bits 16:20 - FLASH memory size" ]
    pub fn set_fsize(&mut self, value: u8) {
        self.bits.set_range(16u8..21u8, value as u32);
    }
    # [ doc = "Bits 8:10 - Chip select high time" ]
    pub fn set_csht(&mut self, value: u8) {
        self.bits.set_range(8u8..11u8, value as u32);
    }
    # [ doc = "Bit 0 - Mode 0 / mode 3" ]
    pub fn set_ckmode(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Sr {
    bits: u32,
}

impl Sr {
    # [ doc = "Bits 8:14 - FIFO level" ]
    pub fn flevel(&self) -> u8 {
        self.bits.get_range(8u8..15u8) as u8
    }
    # [ doc = "Bit 5 - Busy" ]
    pub fn busy(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Timeout flag" ]
    pub fn tof(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Status match flag" ]
    pub fn smf(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - FIFO threshold flag" ]
    pub fn ftf(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Transfer complete flag" ]
    pub fn tcf(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Transfer error flag" ]
    pub fn tef(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Sr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Sr { bits: 0u32 }
    }
}

impl Sr {
    # [ doc = "Bits 8:14 - FIFO level" ]
    pub fn set_flevel(&mut self, value: u8) {
        self.bits.set_range(8u8..15u8, value as u32);
    }
    # [ doc = "Bit 5 - Busy" ]
    pub fn set_busy(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Timeout flag" ]
    pub fn set_tof(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Status match flag" ]
    pub fn set_smf(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - FIFO threshold flag" ]
    pub fn set_ftf(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Transfer complete flag" ]
    pub fn set_tcf(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Transfer error flag" ]
    pub fn set_tef(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Fcr {
    bits: u32,
}

impl Fcr {
    # [ doc = "Bit 4 - Clear timeout flag" ]
    pub fn ctof(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Clear status match flag" ]
    pub fn csmf(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 1 - Clear transfer complete flag" ]
    pub fn ctcf(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Clear transfer error flag" ]
    pub fn ctef(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Fcr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Fcr { bits: 0u32 }
    }
}

impl Fcr {
    # [ doc = "Bit 4 - Clear timeout flag" ]
    pub fn set_ctof(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - Clear status match flag" ]
    pub fn set_csmf(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 1 - Clear transfer complete flag" ]
    pub fn set_ctcf(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Clear transfer error flag" ]
    pub fn set_ctef(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Dlr {
    bits: u32,
}

impl Dlr {
    # [ doc = "Bits 0:31 - Data length" ]
    pub fn dl(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Dlr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Dlr { bits: 0u32 }
    }
}

impl Dlr {
    # [ doc = "Bits 0:31 - Data length" ]
    pub fn set_dl(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ccr {
    bits: u32,
}

impl Ccr {
    # [ doc = "Bit 31 - Double data rate mode" ]
    pub fn ddrm(&self) -> bool {
        self.bits.get_bit(31u8)
    }
    # [ doc = "Bit 30 - DDR hold half cycle" ]
    pub fn dhhc(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 28 - Send instruction only once mode" ]
    pub fn sioo(&self) -> bool {
        self.bits.get_bit(28u8)
    }
    # [ doc = "Bits 26:27 - Functional mode" ]
    pub fn fmode(&self) -> u8 {
        self.bits.get_range(26u8..28u8) as u8
    }
    # [ doc = "Bits 24:25 - Data mode" ]
    pub fn dmode(&self) -> u8 {
        self.bits.get_range(24u8..26u8) as u8
    }
    # [ doc = "Bits 18:22 - Number of dummy cycles" ]
    pub fn dcyc(&self) -> u8 {
        self.bits.get_range(18u8..23u8) as u8
    }
    # [ doc = "Bits 16:17 - Alternate bytes size" ]
    pub fn absize(&self) -> u8 {
        self.bits.get_range(16u8..18u8) as u8
    }
    # [ doc = "Bits 14:15 - Alternate bytes mode" ]
    pub fn abmode(&self) -> u8 {
        self.bits.get_range(14u8..16u8) as u8
    }
    # [ doc = "Bits 12:13 - Address size" ]
    pub fn adsize(&self) -> u8 {
        self.bits.get_range(12u8..14u8) as u8
    }
    # [ doc = "Bits 10:11 - Address mode" ]
    pub fn admode(&self) -> u8 {
        self.bits.get_range(10u8..12u8) as u8
    }
    # [ doc = "Bits 8:9 - Instruction mode" ]
    pub fn imode(&self) -> u8 {
        self.bits.get_range(8u8..10u8) as u8
    }
    # [ doc = "Bits 0:7 - Instruction" ]
    pub fn instruction(&self) -> u8 {
        self.bits.get_range(0u8..8u8) as u8
    }
}

impl Default for Ccr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ccr { bits: 0u32 }
    }
}

impl Ccr {
    # [ doc = "Bit 31 - Double data rate mode" ]
    pub fn set_ddrm(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
    # [ doc = "Bit 30 - DDR hold half cycle" ]
    pub fn set_dhhc(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 28 - Send instruction only once mode" ]
    pub fn set_sioo(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bits 26:27 - Functional mode" ]
    pub fn set_fmode(&mut self, value: u8) {
        self.bits.set_range(26u8..28u8, value as u32);
    }
    # [ doc = "Bits 24:25 - Data mode" ]
    pub fn set_dmode(&mut self, value: u8) {
        self.bits.set_range(24u8..26u8, value as u32);
    }
    # [ doc = "Bits 18:22 - Number of dummy cycles" ]
    pub fn set_dcyc(&mut self, value: u8) {
        self.bits.set_range(18u8..23u8, value as u32);
    }
    # [ doc = "Bits 16:17 - Alternate bytes size" ]
    pub fn set_absize(&mut self, value: u8) {
        self.bits.set_range(16u8..18u8, value as u32);
    }
    # [ doc = "Bits 14:15 - Alternate bytes mode" ]
    pub fn set_abmode(&mut self, value: u8) {
        self.bits.set_range(14u8..16u8, value as u32);
    }
    # [ doc = "Bits 12:13 - Address size" ]
    pub fn set_adsize(&mut self, value: u8) {
        self.bits.set_range(12u8..14u8, value as u32);
    }
    # [ doc = "Bits 10:11 - Address mode" ]
    pub fn set_admode(&mut self, value: u8) {
        self.bits.set_range(10u8..12u8, value as u32);
    }
    # [ doc = "Bits 8:9 - Instruction mode" ]
    pub fn set_imode(&mut self, value: u8) {
        self.bits.set_range(8u8..10u8, value as u32);
    }
    # [ doc = "Bits 0:7 - Instruction" ]
    pub fn set_instruction(&mut self, value: u8) {
        self.bits.set_range(0u8..8u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Ar {
    bits: u32,
}

impl Ar {
    # [ doc = "Bits 0:31 - Address" ]
    pub fn address(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Ar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Ar { bits: 0u32 }
    }
}

impl Ar {
    # [ doc = "Bits 0:31 - Address" ]
    pub fn set_address(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Abr {
    bits: u32,
}

impl Abr {
    # [ doc = "Bits 0:31 - ALTERNATE" ]
    pub fn alternate(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Abr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Abr { bits: 0u32 }
    }
}

impl Abr {
    # [ doc = "Bits 0:31 - ALTERNATE" ]
    pub fn set_alternate(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Dr {
    bits: u32,
}

impl Dr {
    # [ doc = "Bits 0:31 - Data" ]
    pub fn data(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Dr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Dr { bits: 0u32 }
    }
}

impl Dr {
    # [ doc = "Bits 0:31 - Data" ]
    pub fn set_data(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Psmkr {
    bits: u32,
}

impl Psmkr {
    # [ doc = "Bits 0:31 - Status mask" ]
    pub fn mask(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Psmkr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Psmkr { bits: 0u32 }
    }
}

impl Psmkr {
    # [ doc = "Bits 0:31 - Status mask" ]
    pub fn set_mask(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Psmar {
    bits: u32,
}

impl Psmar {
    # [ doc = "Bits 0:31 - Status match" ]
    pub fn match_(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for Psmar {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Psmar { bits: 0u32 }
    }
}

impl Psmar {
    # [ doc = "Bits 0:31 - Status match" ]
    pub fn set_match_(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Pir {
    bits: u32,
}

impl Pir {
    # [ doc = "Bits 0:15 - Polling interval" ]
    pub fn interval(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for Pir {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Pir { bits: 0u32 }
    }
}

impl Pir {
    # [ doc = "Bits 0:15 - Polling interval" ]
    pub fn set_interval(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Lptr {
    bits: u32,
}

impl Lptr {
    # [ doc = "Bits 0:15 - Timeout period" ]
    pub fn timeout(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for Lptr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Lptr { bits: 0u32 }
    }
}

impl Lptr {
    # [ doc = "Bits 0:15 - Timeout period" ]
    pub fn set_timeout(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}
