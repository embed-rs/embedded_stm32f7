// autogenerated

use volatile;
use bit_field::BitField;

# [ doc = "Serial peripheral interface" ]
# [ repr ( C ) ]
pub struct Spi {
    # [ doc = "0x00 - control register 1" ]
    pub cr1: volatile::ReadWrite<Cr1>,
    # [ doc = "0x04 - control register 2" ]
    pub cr2: volatile::ReadWrite<Cr2>,
    # [ doc = "0x08 - status register" ]
    pub sr: volatile::ReadWrite<Sr>,
    # [ doc = "0x0c - data register" ]
    pub dr: volatile::ReadWrite<Dr>,
    # [ doc = "0x10 - CRC polynomial register" ]
    pub crcpr: volatile::ReadWrite<Crcpr>,
    # [ doc = "0x14 - RX CRC register" ]
    pub rxcrcr: volatile::ReadOnly<Rxcrcr>,
    # [ doc = "0x18 - TX CRC register" ]
    pub txcrcr: volatile::ReadOnly<Txcrcr>,
    # [ doc = "0x1c - I2S configuration register" ]
    pub i2scfgr: volatile::ReadWrite<I2scfgr>,
    # [ doc = "0x20 - I2S prescaler register" ]
    pub i2spr: volatile::ReadWrite<I2spr>,
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Cr1 {
    bits: u32,
}

impl Cr1 {
    # [ doc = "Bit 15 - Bidirectional data mode enable" ]
    pub fn bidimode(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 14 - Output enable in bidirectional mode" ]
    pub fn bidioe(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 13 - Hardware CRC calculation enable" ]
    pub fn crcen(&self) -> bool {
        self.bits.get_bit(13u8)
    }
    # [ doc = "Bit 12 - CRC transfer next" ]
    pub fn crcnext(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 11 - Data frame format" ]
    pub fn dff(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 10 - Receive only" ]
    pub fn rxonly(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 9 - Software slave management" ]
    pub fn ssm(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - Internal slave select" ]
    pub fn ssi(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 7 - Frame format" ]
    pub fn lsbfirst(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 6 - SPI enable" ]
    pub fn spe(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bits 3:5 - Baud rate control" ]
    pub fn br(&self) -> u8 {
        self.bits.get_range(3u8..6u8) as u8
    }
    # [ doc = "Bit 2 - Master selection" ]
    pub fn mstr(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Clock polarity" ]
    pub fn cpol(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Clock phase" ]
    pub fn cpha(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Cr1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Cr1 { bits: 0u32 }
    }
}

impl Cr1 {
    # [ doc = "Bit 15 - Bidirectional data mode enable" ]
    pub fn set_bidimode(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 14 - Output enable in bidirectional mode" ]
    pub fn set_bidioe(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 13 - Hardware CRC calculation enable" ]
    pub fn set_crcen(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
    # [ doc = "Bit 12 - CRC transfer next" ]
    pub fn set_crcnext(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 11 - Data frame format" ]
    pub fn set_dff(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 10 - Receive only" ]
    pub fn set_rxonly(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 9 - Software slave management" ]
    pub fn set_ssm(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - Internal slave select" ]
    pub fn set_ssi(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 7 - Frame format" ]
    pub fn set_lsbfirst(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 6 - SPI enable" ]
    pub fn set_spe(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bits 3:5 - Baud rate control" ]
    pub fn set_br(&mut self, value: u8) {
        self.bits.set_range(3u8..6u8, value as u32);
    }
    # [ doc = "Bit 2 - Master selection" ]
    pub fn set_mstr(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Clock polarity" ]
    pub fn set_cpol(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Clock phase" ]
    pub fn set_cpha(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Cr2 {
    bits: u32,
}

impl Cr2 {
    # [ doc = "Bit 14 - Last DMA transfer for transmission" ]
    pub fn ldma_tx(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 13 - Last DMA transfer for reception" ]
    pub fn ldma_rx(&self) -> bool {
        self.bits.get_bit(13u8)
    }
    # [ doc = "Bit 12 - FIFO reception threshold" ]
    pub fn frxth(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bits 8:11 - Data size" ]
    pub fn ds(&self) -> u8 {
        self.bits.get_range(8u8..12u8) as u8
    }
    # [ doc = "Bit 7 - Tx buffer empty interrupt enable" ]
    pub fn txeie(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 6 - RX buffer not empty interrupt enable" ]
    pub fn rxneie(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 5 - Error interrupt enable" ]
    pub fn errie(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - Frame format" ]
    pub fn frf(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - NSS pulse management" ]
    pub fn nssp(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - SS output enable" ]
    pub fn ssoe(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Tx buffer DMA enable" ]
    pub fn txdmaen(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Rx buffer DMA enable" ]
    pub fn rxdmaen(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Cr2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Cr2 { bits: 1792u32 }
    }
}

impl Cr2 {
    # [ doc = "Bit 14 - Last DMA transfer for transmission" ]
    pub fn set_ldma_tx(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 13 - Last DMA transfer for reception" ]
    pub fn set_ldma_rx(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
    # [ doc = "Bit 12 - FIFO reception threshold" ]
    pub fn set_frxth(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bits 8:11 - Data size" ]
    pub fn set_ds(&mut self, value: u8) {
        self.bits.set_range(8u8..12u8, value as u32);
    }
    # [ doc = "Bit 7 - Tx buffer empty interrupt enable" ]
    pub fn set_txeie(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 6 - RX buffer not empty interrupt enable" ]
    pub fn set_rxneie(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 5 - Error interrupt enable" ]
    pub fn set_errie(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 4 - Frame format" ]
    pub fn set_frf(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 3 - NSS pulse management" ]
    pub fn set_nssp(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 2 - SS output enable" ]
    pub fn set_ssoe(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 1 - Tx buffer DMA enable" ]
    pub fn set_txdmaen(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 0 - Rx buffer DMA enable" ]
    pub fn set_rxdmaen(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Sr {
    bits: u32,
}

impl Sr {
    # [ doc = "Bits 11:12 - FIFO transmission level" ]
    pub fn ftlvl(&self) -> u8 {
        self.bits.get_range(11u8..13u8) as u8
    }
    # [ doc = "Bits 9:10 - FIFO reception level" ]
    pub fn frlvl(&self) -> u8 {
        self.bits.get_range(9u8..11u8) as u8
    }
    # [ doc = "Bit 8 - TI frame format error" ]
    pub fn tifrfe(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 7 - Busy flag" ]
    pub fn bsy(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 6 - Overrun flag" ]
    pub fn ovr(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 5 - Mode fault" ]
    pub fn modf(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 4 - CRC error flag" ]
    pub fn crcerr(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 3 - Underrun flag" ]
    pub fn udr(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 2 - Channel side" ]
    pub fn chside(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 1 - Transmit buffer empty" ]
    pub fn txe(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 0 - Receive buffer not empty" ]
    pub fn rxne(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for Sr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Sr { bits: 2u32 }
    }
}

impl Sr {
    # [ doc = "Bit 4 - CRC error flag" ]
    pub fn set_crcerr(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Dr {
    bits: u32,
}

impl Dr {
    # [ doc = "Bits 0:15 - Data register" ]
    pub fn dr(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for Dr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Dr { bits: 0u32 }
    }
}

impl Dr {
    # [ doc = "Bits 0:15 - Data register" ]
    pub fn set_dr(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Crcpr {
    bits: u32,
}

impl Crcpr {
    # [ doc = "Bits 0:15 - CRC polynomial register" ]
    pub fn crcpoly(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for Crcpr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Crcpr { bits: 7u32 }
    }
}

impl Crcpr {
    # [ doc = "Bits 0:15 - CRC polynomial register" ]
    pub fn set_crcpoly(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Rxcrcr {
    bits: u32,
}

impl Rxcrcr {
    # [ doc = "Bits 0:15 - Rx CRC register" ]
    pub fn rx_crc(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for Rxcrcr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Rxcrcr { bits: 0u32 }
    }
}

impl Rxcrcr {
    # [ doc = "Bits 0:15 - Rx CRC register" ]
    pub fn set_rx_crc(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct Txcrcr {
    bits: u32,
}

impl Txcrcr {
    # [ doc = "Bits 0:15 - Tx CRC register" ]
    pub fn tx_crc(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for Txcrcr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        Txcrcr { bits: 0u32 }
    }
}

impl Txcrcr {
    # [ doc = "Bits 0:15 - Tx CRC register" ]
    pub fn set_tx_crc(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct I2scfgr {
    bits: u32,
}

impl I2scfgr {
    # [ doc = "Bit 12 - Asynchronous start enable" ]
    pub fn astrten(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 11 - I2S mode selection" ]
    pub fn i2smod(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 10 - I2S Enable" ]
    pub fn i2se(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bits 8:9 - I2S configuration mode" ]
    pub fn i2scfg(&self) -> u8 {
        self.bits.get_range(8u8..10u8) as u8
    }
    # [ doc = "Bit 7 - PCM frame synchronization" ]
    pub fn pcmsync(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bits 4:5 - I2S standard selection" ]
    pub fn i2sstd(&self) -> u8 {
        self.bits.get_range(4u8..6u8) as u8
    }
    # [ doc = "Bit 3 - Steady state clock polarity" ]
    pub fn ckpol(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bits 1:2 - Data length to be transferred" ]
    pub fn datlen(&self) -> u8 {
        self.bits.get_range(1u8..3u8) as u8
    }
    # [ doc = "Bit 0 - Channel length (number of bits per audio channel)" ]
    pub fn chlen(&self) -> bool {
        self.bits.get_bit(0u8)
    }
}

impl Default for I2scfgr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        I2scfgr { bits: 0u32 }
    }
}

impl I2scfgr {
    # [ doc = "Bit 12 - Asynchronous start enable" ]
    pub fn set_astrten(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 11 - I2S mode selection" ]
    pub fn set_i2smod(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 10 - I2S Enable" ]
    pub fn set_i2se(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bits 8:9 - I2S configuration mode" ]
    pub fn set_i2scfg(&mut self, value: u8) {
        self.bits.set_range(8u8..10u8, value as u32);
    }
    # [ doc = "Bit 7 - PCM frame synchronization" ]
    pub fn set_pcmsync(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bits 4:5 - I2S standard selection" ]
    pub fn set_i2sstd(&mut self, value: u8) {
        self.bits.set_range(4u8..6u8, value as u32);
    }
    # [ doc = "Bit 3 - Steady state clock polarity" ]
    pub fn set_ckpol(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bits 1:2 - Data length to be transferred" ]
    pub fn set_datlen(&mut self, value: u8) {
        self.bits.set_range(1u8..3u8, value as u32);
    }
    # [ doc = "Bit 0 - Channel length (number of bits per audio channel)" ]
    pub fn set_chlen(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
}

# [ derive ( Debug , Clone , Copy ) ]
# [ repr ( C ) ]
pub struct I2spr {
    bits: u32,
}

impl I2spr {
    # [ doc = "Bit 9 - Master clock output enable" ]
    pub fn mckoe(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 8 - Odd factor for the prescaler" ]
    pub fn odd(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bits 0:7 - I2S Linear prescaler" ]
    pub fn i2sdiv(&self) -> u8 {
        self.bits.get_range(0u8..8u8) as u8
    }
}

impl Default for I2spr {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        I2spr { bits: 10u32 }
    }
}

impl I2spr {
    # [ doc = "Bit 9 - Master clock output enable" ]
    pub fn set_mckoe(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 8 - Odd factor for the prescaler" ]
    pub fn set_odd(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bits 0:7 - I2S Linear prescaler" ]
    pub fn set_i2sdiv(&mut self, value: u8) {
        self.bits.set_range(0u8..8u8, value as u32);
    }
}
